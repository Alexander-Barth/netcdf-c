#line 6 "ncx.m4"
/* Do not edit this file. It is produced from the corresponding .m4 source */
#line 8
/*
 *  Copyright (C) 2014, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id: ncx.m4 2601 2016-11-07 04:54:42Z wkliao $ */

#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif

#line 22



#line 31

#line 38

#line 38
#if HAVE_CONFIG_H
#line 38
#include <config.h>
#line 38
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#line 50

#line 50
#pragma GCC diagnostic ignored "-Wdeprecated"
#line 50
#include "ncx.h"
#line 50
#include "nc3dispatch.h"

#line 69




#ifdef HAVE_INTTYPES_H
#include <inttypes.h> /* uint16_t, uint32_t, uint64_t */
#elif defined(HAVE_STDINT_H)
#include <stdint.h>   /* uint16_t, uint32_t, uint64_t */
#endif

#line 97

#line 115

/*
 * The only error code returned from subroutines in this file is NC_ERANGE,
 * if errors are detected.
 */

/*
 * An external data representation interface.
 */

/* alias poorly named limits.h macros */
#define  SHORT_MAX  SHRT_MAX
#define  SHORT_MIN  SHRT_MIN
#define USHORT_MAX USHRT_MAX
#ifndef LLONG_MAX
#   define LLONG_MAX	9223372036854775807LL
#   define LLONG_MIN	(-LLONG_MAX - 1LL)
#   define ULLONG_MAX	18446744073709551615ULL
#endif
#ifndef LONG_LONG_MAX
#define LONG_LONG_MAX LLONG_MAX
#endif
#ifndef LONGLONG_MAX
#define LONGLONG_MAX LONG_LONG_MAX
#endif
#ifndef LONG_LONG_MIN
#define LONG_LONG_MIN LLONG_MIN
#endif
#ifndef LONGLONG_MIN
#define LONGLONG_MIN LONG_LONG_MIN
#endif
#ifndef ULONG_LONG_MAX
#define ULONG_LONG_MAX ULLONG_MAX
#endif
#ifndef ULONGLONG_MAX
#define ULONGLONG_MAX ULONG_LONG_MAX
#endif
#include <float.h>
#ifndef FLT_MAX /* This POSIX macro missing on some systems */
# ifndef NO_IEEE_FLOAT
# define FLT_MAX 3.40282347e+38f
# else
# error "You will need to define FLT_MAX"
# endif
#endif
/* alias poorly named float.h macros */
#define FLOAT_MAX FLT_MAX
#define FLOAT_MIN (-FLT_MAX)
#define DOUBLE_MAX DBL_MAX
#define DOUBLE_MIN (-DBL_MAX)
#define FLOAT_MAX_EXP FLT_MAX_EXP
#define DOUBLE_MAX_EXP DBL_MAX_EXP
#include <assert.h>
#define UCHAR_MIN 0
#define Min(a,b) ((a) < (b) ? (a) : (b))
#define Max(a,b) ((a) > (b) ? (a) : (b))

#ifndef SIZEOF_UCHAR
#ifdef  SIZEOF_UNSIGNED_CHAR
#define SIZEOF_UCHAR SIZEOF_UNSIGNED_CHAR
#else
#error "unknown SIZEOF_UCHAR"
#endif
#endif

#ifndef SIZEOF_USHORT
#ifdef  SIZEOF_UNSIGNED_SHORT_INT
#define SIZEOF_USHORT SIZEOF_UNSIGNED_SHORT_INT
#elif defined(SIZEOF_UNSIGNED_SHORT)
#define SIZEOF_USHORT SIZEOF_UNSIGNED_SHORT
#else
#error "unknown SIZEOF_USHORT"
#endif
#endif

#ifndef SIZEOF_UINT
#ifdef  SIZEOF_UNSIGNED_INT
#define SIZEOF_UINT SIZEOF_UNSIGNED_INT
#else
#error "unknown SIZEOF_UINT"
#endif
#endif

#ifndef SIZEOF_LONGLONG
#ifdef  SIZEOF_LONG_LONG
#define SIZEOF_LONGLONG SIZEOF_LONG_LONG
#else
#error "unknown SIZEOF_LONGLONG"
#endif
#endif

#ifndef SIZEOF_INT64
#ifdef  SIZEOF_LONG_LONG
#define SIZEOF_INT64 SIZEOF_LONG_LONG
#elif defined(SIZEOF_LONGLONG)
#define SIZEOF_INT64 SIZEOF_LONGLONG
#else
#error "unknown SIZEOF_INT64"
#endif
#endif

#ifndef SIZEOF_ULONGLONG
#ifdef  SIZEOF_UNSIGNED_LONG_LONG
#define SIZEOF_ULONGLONG SIZEOF_UNSIGNED_LONG_LONG
#else
#error "unknown SIZEOF_ULONGLONG"
#endif
#endif

#ifndef SIZEOF_UINT64
#ifdef  SIZEOF_UNSIGNED_LONG_LONG
#define SIZEOF_UINT64 SIZEOF_UNSIGNED_LONG_LONG
#elif defined(SIZEOF_ULONGLONG)
#define SIZEOF_UINT64 SIZEOF_ULONGLONG
#else
#error "unknown SIZEOF_UINT64"
#endif
#endif

/*
 * If the machine's float domain is "smaller" than the external one
 * use the machine domain
 */
#if defined(FLT_MAX_EXP) && FLT_MAX_EXP < 128 /* 128 is X_FLT_MAX_EXP */
#undef X_FLOAT_MAX
# define X_FLOAT_MAX FLT_MAX
#undef X_FLOAT_MIN
# define X_FLOAT_MIN (-X_FLOAT_MAX)
#endif

#if defined(_SX) && _SX != 0 /* NEC SUPER UX */
#define LOOPCNT 256    /* must be no longer than hardware vector length */
#if _INT64
#undef  INT_MAX /* workaround cpp bug */
#define INT_MAX  X_INT_MAX
#undef  INT_MIN /* workaround cpp bug */
#define INT_MIN  X_INT_MIN
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  X_INT_MAX
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN  X_INT_MIN
#elif _LONG64
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  4294967295L
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN -4294967295L
#endif
#if !_FLOAT0
#error "FLOAT1 and FLOAT2 not supported"
#endif
#endif /* _SX */

static const char nada[X_ALIGN] = {0, 0, 0, 0};

#ifndef WORDS_BIGENDIAN
/* LITTLE_ENDIAN: DEC and intel */
/*
 * Routines to convert to BIG ENDIAN.
 * Optimize the swapn?b() and swap?b() routines aggressively.
 */

#define SWAP2(a) ( (((a) & 0xff) << 8) | \
                   (((a) >> 8) & 0xff) )

#define SWAP4(a) ( ((a) << 24) | \
                  (((a) <<  8) & 0x00ff0000) | \
                  (((a) >>  8) & 0x0000ff00) | \
                  (((a) >> 24) & 0x000000ff) )

#define SWAP8(a) ( (((a) & 0x00000000000000FFULL) << 56) | \
                   (((a) & 0x000000000000FF00ULL) << 40) | \
                   (((a) & 0x0000000000FF0000ULL) << 24) | \
                   (((a) & 0x00000000FF000000ULL) <<  8) | \
                   (((a) & 0x000000FF00000000ULL) >>  8) | \
                   (((a) & 0x0000FF0000000000ULL) >> 24) | \
                   (((a) & 0x00FF000000000000ULL) >> 40) | \
                   (((a) & 0xFF00000000000000ULL) >> 56) )


inline static void
swapn2b(void *dst, const void *src, size_t nn)
{
    /* it is OK if dst == src */
    int i;
    uint16_t *op = (uint16_t*) dst;
    uint16_t *ip = (uint16_t*) src;
    for (i=0; i<nn; i++) {
        op[i] = ip[i];
        op[i] = (uint16_t)SWAP2(op[i]);
    }
#if 0
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *
 *	while (nn-- > 0)
 *	{
 *		*op++ = *(++ip);
 *		*op++ = *(ip++ -1);
 *	}
 */
	while (nn > 3)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		nn -= 4;
	}
	while (nn-- > 0)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
	}
#endif
}

# ifndef vax
inline static void
swap4b(void *dst, const void *src)
{
    /* copy over, make the below swap in-place */
    uint32_t tmp = *(uint32_t*)src;
    tmp = SWAP4(tmp);
    memcpy(dst, &tmp, 4);

    /* Codes below will cause "break strict-aliasing rules" in gcc
    uint32_t *op = (uint32_t*)dst;
    *op = *(uint32_t*)src;
    *op = SWAP4(*op);
    */

    /* Below are copied from netCDF-4.
     * See https://bugtracking.unidata.ucar.edu/browse/NCF-338
     * Quote "One issue we are wrestling with is how compilers optimize this
     * code.  For some reason, we are actually needing to add an artificial
     * move to a 4 byte space to get it to work.  I think what is happening is
     * that the optimizer is bit shifting within a double, which is incorrect.
     * The following code actually does work correctly.
     *  This is in Linux land, gcc.
     *
     * However, the above in-place byte-swap does not appear affected by this.
     */
#if 0
    uint32_t *ip = (uint32_t*)src;
    uint32_t tempOut;  /* cannot use pointer when gcc O2 optimizer is used */
    tempOut = SWAP4(*ip);

    *(float *)dst = *(float *)(&tempOut);
#endif

    /* OLD implementation that results in four load and four store CPU
       instructions
    char *op = dst;
    const char *ip = src;
    op[0] = ip[3];
    op[1] = ip[2];
    op[2] = ip[1];
    op[3] = ip[0];
    */

}
# endif /* !vax */

inline static void
swapn4b(void *dst, const void *src, size_t nn)
{
    int i;
    uint32_t *op = (uint32_t*) dst;
    uint32_t *ip = (uint32_t*) src;
    for (i=0; i<nn; i++) {
        /* copy over, make the below swap in-place */
        op[i] = ip[i];
        op[i] = SWAP4(op[i]);
    }

#if 0
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while (nn-- > 0)
 *	{
 *		op[0] = ip[3];
 *		op[1] = ip[2];
 *		op[2] = ip[1];
 *		op[3] = ip[0];
 *		op += 4;
 *		ip += 4;
 *	}
 */
	while (nn > 3)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op[8] = ip[11];
		op[9] = ip[10];
		op[10] = ip[9];
		op[11] = ip[8];
		op[12] = ip[15];
		op[13] = ip[14];
		op[14] = ip[13];
		op[15] = ip[12];
		op += 16;
		ip += 16;
		nn -= 4;
	}
	while (nn-- > 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op += 4;
		ip += 4;
	}
#endif
}

# ifndef vax
inline static void
swap8b(void *dst, const void *src)
{
#ifdef FLOAT_WORDS_BIGENDIAN
    /* copy over, make the below swap in-place */
    *(uint64_t*)dst = *(uint64_t*)src;

    uint32_t *op = (uint32_t*)dst;
    *op = SWAP4(*op);
    op = (uint32_t*)((char*)dst+4);
    *op = SWAP4(*op);
#else
    uint64_t *op = (uint64_t*)dst;
    /* copy over, make the below swap in-place */
    *op = *(uint64_t*)src;
    *op = SWAP8(*op);
#endif

#if 0
	char *op = dst;
	const char *ip = src;
#  ifndef FLOAT_WORDS_BIGENDIAN
	op[0] = ip[7];
	op[1] = ip[6];
	op[2] = ip[5];
	op[3] = ip[4];
	op[4] = ip[3];
	op[5] = ip[2];
	op[6] = ip[1];
	op[7] = ip[0];
#  else
	op[0] = ip[3];
	op[1] = ip[2];
	op[2] = ip[1];
	op[3] = ip[0];
	op[4] = ip[7];
	op[5] = ip[6];
	op[6] = ip[5];
	op[7] = ip[4];
#endif
#endif
}
# endif /* !vax */

# ifndef vax
inline static void
swapn8b(void *dst, const void *src, size_t nn)
{
#ifdef FLOAT_WORDS_BIGENDIAN
    int i;
    uint64_t *dst_p = (uint64_t*) dst;
    uint64_t *src_p = (uint64_t*) src;
    for (i=0; i<nn; i++) {
        /* copy over, make the below swap in-place */
        dst_p[i] = src_p[i];
        uint32_t *op = (uint32_t*)(&dst_p[i]);
        *op = SWAP4(*op);
        op = (uint32_t*)((char*)op+4);
        *op = SWAP4(*op);
    }
#else
    int i;
    uint64_t *op = (uint64_t*) dst;
    uint64_t *ip = (uint64_t*) src;
    for (i=0; i<nn; i++) {
        /* copy over, make the below swap in-place */
        op[i] = ip[i];
        op[i] = SWAP8(op[i]);
    }
#endif

#if 0
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while (nn-- > 0)
 *	{
 *		op[0] = ip[7];
 *		op[1] = ip[6];
 *		op[2] = ip[5];
 *		op[3] = ip[4];
 *		op[4] = ip[3];
 *		op[5] = ip[2];
 *		op[6] = ip[1];
 *		op[7] = ip[0];
 *		op += 8;
 *		ip += 8;
 *	}
 */
#  ifndef FLOAT_WORDS_BIGENDIAN
	while (nn > 1)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op[8] = ip[15];
		op[9] = ip[14];
		op[10] = ip[13];
		op[11] = ip[12];
		op[12] = ip[11];
		op[13] = ip[10];
		op[14] = ip[9];
		op[15] = ip[8];
		op += 16;
		ip += 16;
		nn -= 2;
	}
	while (nn-- > 0)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op += 8;
		ip += 8;
	}
#  else
	while (nn-- > 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op += 8;
		ip += 8;
	}
#endif
#endif
}
# endif /* !vax */

#endif /* LITTLE_ENDIAN */

#line 616

#line 620

#line 630

#line 643


/*
 * Primitive numeric conversion functions.
 */

#line 671

#line 715

#line 742

#line 782

/* x_schar */
/* x_uchar */

/* We don't implement any x_schar and x_uchar primitives. */


/* external NC_SHORT --------------------------------------------------------*/

#if SHORT_MAX == X_SHORT_MAX
typedef short ix_short;
#define SIZEOF_IX_SHORT SIZEOF_SHORT
#define IX_SHORT_MAX SHORT_MAX
#elif INT_MAX >= X_SHORT_MAX
typedef int ix_short;
#define SIZEOF_IX_SHORT SIZEOF_INT
#define IX_SHORT_MAX INT_MAX
#elif LONG_MAX >= X_SHORT_MAX
typedef long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONG
#define IX_SHORT_MAX LONG_MAX
#elif LLONG_MAX >= X_SHORT_MAX
typedef long long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONGLONG
#define IX_SHORT_MAX LLONG_MAX
#else
#error "ix_short implementation"
#endif

static void
get_ix_short(const void *xp, ix_short *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = (ix_short)(*cp++ << 8);
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if (*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip = (ix_short)(*ip | *cp);
}

static void
put_ix_short(void *xp, const ix_short *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (uchar)((*ip) >> 8);
	*cp   = (uchar)((*ip) & 0xff);
}

static int
#line 834
ncx_get_short_schar(const void *xp, schar *ip)
#line 834
{
#line 834
    int err=NC_NOERR;
#line 834
    ix_short xx;
#line 834
    get_ix_short(xp, &xx);
#line 834

#line 834
#if IX_SHORT_MAX > SCHAR_MAX
#line 834
    if (xx > SCHAR_MAX || xx < SCHAR_MIN) {
#line 834

#line 834
        err = NC_ERANGE;
#line 834
    }
#line 834
#endif
#line 834

#line 834

#line 834
    *ip = (schar) xx;
#line 834
    return err;
#line 834
}
#line 834

static int
#line 835
ncx_get_short_short(const void *xp, short *ip)
#line 835
{
#line 835
    int err=NC_NOERR;
#line 835
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
#line 835
    get_ix_short(xp, (ix_short *)ip);
#line 835
#else
#line 835
    ix_short xx;
#line 835
    get_ix_short(xp, &xx);
#line 835

#line 835
#if IX_SHORT_MAX > SHORT_MAX
#line 835
    if (xx > SHORT_MAX || xx < SHORT_MIN) {
#line 835

#line 835
        err = NC_ERANGE;
#line 835
    }
#line 835
#endif
#line 835

#line 835

#line 835
    *ip = (short) xx;
#line 835
#endif
#line 835
    return err;
#line 835
}
#line 835

static int
#line 836
ncx_get_short_int(const void *xp, int *ip)
#line 836
{
#line 836
    int err=NC_NOERR;
#line 836
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
#line 836
    get_ix_short(xp, (ix_short *)ip);
#line 836
#else
#line 836
    ix_short xx;
#line 836
    get_ix_short(xp, &xx);
#line 836

#line 836
#if IX_SHORT_MAX > INT_MAX
#line 836
    if (xx > INT_MAX || xx < INT_MIN) {
#line 836

#line 836
        err = NC_ERANGE;
#line 836
    }
#line 836
#endif
#line 836

#line 836

#line 836
    *ip = (int) xx;
#line 836
#endif
#line 836
    return err;
#line 836
}
#line 836

static int
#line 837
ncx_get_short_long(const void *xp, long *ip)
#line 837
{
#line 837
    int err=NC_NOERR;
#line 837
#if SIZEOF_IX_SHORT == SIZEOF_LONG && IX_SHORT_MAX == LONG_MAX
#line 837
    get_ix_short(xp, (ix_short *)ip);
#line 837
#else
#line 837
    ix_short xx;
#line 837
    get_ix_short(xp, &xx);
#line 837

#line 837
#if IX_SHORT_MAX > LONG_MAX
#line 837
    if (xx > LONG_MAX || xx < LONG_MIN) {
#line 837

#line 837
        err = NC_ERANGE;
#line 837
    }
#line 837
#endif
#line 837

#line 837

#line 837
    *ip = (long) xx;
#line 837
#endif
#line 837
    return err;
#line 837
}
#line 837

static int
#line 838
ncx_get_short_longlong(const void *xp, longlong *ip)
#line 838
{
#line 838
    int err=NC_NOERR;
#line 838
#if SIZEOF_IX_SHORT == SIZEOF_LONGLONG && IX_SHORT_MAX == LONGLONG_MAX
#line 838
    get_ix_short(xp, (ix_short *)ip);
#line 838
#else
#line 838
    ix_short xx;
#line 838
    get_ix_short(xp, &xx);
#line 838

#line 838
#if IX_SHORT_MAX > LONGLONG_MAX
#line 838
    if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) {
#line 838

#line 838
        err = NC_ERANGE;
#line 838
    }
#line 838
#endif
#line 838

#line 838

#line 838
    *ip = (longlong) xx;
#line 838
#endif
#line 838
    return err;
#line 838
}
#line 838

static int
#line 839
ncx_get_short_ushort(const void *xp, ushort *ip)
#line 839
{
#line 839
    int err=NC_NOERR;
#line 839
    ix_short xx;
#line 839
    get_ix_short(xp, &xx);
#line 839

#line 839
#if IX_SHORT_MAX > USHORT_MAX
#line 839
    if (xx > USHORT_MAX) {
#line 839

#line 839
        err = NC_ERANGE;
#line 839
    }
#line 839
#endif
#line 839

#line 839
    if (xx < 0) {
#line 839

#line 839
        err = NC_ERANGE; /* because ip is unsigned */
#line 839
    }
#line 839
    *ip = (ushort) xx;
#line 839
    return err;
#line 839
}
#line 839

static int
#line 840
ncx_get_short_uchar(const void *xp, uchar *ip)
#line 840
{
#line 840
    int err=NC_NOERR;
#line 840
    ix_short xx;
#line 840
    get_ix_short(xp, &xx);
#line 840

#line 840
#if IX_SHORT_MAX > UCHAR_MAX
#line 840
    if (xx > UCHAR_MAX) {
#line 840

#line 840
        err = NC_ERANGE;
#line 840
    }
#line 840
#endif
#line 840

#line 840
    if (xx < 0) {
#line 840

#line 840
        err = NC_ERANGE; /* because ip is unsigned */
#line 840
    }
#line 840
    *ip = (uchar) xx;
#line 840
    return err;
#line 840
}
#line 840

static int
#line 841
ncx_get_short_uint(const void *xp, uint *ip)
#line 841
{
#line 841
    int err=NC_NOERR;
#line 841
    ix_short xx;
#line 841
    get_ix_short(xp, &xx);
#line 841

#line 841
#if IX_SHORT_MAX > UINT_MAX
#line 841
    if (xx > UINT_MAX) {
#line 841

#line 841
        err = NC_ERANGE;
#line 841
    }
#line 841
#endif
#line 841

#line 841
    if (xx < 0) {
#line 841

#line 841
        err = NC_ERANGE; /* because ip is unsigned */
#line 841
    }
#line 841
    *ip = (uint) xx;
#line 841
    return err;
#line 841
}
#line 841

static int
#line 842
ncx_get_short_ulonglong(const void *xp, ulonglong *ip)
#line 842
{
#line 842
    int err=NC_NOERR;
#line 842
    ix_short xx;
#line 842
    get_ix_short(xp, &xx);
#line 842

#line 842
#if IX_SHORT_MAX > ULONGLONG_MAX
#line 842
    if (xx > ULONGLONG_MAX) {
#line 842

#line 842
        err = NC_ERANGE;
#line 842
    }
#line 842
#endif
#line 842

#line 842
    if (xx < 0) {
#line 842

#line 842
        err = NC_ERANGE; /* because ip is unsigned */
#line 842
    }
#line 842
    *ip = (ulonglong) xx;
#line 842
    return err;
#line 842
}
#line 842

static int
#line 843
ncx_get_short_float(const void *xp, float *ip)
#line 843
{
#line 843
	ix_short xx;
#line 843
	get_ix_short(xp, &xx);
#line 843
	*ip = (float)xx;
#line 843
	return NC_NOERR;
#line 843
}
#line 843

static int
#line 844
ncx_get_short_double(const void *xp, double *ip)
#line 844
{
#line 844
	ix_short xx;
#line 844
	get_ix_short(xp, &xx);
#line 844
	*ip = (double)xx;
#line 844
	return NC_NOERR;
#line 844
}
#line 844


static int
ncx_put_short_schar(void *xp, const schar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	if (*ip & 0x80)
		*cp++ = 0xff;
	else
		*cp++ = 0;
	*cp = (uchar)*ip;
	return NC_NOERR;
}

static int
ncx_put_short_uchar(void *xp, const uchar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return NC_NOERR;
}

static int
#line 867
ncx_put_short_short(void *xp, const short *ip, void *fillp)
#line 867
{
#line 867
    int err=NC_NOERR;
#line 867
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
#line 867
    put_ix_short(xp, (const ix_short *)ip);
#line 867
#else
#line 867
    ix_short xx = NC_FILL_SHORT;
#line 867

#line 867
#if IX_SHORT_MAX < SHORT_MAX
#line 867
    if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) {
#line 867
        
#line 867
        err = NC_ERANGE;
#line 867
    } 
#line 867
#endif
#line 867
        xx = (ix_short)*ip;
#line 867

#line 867
    put_ix_short(xp, &xx);
#line 867
#endif
#line 867
    return err;
#line 867
}
#line 867

static int
#line 868
ncx_put_short_int(void *xp, const int *ip, void *fillp)
#line 868
{
#line 868
    int err=NC_NOERR;
#line 868
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
#line 868
    put_ix_short(xp, (const ix_short *)ip);
#line 868
#else
#line 868
    ix_short xx = NC_FILL_SHORT;
#line 868

#line 868
#if IX_SHORT_MAX < INT_MAX
#line 868
    if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) {
#line 868
        
#line 868
        err = NC_ERANGE;
#line 868
    } 
#line 868
#endif
#line 868
        xx = (ix_short)*ip;
#line 868

#line 868
    put_ix_short(xp, &xx);
#line 868
#endif
#line 868
    return err;
#line 868
}
#line 868

static int
#line 869
ncx_put_short_long(void *xp, const long *ip, void *fillp)
#line 869
{
#line 869
    int err=NC_NOERR;
#line 869
#if SIZEOF_IX_SHORT == SIZEOF_LONG && IX_SHORT_MAX == LONG_MAX
#line 869
    put_ix_short(xp, (const ix_short *)ip);
#line 869
#else
#line 869
    ix_short xx = NC_FILL_SHORT;
#line 869

#line 869
#if IX_SHORT_MAX < LONG_MAX
#line 869
    if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) {
#line 869
        
#line 869
        err = NC_ERANGE;
#line 869
    } 
#line 869
#endif
#line 869
        xx = (ix_short)*ip;
#line 869

#line 869
    put_ix_short(xp, &xx);
#line 869
#endif
#line 869
    return err;
#line 869
}
#line 869

static int
#line 870
ncx_put_short_longlong(void *xp, const longlong *ip, void *fillp)
#line 870
{
#line 870
    int err=NC_NOERR;
#line 870
#if SIZEOF_IX_SHORT == SIZEOF_LONGLONG && IX_SHORT_MAX == LONGLONG_MAX
#line 870
    put_ix_short(xp, (const ix_short *)ip);
#line 870
#else
#line 870
    ix_short xx = NC_FILL_SHORT;
#line 870

#line 870
#if IX_SHORT_MAX < LONGLONG_MAX
#line 870
    if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) {
#line 870
        
#line 870
        err = NC_ERANGE;
#line 870
    } 
#line 870
#endif
#line 870
        xx = (ix_short)*ip;
#line 870

#line 870
    put_ix_short(xp, &xx);
#line 870
#endif
#line 870
    return err;
#line 870
}
#line 870

static int
#line 871
ncx_put_short_ushort(void *xp, const ushort *ip, void *fillp)
#line 871
{
#line 871
    int err=NC_NOERR;
#line 871
    ix_short xx = NC_FILL_SHORT;
#line 871

#line 871
#if IX_SHORT_MAX < USHORT_MAX
#line 871
    if (*ip > IX_SHORT_MAX) {
#line 871
        
#line 871
        err = NC_ERANGE;
#line 871
    } 
#line 871
#endif
#line 871
        xx = (ix_short)*ip;
#line 871

#line 871
    put_ix_short(xp, &xx);
#line 871
    return err;
#line 871
}
#line 871

static int
#line 872
ncx_put_short_uint(void *xp, const uint *ip, void *fillp)
#line 872
{
#line 872
    int err=NC_NOERR;
#line 872
    ix_short xx = NC_FILL_SHORT;
#line 872

#line 872
#if IX_SHORT_MAX < UINT_MAX
#line 872
    if (*ip > IX_SHORT_MAX) {
#line 872
        
#line 872
        err = NC_ERANGE;
#line 872
    } 
#line 872
#endif
#line 872
        xx = (ix_short)*ip;
#line 872

#line 872
    put_ix_short(xp, &xx);
#line 872
    return err;
#line 872
}
#line 872

static int
#line 873
ncx_put_short_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 873
{
#line 873
    int err=NC_NOERR;
#line 873
    ix_short xx = NC_FILL_SHORT;
#line 873

#line 873
#if IX_SHORT_MAX < ULONGLONG_MAX
#line 873
    if (*ip > IX_SHORT_MAX) {
#line 873
        
#line 873
        err = NC_ERANGE;
#line 873
    } 
#line 873
#endif
#line 873
        xx = (ix_short)*ip;
#line 873

#line 873
    put_ix_short(xp, &xx);
#line 873
    return err;
#line 873
}
#line 873

static int
#line 874
ncx_put_short_float(void *xp, const float *ip, void *fillp)
#line 874
{
#line 874
    int err=NC_NOERR;
#line 874
    ix_short xx = NC_FILL_SHORT;
#line 874

#line 874
    if (*ip > (double)X_SHORT_MAX || *ip < (double)X_SHORT_MIN) {
#line 874
        
#line 874
        err = NC_ERANGE;
#line 874
    } 
#line 874
        xx = (ix_short)*ip;
#line 874

#line 874
    put_ix_short(xp, &xx);
#line 874
    return err;
#line 874
}
#line 874

static int
#line 875
ncx_put_short_double(void *xp, const double *ip, void *fillp)
#line 875
{
#line 875
    int err=NC_NOERR;
#line 875
    ix_short xx = NC_FILL_SHORT;
#line 875

#line 875
    if (*ip > X_SHORT_MAX || *ip < X_SHORT_MIN) {
#line 875
        
#line 875
        err = NC_ERANGE;
#line 875
    } 
#line 875
        xx = (ix_short)*ip;
#line 875

#line 875
    put_ix_short(xp, &xx);
#line 875
    return err;
#line 875
}
#line 875


/* external NC_USHORT -------------------------------------------------------*/

#if USHORT_MAX == X_USHORT_MAX
typedef unsigned short ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_USHORT
#define IX_USHORT_MAX USHORT_MAX
#elif UINT_MAX >= X_USHORT_MAX
typedef unsigned int ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_UINT
#define IX_USHORT_MAX UINT_MAX
#elif ULONG_MAX >= X_USHORT_MAX
typedef unsigned long ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_ULONG
#define IX_USHORT_MAX ULONG_MAX
#elif ULLONG_MAX >= X_USHORT_MAX
typedef unsigned long long ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_ULONGLONG
#define IX_USHORT_MAX ULLONG_MAX
#else
#error "ix_ushort implementation"
#endif

static void
get_ix_ushort(const void *xp, ix_ushort *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = (ix_ushort)(*cp++ << 8);
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if (*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip = (ix_ushort)(*ip | *cp);
}

static void
put_ix_ushort(void *xp, const ix_ushort *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (uchar)((*ip) >> 8);
	*cp   = (uchar)((*ip) & 0xff);
}

static int
#line 922
ncx_get_ushort_schar(const void *xp, schar *ip)
#line 922
{
#line 922
    int err=NC_NOERR;
#line 922
    ix_ushort xx;
#line 922
    get_ix_ushort(xp, &xx);
#line 922

#line 922
#if IX_USHORT_MAX > SCHAR_MAX
#line 922
    if (xx > SCHAR_MAX) {
#line 922

#line 922
        err = NC_ERANGE;
#line 922
    }
#line 922
#endif
#line 922

#line 922

#line 922
    *ip = (schar) xx;
#line 922
    return err;
#line 922
}
#line 922

static int
#line 923
ncx_get_ushort_short(const void *xp, short *ip)
#line 923
{
#line 923
    int err=NC_NOERR;
#line 923
    ix_ushort xx;
#line 923
    get_ix_ushort(xp, &xx);
#line 923

#line 923
#if IX_USHORT_MAX > SHORT_MAX
#line 923
    if (xx > SHORT_MAX) {
#line 923

#line 923
        err = NC_ERANGE;
#line 923
    }
#line 923
#endif
#line 923

#line 923

#line 923
    *ip = (short) xx;
#line 923
    return err;
#line 923
}
#line 923

static int
#line 924
ncx_get_ushort_int(const void *xp, int *ip)
#line 924
{
#line 924
    int err=NC_NOERR;
#line 924
    ix_ushort xx;
#line 924
    get_ix_ushort(xp, &xx);
#line 924

#line 924
#if IX_USHORT_MAX > INT_MAX
#line 924
    if (xx > INT_MAX) {
#line 924

#line 924
        err = NC_ERANGE;
#line 924
    }
#line 924
#endif
#line 924

#line 924

#line 924
    *ip = (int) xx;
#line 924
    return err;
#line 924
}
#line 924

static int
#line 925
ncx_get_ushort_long(const void *xp, long *ip)
#line 925
{
#line 925
    int err=NC_NOERR;
#line 925
    ix_ushort xx;
#line 925
    get_ix_ushort(xp, &xx);
#line 925

#line 925
#if IX_USHORT_MAX > LONG_MAX
#line 925
    if (xx > LONG_MAX) {
#line 925

#line 925
        err = NC_ERANGE;
#line 925
    }
#line 925
#endif
#line 925

#line 925

#line 925
    *ip = (long) xx;
#line 925
    return err;
#line 925
}
#line 925

static int
#line 926
ncx_get_ushort_longlong(const void *xp, longlong *ip)
#line 926
{
#line 926
    int err=NC_NOERR;
#line 926
    ix_ushort xx;
#line 926
    get_ix_ushort(xp, &xx);
#line 926

#line 926
#if IX_USHORT_MAX > LONGLONG_MAX
#line 926
    if (xx > LONGLONG_MAX) {
#line 926

#line 926
        err = NC_ERANGE;
#line 926
    }
#line 926
#endif
#line 926

#line 926

#line 926
    *ip = (longlong) xx;
#line 926
    return err;
#line 926
}
#line 926

static int
#line 927
ncx_get_ushort_ushort(const void *xp, ushort *ip)
#line 927
{
#line 927
    int err=NC_NOERR;
#line 927
#if SIZEOF_IX_USHORT == SIZEOF_USHORT && IX_USHORT_MAX == USHORT_MAX
#line 927
    get_ix_ushort(xp, (ix_ushort *)ip);
#line 927
#else
#line 927
    ix_ushort xx;
#line 927
    get_ix_ushort(xp, &xx);
#line 927

#line 927
#if IX_USHORT_MAX > USHORT_MAX
#line 927
    if (xx > USHORT_MAX) {
#line 927

#line 927
        err = NC_ERANGE;
#line 927
    }
#line 927
#endif
#line 927

#line 927

#line 927
    *ip = (ushort) xx;
#line 927
#endif
#line 927
    return err;
#line 927
}
#line 927

static int
#line 928
ncx_get_ushort_uchar(const void *xp, uchar *ip)
#line 928
{
#line 928
    int err=NC_NOERR;
#line 928
#if SIZEOF_IX_USHORT == SIZEOF_UCHAR && IX_USHORT_MAX == UCHAR_MAX
#line 928
    get_ix_ushort(xp, (ix_ushort *)ip);
#line 928
#else
#line 928
    ix_ushort xx;
#line 928
    get_ix_ushort(xp, &xx);
#line 928

#line 928
#if IX_USHORT_MAX > UCHAR_MAX
#line 928
    if (xx > UCHAR_MAX) {
#line 928

#line 928
        err = NC_ERANGE;
#line 928
    }
#line 928
#endif
#line 928

#line 928

#line 928
    *ip = (uchar) xx;
#line 928
#endif
#line 928
    return err;
#line 928
}
#line 928

static int
#line 929
ncx_get_ushort_uint(const void *xp, uint *ip)
#line 929
{
#line 929
    int err=NC_NOERR;
#line 929
#if SIZEOF_IX_USHORT == SIZEOF_UINT && IX_USHORT_MAX == UINT_MAX
#line 929
    get_ix_ushort(xp, (ix_ushort *)ip);
#line 929
#else
#line 929
    ix_ushort xx;
#line 929
    get_ix_ushort(xp, &xx);
#line 929

#line 929
#if IX_USHORT_MAX > UINT_MAX
#line 929
    if (xx > UINT_MAX) {
#line 929

#line 929
        err = NC_ERANGE;
#line 929
    }
#line 929
#endif
#line 929

#line 929

#line 929
    *ip = (uint) xx;
#line 929
#endif
#line 929
    return err;
#line 929
}
#line 929

static int
#line 930
ncx_get_ushort_ulonglong(const void *xp, ulonglong *ip)
#line 930
{
#line 930
    int err=NC_NOERR;
#line 930
#if SIZEOF_IX_USHORT == SIZEOF_ULONGLONG && IX_USHORT_MAX == ULONGLONG_MAX
#line 930
    get_ix_ushort(xp, (ix_ushort *)ip);
#line 930
#else
#line 930
    ix_ushort xx;
#line 930
    get_ix_ushort(xp, &xx);
#line 930

#line 930
#if IX_USHORT_MAX > ULONGLONG_MAX
#line 930
    if (xx > ULONGLONG_MAX) {
#line 930

#line 930
        err = NC_ERANGE;
#line 930
    }
#line 930
#endif
#line 930

#line 930

#line 930
    *ip = (ulonglong) xx;
#line 930
#endif
#line 930
    return err;
#line 930
}
#line 930

static int
#line 931
ncx_get_ushort_float(const void *xp, float *ip)
#line 931
{
#line 931
	ix_ushort xx;
#line 931
	get_ix_ushort(xp, &xx);
#line 931
	*ip = (float)xx;
#line 931
	return NC_NOERR;
#line 931
}
#line 931

static int
#line 932
ncx_get_ushort_double(const void *xp, double *ip)
#line 932
{
#line 932
	ix_ushort xx;
#line 932
	get_ix_ushort(xp, &xx);
#line 932
	*ip = (double)xx;
#line 932
	return NC_NOERR;
#line 932
}
#line 932


static int
ncx_put_ushort_schar(void *xp, const schar *ip, void *fillp)
{
    int err=NC_NOERR;
    uchar *cp;
    if (*ip < 0) {
#line 946
        err = NC_ERANGE;
    }

    cp = (uchar *) xp;
    if (*ip & 0x80)
        *cp++ = 0xff;
    else
        *cp++ = 0;
    *cp = (uchar)*ip;

    return err;
}

static int
ncx_put_ushort_uchar(void *xp, const uchar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return NC_NOERR;
}

static int
#line 968
ncx_put_ushort_short(void *xp, const short *ip, void *fillp)
#line 968
{
#line 968
    int err=NC_NOERR;
#line 968
    ix_ushort xx = NC_FILL_USHORT;
#line 968

#line 968
#if IX_USHORT_MAX < SHORT_MAX
#line 968
    if (*ip > IX_USHORT_MAX) {
#line 968
        
#line 968
        err = NC_ERANGE;
#line 968
    } 
#line 968
#endif
#line 968
    if (*ip < 0) {
#line 968
        
#line 968
        err = NC_ERANGE; /* because xp is unsigned */
#line 968
    } 
#line 968
        xx = (ix_ushort)*ip;
#line 968

#line 968
    put_ix_ushort(xp, &xx);
#line 968
    return err;
#line 968
}
#line 968

static int
#line 969
ncx_put_ushort_int(void *xp, const int *ip, void *fillp)
#line 969
{
#line 969
    int err=NC_NOERR;
#line 969
    ix_ushort xx = NC_FILL_USHORT;
#line 969

#line 969
#if IX_USHORT_MAX < INT_MAX
#line 969
    if (*ip > IX_USHORT_MAX) {
#line 969
        
#line 969
        err = NC_ERANGE;
#line 969
    } 
#line 969
#endif
#line 969
    if (*ip < 0) {
#line 969
        
#line 969
        err = NC_ERANGE; /* because xp is unsigned */
#line 969
    } 
#line 969
        xx = (ix_ushort)*ip;
#line 969

#line 969
    put_ix_ushort(xp, &xx);
#line 969
    return err;
#line 969
}
#line 969

static int
#line 970
ncx_put_ushort_long(void *xp, const long *ip, void *fillp)
#line 970
{
#line 970
    int err=NC_NOERR;
#line 970
    ix_ushort xx = NC_FILL_USHORT;
#line 970

#line 970
#if IX_USHORT_MAX < LONG_MAX
#line 970
    if (*ip > IX_USHORT_MAX) {
#line 970
        
#line 970
        err = NC_ERANGE;
#line 970
    } 
#line 970
#endif
#line 970
    if (*ip < 0) {
#line 970
        
#line 970
        err = NC_ERANGE; /* because xp is unsigned */
#line 970
    } 
#line 970
        xx = (ix_ushort)*ip;
#line 970

#line 970
    put_ix_ushort(xp, &xx);
#line 970
    return err;
#line 970
}
#line 970

static int
#line 971
ncx_put_ushort_longlong(void *xp, const longlong *ip, void *fillp)
#line 971
{
#line 971
    int err=NC_NOERR;
#line 971
    ix_ushort xx = NC_FILL_USHORT;
#line 971

#line 971
#if IX_USHORT_MAX < LONGLONG_MAX
#line 971
    if (*ip > IX_USHORT_MAX) {
#line 971
        
#line 971
        err = NC_ERANGE;
#line 971
    } 
#line 971
#endif
#line 971
    if (*ip < 0) {
#line 971
        
#line 971
        err = NC_ERANGE; /* because xp is unsigned */
#line 971
    } 
#line 971
        xx = (ix_ushort)*ip;
#line 971

#line 971
    put_ix_ushort(xp, &xx);
#line 971
    return err;
#line 971
}
#line 971

static int
#line 972
ncx_put_ushort_ushort(void *xp, const ushort *ip, void *fillp)
#line 972
{
#line 972
    int err=NC_NOERR;
#line 972
#if SIZEOF_IX_USHORT == SIZEOF_USHORT && IX_USHORT_MAX == USHORT_MAX
#line 972
    put_ix_ushort(xp, (const ix_ushort *)ip);
#line 972
#else
#line 972
    ix_ushort xx = NC_FILL_USHORT;
#line 972

#line 972
#if IX_USHORT_MAX < USHORT_MAX
#line 972
    if (*ip > IX_USHORT_MAX) {
#line 972
        
#line 972
        err = NC_ERANGE;
#line 972
    } 
#line 972
#endif
#line 972
        xx = (ix_ushort)*ip;
#line 972

#line 972
    put_ix_ushort(xp, &xx);
#line 972
#endif
#line 972
    return err;
#line 972
}
#line 972

static int
#line 973
ncx_put_ushort_uint(void *xp, const uint *ip, void *fillp)
#line 973
{
#line 973
    int err=NC_NOERR;
#line 973
#if SIZEOF_IX_USHORT == SIZEOF_UINT && IX_USHORT_MAX == UINT_MAX
#line 973
    put_ix_ushort(xp, (const ix_ushort *)ip);
#line 973
#else
#line 973
    ix_ushort xx = NC_FILL_USHORT;
#line 973

#line 973
#if IX_USHORT_MAX < UINT_MAX
#line 973
    if (*ip > IX_USHORT_MAX) {
#line 973
        
#line 973
        err = NC_ERANGE;
#line 973
    } 
#line 973
#endif
#line 973
        xx = (ix_ushort)*ip;
#line 973

#line 973
    put_ix_ushort(xp, &xx);
#line 973
#endif
#line 973
    return err;
#line 973
}
#line 973

static int
#line 974
ncx_put_ushort_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 974
{
#line 974
    int err=NC_NOERR;
#line 974
#if SIZEOF_IX_USHORT == SIZEOF_ULONGLONG && IX_USHORT_MAX == ULONGLONG_MAX
#line 974
    put_ix_ushort(xp, (const ix_ushort *)ip);
#line 974
#else
#line 974
    ix_ushort xx = NC_FILL_USHORT;
#line 974

#line 974
#if IX_USHORT_MAX < ULONGLONG_MAX
#line 974
    if (*ip > IX_USHORT_MAX) {
#line 974
        
#line 974
        err = NC_ERANGE;
#line 974
    } 
#line 974
#endif
#line 974
        xx = (ix_ushort)*ip;
#line 974

#line 974
    put_ix_ushort(xp, &xx);
#line 974
#endif
#line 974
    return err;
#line 974
}
#line 974

static int
#line 975
ncx_put_ushort_float(void *xp, const float *ip, void *fillp)
#line 975
{
#line 975
    int err=NC_NOERR;
#line 975
    ix_ushort xx = NC_FILL_USHORT;
#line 975

#line 975
    if (*ip > (double)X_USHORT_MAX || *ip < 0) {
#line 975
        
#line 975
        err = NC_ERANGE;
#line 975
    } 
#line 975
        xx = (ix_ushort)*ip;
#line 975

#line 975
    put_ix_ushort(xp, &xx);
#line 975
    return err;
#line 975
}
#line 975

static int
#line 976
ncx_put_ushort_double(void *xp, const double *ip, void *fillp)
#line 976
{
#line 976
    int err=NC_NOERR;
#line 976
    ix_ushort xx = NC_FILL_USHORT;
#line 976

#line 976
    if (*ip > X_USHORT_MAX || *ip < 0) {
#line 976
        
#line 976
        err = NC_ERANGE;
#line 976
    } 
#line 976
        xx = (ix_ushort)*ip;
#line 976

#line 976
    put_ix_ushort(xp, &xx);
#line 976
    return err;
#line 976
}
#line 976


/* external NC_INT ----------------------------------------------------------*/

#if SHORT_MAX == X_INT_MAX
typedef short ix_int;
#define SIZEOF_IX_INT SIZEOF_SHORT
#define IX_INT_MAX SHORT_MAX
#elif INT_MAX  >= X_INT_MAX
typedef int ix_int;
#define SIZEOF_IX_INT SIZEOF_INT
#define IX_INT_MAX INT_MAX
#elif LONG_MAX  >= X_INT_MAX
typedef long ix_int;
#define SIZEOF_IX_INT SIZEOF_LONG
#define IX_INT_MAX LONG_MAX
#else
#error "ix_int implementation"
#endif


static void
get_ix_int(const void *xp, ix_int *ip)
{
	const uchar *cp = (const uchar *) xp;

	*ip = *cp++ << 24;
#if SIZEOF_IX_INT > X_SIZEOF_INT
	if (*ip & 0x80000000)
	{
		/* extern is negative */
		*ip |= (~(0xffffffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= (*cp++ << 16);
	*ip |= (*cp++ << 8);
	*ip |= *cp;
}

static void
put_ix_int(void *xp, const ix_int *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (uchar)( (*ip) >> 24);
	*cp++ = (uchar)(((*ip) & 0x00ff0000) >> 16);
	*cp++ = (uchar)(((*ip) & 0x0000ff00) >>  8);
	*cp   = (uchar)( (*ip) & 0x000000ff);
}

#if X_SIZEOF_INT != SIZEOF_INT
static int
#line 1027
ncx_get_int_int(const void *xp, int *ip)
#line 1027
{
#line 1027
    int err=NC_NOERR;
#line 1027
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
#line 1027
    get_ix_int(xp, (ix_int *)ip);
#line 1027
#else
#line 1027
    ix_int xx;
#line 1027
    get_ix_int(xp, &xx);
#line 1027

#line 1027
#if IX_INT_MAX > INT_MAX
#line 1027
    if (xx > INT_MAX || xx < INT_MIN) {
#line 1027

#line 1027
        err = NC_ERANGE;
#line 1027
    }
#line 1027
#endif
#line 1027

#line 1027

#line 1027
    *ip = (int) xx;
#line 1027
#endif
#line 1027
    return err;
#line 1027
}
#line 1027

#endif
static int
#line 1029
ncx_get_int_schar(const void *xp, schar *ip)
#line 1029
{
#line 1029
    int err=NC_NOERR;
#line 1029
    ix_int xx;
#line 1029
    get_ix_int(xp, &xx);
#line 1029

#line 1029
#if IX_INT_MAX > SCHAR_MAX
#line 1029
    if (xx > SCHAR_MAX || xx < SCHAR_MIN) {
#line 1029

#line 1029
        err = NC_ERANGE;
#line 1029
    }
#line 1029
#endif
#line 1029

#line 1029

#line 1029
    *ip = (schar) xx;
#line 1029
    return err;
#line 1029
}
#line 1029

static int
#line 1030
ncx_get_int_short(const void *xp, short *ip)
#line 1030
{
#line 1030
    int err=NC_NOERR;
#line 1030
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
#line 1030
    get_ix_int(xp, (ix_int *)ip);
#line 1030
#else
#line 1030
    ix_int xx;
#line 1030
    get_ix_int(xp, &xx);
#line 1030

#line 1030
#if IX_INT_MAX > SHORT_MAX
#line 1030
    if (xx > SHORT_MAX || xx < SHORT_MIN) {
#line 1030

#line 1030
        err = NC_ERANGE;
#line 1030
    }
#line 1030
#endif
#line 1030

#line 1030

#line 1030
    *ip = (short) xx;
#line 1030
#endif
#line 1030
    return err;
#line 1030
}
#line 1030

static int
#line 1031
ncx_get_int_long(const void *xp, long *ip)
#line 1031
{
#line 1031
    int err=NC_NOERR;
#line 1031
#if SIZEOF_IX_INT == SIZEOF_LONG && IX_INT_MAX == LONG_MAX
#line 1031
    get_ix_int(xp, (ix_int *)ip);
#line 1031
#else
#line 1031
    ix_int xx;
#line 1031
    get_ix_int(xp, &xx);
#line 1031

#line 1031
#if IX_INT_MAX > LONG_MAX
#line 1031
    if (xx > LONG_MAX || xx < LONG_MIN) {
#line 1031

#line 1031
        err = NC_ERANGE;
#line 1031
    }
#line 1031
#endif
#line 1031

#line 1031

#line 1031
    *ip = (long) xx;
#line 1031
#endif
#line 1031
    return err;
#line 1031
}
#line 1031

static int
#line 1032
ncx_get_int_longlong(const void *xp, longlong *ip)
#line 1032
{
#line 1032
    int err=NC_NOERR;
#line 1032
#if SIZEOF_IX_INT == SIZEOF_LONGLONG && IX_INT_MAX == LONGLONG_MAX
#line 1032
    get_ix_int(xp, (ix_int *)ip);
#line 1032
#else
#line 1032
    ix_int xx;
#line 1032
    get_ix_int(xp, &xx);
#line 1032

#line 1032
#if IX_INT_MAX > LONGLONG_MAX
#line 1032
    if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) {
#line 1032

#line 1032
        err = NC_ERANGE;
#line 1032
    }
#line 1032
#endif
#line 1032

#line 1032

#line 1032
    *ip = (longlong) xx;
#line 1032
#endif
#line 1032
    return err;
#line 1032
}
#line 1032

static int
#line 1033
ncx_get_int_ushort(const void *xp, ushort *ip)
#line 1033
{
#line 1033
    int err=NC_NOERR;
#line 1033
    ix_int xx;
#line 1033
    get_ix_int(xp, &xx);
#line 1033

#line 1033
#if IX_INT_MAX > USHORT_MAX
#line 1033
    if (xx > USHORT_MAX) {
#line 1033

#line 1033
        err = NC_ERANGE;
#line 1033
    }
#line 1033
#endif
#line 1033

#line 1033
    if (xx < 0) {
#line 1033

#line 1033
        err = NC_ERANGE; /* because ip is unsigned */
#line 1033
    }
#line 1033
    *ip = (ushort) xx;
#line 1033
    return err;
#line 1033
}
#line 1033

static int
#line 1034
ncx_get_int_uchar(const void *xp, uchar *ip)
#line 1034
{
#line 1034
    int err=NC_NOERR;
#line 1034
    ix_int xx;
#line 1034
    get_ix_int(xp, &xx);
#line 1034

#line 1034
#if IX_INT_MAX > UCHAR_MAX
#line 1034
    if (xx > UCHAR_MAX) {
#line 1034

#line 1034
        err = NC_ERANGE;
#line 1034
    }
#line 1034
#endif
#line 1034

#line 1034
    if (xx < 0) {
#line 1034

#line 1034
        err = NC_ERANGE; /* because ip is unsigned */
#line 1034
    }
#line 1034
    *ip = (uchar) xx;
#line 1034
    return err;
#line 1034
}
#line 1034

static int
#line 1035
ncx_get_int_uint(const void *xp, uint *ip)
#line 1035
{
#line 1035
    int err=NC_NOERR;
#line 1035
    ix_int xx;
#line 1035
    get_ix_int(xp, &xx);
#line 1035

#line 1035
#if IX_INT_MAX > UINT_MAX
#line 1035
    if (xx > UINT_MAX) {
#line 1035

#line 1035
        err = NC_ERANGE;
#line 1035
    }
#line 1035
#endif
#line 1035

#line 1035
    if (xx < 0) {
#line 1035

#line 1035
        err = NC_ERANGE; /* because ip is unsigned */
#line 1035
    }
#line 1035
    *ip = (uint) xx;
#line 1035
    return err;
#line 1035
}
#line 1035

static int
#line 1036
ncx_get_int_ulonglong(const void *xp, ulonglong *ip)
#line 1036
{
#line 1036
    int err=NC_NOERR;
#line 1036
    ix_int xx;
#line 1036
    get_ix_int(xp, &xx);
#line 1036

#line 1036
#if IX_INT_MAX > ULONGLONG_MAX
#line 1036
    if (xx > ULONGLONG_MAX) {
#line 1036

#line 1036
        err = NC_ERANGE;
#line 1036
    }
#line 1036
#endif
#line 1036

#line 1036
    if (xx < 0) {
#line 1036

#line 1036
        err = NC_ERANGE; /* because ip is unsigned */
#line 1036
    }
#line 1036
    *ip = (ulonglong) xx;
#line 1036
    return err;
#line 1036
}
#line 1036

static int
#line 1037
ncx_get_int_float(const void *xp, float *ip)
#line 1037
{
#line 1037
	ix_int xx;
#line 1037
	get_ix_int(xp, &xx);
#line 1037
	*ip = (float)xx;
#line 1037
	return NC_NOERR;
#line 1037
}
#line 1037

static int
#line 1038
ncx_get_int_double(const void *xp, double *ip)
#line 1038
{
#line 1038
	ix_int xx;
#line 1038
	get_ix_int(xp, &xx);
#line 1038
	*ip = (double)xx;
#line 1038
	return NC_NOERR;
#line 1038
}
#line 1038


static int
ncx_put_int_schar(void *xp, const schar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	if (*ip & 0x80)
	{
		*cp++ = 0xff;
		*cp++ = 0xff;
		*cp++ = 0xff;
	}
	else
	{
		*cp++ = 0x00;
		*cp++ = 0x00;
		*cp++ = 0x00;
	}
	*cp = (uchar)*ip;
	return NC_NOERR;
}

static int
ncx_put_int_uchar(void *xp, const uchar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return NC_NOERR;
}

#if X_SIZEOF_INT != SIZEOF_INT
static int
#line 1072
ncx_put_int_int(void *xp, const int *ip, void *fillp)
#line 1072
{
#line 1072
    int err=NC_NOERR;
#line 1072
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
#line 1072
    put_ix_int(xp, (const ix_int *)ip);
#line 1072
#else
#line 1072
    ix_int xx = NC_FILL_INT;
#line 1072

#line 1072
#if IX_INT_MAX < INT_MAX
#line 1072
    if (*ip > IX_INT_MAX || *ip < X_INT_MIN) {
#line 1072
        
#line 1072
        err = NC_ERANGE;
#line 1072
    } 
#line 1072
#endif
#line 1072
        xx = (ix_int)*ip;
#line 1072

#line 1072
    put_ix_int(xp, &xx);
#line 1072
#endif
#line 1072
    return err;
#line 1072
}
#line 1072

#endif
static int
#line 1074
ncx_put_int_short(void *xp, const short *ip, void *fillp)
#line 1074
{
#line 1074
    int err=NC_NOERR;
#line 1074
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
#line 1074
    put_ix_int(xp, (const ix_int *)ip);
#line 1074
#else
#line 1074
    ix_int xx = NC_FILL_INT;
#line 1074

#line 1074
#if IX_INT_MAX < SHORT_MAX
#line 1074
    if (*ip > IX_INT_MAX || *ip < X_INT_MIN) {
#line 1074
        
#line 1074
        err = NC_ERANGE;
#line 1074
    } 
#line 1074
#endif
#line 1074
        xx = (ix_int)*ip;
#line 1074

#line 1074
    put_ix_int(xp, &xx);
#line 1074
#endif
#line 1074
    return err;
#line 1074
}
#line 1074

static int
#line 1075
ncx_put_int_long(void *xp, const long *ip, void *fillp)
#line 1075
{
#line 1075
    int err=NC_NOERR;
#line 1075
#if SIZEOF_IX_INT == SIZEOF_LONG && IX_INT_MAX == LONG_MAX
#line 1075
    put_ix_int(xp, (const ix_int *)ip);
#line 1075
#else
#line 1075
    ix_int xx = NC_FILL_INT;
#line 1075

#line 1075
#if IX_INT_MAX < LONG_MAX
#line 1075
    if (*ip > IX_INT_MAX || *ip < X_INT_MIN) {
#line 1075
        
#line 1075
        err = NC_ERANGE;
#line 1075
    } 
#line 1075
#endif
#line 1075
        xx = (ix_int)*ip;
#line 1075

#line 1075
    put_ix_int(xp, &xx);
#line 1075
#endif
#line 1075
    return err;
#line 1075
}
#line 1075

static int
#line 1076
ncx_put_int_longlong(void *xp, const longlong *ip, void *fillp)
#line 1076
{
#line 1076
    int err=NC_NOERR;
#line 1076
#if SIZEOF_IX_INT == SIZEOF_LONGLONG && IX_INT_MAX == LONGLONG_MAX
#line 1076
    put_ix_int(xp, (const ix_int *)ip);
#line 1076
#else
#line 1076
    ix_int xx = NC_FILL_INT;
#line 1076

#line 1076
#if IX_INT_MAX < LONGLONG_MAX
#line 1076
    if (*ip > IX_INT_MAX || *ip < X_INT_MIN) {
#line 1076
        
#line 1076
        err = NC_ERANGE;
#line 1076
    } 
#line 1076
#endif
#line 1076
        xx = (ix_int)*ip;
#line 1076

#line 1076
    put_ix_int(xp, &xx);
#line 1076
#endif
#line 1076
    return err;
#line 1076
}
#line 1076

static int
#line 1077
ncx_put_int_ushort(void *xp, const ushort *ip, void *fillp)
#line 1077
{
#line 1077
    int err=NC_NOERR;
#line 1077
    ix_int xx = NC_FILL_INT;
#line 1077

#line 1077
#if IX_INT_MAX < USHORT_MAX
#line 1077
    if (*ip > IX_INT_MAX) {
#line 1077
        
#line 1077
        err = NC_ERANGE;
#line 1077
    } 
#line 1077
#endif
#line 1077
        xx = (ix_int)*ip;
#line 1077

#line 1077
    put_ix_int(xp, &xx);
#line 1077
    return err;
#line 1077
}
#line 1077

static int
#line 1078
ncx_put_int_uint(void *xp, const uint *ip, void *fillp)
#line 1078
{
#line 1078
    int err=NC_NOERR;
#line 1078
    ix_int xx = NC_FILL_INT;
#line 1078

#line 1078
#if IX_INT_MAX < UINT_MAX
#line 1078
    if (*ip > IX_INT_MAX) {
#line 1078
        
#line 1078
        err = NC_ERANGE;
#line 1078
    } 
#line 1078
#endif
#line 1078
        xx = (ix_int)*ip;
#line 1078

#line 1078
    put_ix_int(xp, &xx);
#line 1078
    return err;
#line 1078
}
#line 1078

static int
#line 1079
ncx_put_int_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 1079
{
#line 1079
    int err=NC_NOERR;
#line 1079
    ix_int xx = NC_FILL_INT;
#line 1079

#line 1079
#if IX_INT_MAX < ULONGLONG_MAX
#line 1079
    if (*ip > IX_INT_MAX) {
#line 1079
        
#line 1079
        err = NC_ERANGE;
#line 1079
    } 
#line 1079
#endif
#line 1079
        xx = (ix_int)*ip;
#line 1079

#line 1079
    put_ix_int(xp, &xx);
#line 1079
    return err;
#line 1079
}
#line 1079

static int
#line 1080
ncx_put_int_float(void *xp, const float *ip, void *fillp)
#line 1080
{
#line 1080
    int err=NC_NOERR;
#line 1080
    ix_int xx = NC_FILL_INT;
#line 1080

#line 1080
    if (*ip > (double)X_INT_MAX || *ip < (double)X_INT_MIN) {
#line 1080
        
#line 1080
        err = NC_ERANGE;
#line 1080
    } 
#line 1080
        xx = (ix_int)*ip;
#line 1080

#line 1080
    put_ix_int(xp, &xx);
#line 1080
    return err;
#line 1080
}
#line 1080

static int
#line 1081
ncx_put_int_double(void *xp, const double *ip, void *fillp)
#line 1081
{
#line 1081
    int err=NC_NOERR;
#line 1081
    ix_int xx = NC_FILL_INT;
#line 1081

#line 1081
    if (*ip > X_INT_MAX || *ip < X_INT_MIN) {
#line 1081
        
#line 1081
        err = NC_ERANGE;
#line 1081
    } 
#line 1081
        xx = (ix_int)*ip;
#line 1081

#line 1081
    put_ix_int(xp, &xx);
#line 1081
    return err;
#line 1081
}
#line 1081



/* external NC_UINT ---------------------------------------------------------*/

#if USHORT_MAX == X_UINT_MAX
typedef ushort ix_uint;
#define SIZEOF_IX_UINT SIZEOF_USHORT
#define IX_UINT_MAX USHORT_MAX
#elif UINT_MAX  >= X_UINT_MAX
typedef uint ix_uint;
#define SIZEOF_IX_UINT SIZEOF_UINT
#define IX_UINT_MAX UINT_MAX
#elif ULONG_MAX  >= X_UINT_MAX
typedef ulong ix_uint;
#define SIZEOF_IX_UINT SIZEOF_ULONG
#define IX_UINT_MAX ULONG_MAX
#else
#error "ix_uint implementation"
#endif


static void
get_ix_uint(const void *xp, ix_uint *ip)
{
	const uchar *cp = (const uchar *) xp;

	*ip = (ix_uint)(*cp++ << 24);
	*ip = (ix_uint)(*ip | (ix_uint)(*cp++ << 16));
	*ip = (ix_uint)(*ip | (ix_uint)(*cp++ << 8));
	*ip = (ix_uint)(*ip | *cp);
}

static void
put_ix_uint(void *xp, const ix_uint *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (uchar)((*ip) >> 24);
	*cp++ = (uchar)(((*ip) & 0x00ff0000) >> 16);
	*cp++ = (uchar)(((*ip) & 0x0000ff00) >>  8);
	*cp   = (uchar)( (*ip) & 0x000000ff);
}

#if X_SIZEOF_UINT != SIZEOF_UINT
static int
#line 1126
ncx_get_uint_uint(const void *xp, uint *ip)
#line 1126
{
#line 1126
    int err=NC_NOERR;
#line 1126
#if SIZEOF_IX_UINT == SIZEOF_UINT && IX_UINT_MAX == UINT_MAX
#line 1126
    get_ix_uint(xp, (ix_uint *)ip);
#line 1126
#else
#line 1126
    ix_uint xx;
#line 1126
    get_ix_uint(xp, &xx);
#line 1126

#line 1126
#if IX_UINT_MAX > UINT_MAX
#line 1126
    if (xx > UINT_MAX) {
#line 1126

#line 1126
        err = NC_ERANGE;
#line 1126
    }
#line 1126
#endif
#line 1126

#line 1126

#line 1126
    *ip = (uint) xx;
#line 1126
#endif
#line 1126
    return err;
#line 1126
}
#line 1126

#endif

static int
#line 1129
ncx_get_uint_schar(const void *xp, schar *ip)
#line 1129
{
#line 1129
    int err=NC_NOERR;
#line 1129
    ix_uint xx;
#line 1129
    get_ix_uint(xp, &xx);
#line 1129

#line 1129
#if IX_UINT_MAX > SCHAR_MAX
#line 1129
    if (xx > SCHAR_MAX) {
#line 1129

#line 1129
        err = NC_ERANGE;
#line 1129
    }
#line 1129
#endif
#line 1129

#line 1129

#line 1129
    *ip = (schar) xx;
#line 1129
    return err;
#line 1129
}
#line 1129

static int
#line 1130
ncx_get_uint_short(const void *xp, short *ip)
#line 1130
{
#line 1130
    int err=NC_NOERR;
#line 1130
    ix_uint xx;
#line 1130
    get_ix_uint(xp, &xx);
#line 1130

#line 1130
#if IX_UINT_MAX > SHORT_MAX
#line 1130
    if (xx > SHORT_MAX) {
#line 1130

#line 1130
        err = NC_ERANGE;
#line 1130
    }
#line 1130
#endif
#line 1130

#line 1130

#line 1130
    *ip = (short) xx;
#line 1130
    return err;
#line 1130
}
#line 1130

static int
#line 1131
ncx_get_uint_int(const void *xp, int *ip)
#line 1131
{
#line 1131
    int err=NC_NOERR;
#line 1131
    ix_uint xx;
#line 1131
    get_ix_uint(xp, &xx);
#line 1131

#line 1131
#if IX_UINT_MAX > INT_MAX
#line 1131
    if (xx > INT_MAX) {
#line 1131

#line 1131
        err = NC_ERANGE;
#line 1131
    }
#line 1131
#endif
#line 1131

#line 1131

#line 1131
    *ip = (int) xx;
#line 1131
    return err;
#line 1131
}
#line 1131

static int
#line 1132
ncx_get_uint_long(const void *xp, long *ip)
#line 1132
{
#line 1132
    int err=NC_NOERR;
#line 1132
    ix_uint xx;
#line 1132
    get_ix_uint(xp, &xx);
#line 1132

#line 1132
#if IX_UINT_MAX > LONG_MAX
#line 1132
    if (xx > LONG_MAX) {
#line 1132

#line 1132
        err = NC_ERANGE;
#line 1132
    }
#line 1132
#endif
#line 1132

#line 1132

#line 1132
    *ip = (long) xx;
#line 1132
    return err;
#line 1132
}
#line 1132

static int
#line 1133
ncx_get_uint_longlong(const void *xp, longlong *ip)
#line 1133
{
#line 1133
    int err=NC_NOERR;
#line 1133
    ix_uint xx;
#line 1133
    get_ix_uint(xp, &xx);
#line 1133

#line 1133
#if IX_UINT_MAX > LONGLONG_MAX
#line 1133
    if (xx > LONGLONG_MAX) {
#line 1133

#line 1133
        err = NC_ERANGE;
#line 1133
    }
#line 1133
#endif
#line 1133

#line 1133

#line 1133
    *ip = (longlong) xx;
#line 1133
    return err;
#line 1133
}
#line 1133

static int
#line 1134
ncx_get_uint_ushort(const void *xp, ushort *ip)
#line 1134
{
#line 1134
    int err=NC_NOERR;
#line 1134
#if SIZEOF_IX_UINT == SIZEOF_USHORT && IX_UINT_MAX == USHORT_MAX
#line 1134
    get_ix_uint(xp, (ix_uint *)ip);
#line 1134
#else
#line 1134
    ix_uint xx;
#line 1134
    get_ix_uint(xp, &xx);
#line 1134

#line 1134
#if IX_UINT_MAX > USHORT_MAX
#line 1134
    if (xx > USHORT_MAX) {
#line 1134

#line 1134
        err = NC_ERANGE;
#line 1134
    }
#line 1134
#endif
#line 1134

#line 1134

#line 1134
    *ip = (ushort) xx;
#line 1134
#endif
#line 1134
    return err;
#line 1134
}
#line 1134

static int
#line 1135
ncx_get_uint_uchar(const void *xp, uchar *ip)
#line 1135
{
#line 1135
    int err=NC_NOERR;
#line 1135
#if SIZEOF_IX_UINT == SIZEOF_UCHAR && IX_UINT_MAX == UCHAR_MAX
#line 1135
    get_ix_uint(xp, (ix_uint *)ip);
#line 1135
#else
#line 1135
    ix_uint xx;
#line 1135
    get_ix_uint(xp, &xx);
#line 1135

#line 1135
#if IX_UINT_MAX > UCHAR_MAX
#line 1135
    if (xx > UCHAR_MAX) {
#line 1135

#line 1135
        err = NC_ERANGE;
#line 1135
    }
#line 1135
#endif
#line 1135

#line 1135

#line 1135
    *ip = (uchar) xx;
#line 1135
#endif
#line 1135
    return err;
#line 1135
}
#line 1135

static int
#line 1136
ncx_get_uint_ulonglong(const void *xp, ulonglong *ip)
#line 1136
{
#line 1136
    int err=NC_NOERR;
#line 1136
#if SIZEOF_IX_UINT == SIZEOF_ULONGLONG && IX_UINT_MAX == ULONGLONG_MAX
#line 1136
    get_ix_uint(xp, (ix_uint *)ip);
#line 1136
#else
#line 1136
    ix_uint xx;
#line 1136
    get_ix_uint(xp, &xx);
#line 1136

#line 1136
#if IX_UINT_MAX > ULONGLONG_MAX
#line 1136
    if (xx > ULONGLONG_MAX) {
#line 1136

#line 1136
        err = NC_ERANGE;
#line 1136
    }
#line 1136
#endif
#line 1136

#line 1136

#line 1136
    *ip = (ulonglong) xx;
#line 1136
#endif
#line 1136
    return err;
#line 1136
}
#line 1136

static int
#line 1137
ncx_get_uint_float(const void *xp, float *ip)
#line 1137
{
#line 1137
	ix_uint xx;
#line 1137
	get_ix_uint(xp, &xx);
#line 1137
	*ip = (float)xx;
#line 1137
	return NC_NOERR;
#line 1137
}
#line 1137

static int
#line 1138
ncx_get_uint_double(const void *xp, double *ip)
#line 1138
{
#line 1138
	ix_uint xx;
#line 1138
	get_ix_uint(xp, &xx);
#line 1138
	*ip = (double)xx;
#line 1138
	return NC_NOERR;
#line 1138
}
#line 1138


static int
ncx_put_uint_schar(void *xp, const schar *ip, void *fillp)
{
    uchar *cp;
    if (*ip < 0) {
#line 1149

        return NC_ERANGE;
    }

    cp = (uchar *) xp;
    *cp++ = 0x00;
    *cp++ = 0x00;
    *cp++ = 0x00;
    *cp = (uchar)*ip;

    return NC_NOERR;
}

static int
ncx_put_uint_uchar(void *xp, const uchar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return NC_NOERR;
}

#if X_SIZEOF_UINT != SIZEOF_UINT
static int
#line 1174
ncx_put_uint_uint(void *xp, const uint *ip, void *fillp)
#line 1174
{
#line 1174
    int err=NC_NOERR;
#line 1174
#if SIZEOF_IX_UINT == SIZEOF_UINT && IX_UINT_MAX == UINT_MAX
#line 1174
    put_ix_uint(xp, (const ix_uint *)ip);
#line 1174
#else
#line 1174
    ix_uint xx = NC_FILL_UINT;
#line 1174

#line 1174
#if IX_UINT_MAX < UINT_MAX
#line 1174
    if (*ip > IX_UINT_MAX) {
#line 1174
        
#line 1174
        err = NC_ERANGE;
#line 1174
    } 
#line 1174
#endif
#line 1174
        xx = (ix_uint)*ip;
#line 1174

#line 1174
    put_ix_uint(xp, &xx);
#line 1174
#endif
#line 1174
    return err;
#line 1174
}
#line 1174

#endif

static int
#line 1177
ncx_put_uint_short(void *xp, const short *ip, void *fillp)
#line 1177
{
#line 1177
    int err=NC_NOERR;
#line 1177
    ix_uint xx = NC_FILL_UINT;
#line 1177

#line 1177
#if IX_UINT_MAX < SHORT_MAX
#line 1177
    if (*ip > IX_UINT_MAX) {
#line 1177
        
#line 1177
        err = NC_ERANGE;
#line 1177
    } 
#line 1177
#endif
#line 1177
    if (*ip < 0) {
#line 1177
        
#line 1177
        err = NC_ERANGE; /* because xp is unsigned */
#line 1177
    } 
#line 1177
        xx = (ix_uint)*ip;
#line 1177

#line 1177
    put_ix_uint(xp, &xx);
#line 1177
    return err;
#line 1177
}
#line 1177

static int
#line 1178
ncx_put_uint_int(void *xp, const int *ip, void *fillp)
#line 1178
{
#line 1178
    int err=NC_NOERR;
#line 1178
    ix_uint xx = NC_FILL_UINT;
#line 1178

#line 1178
#if IX_UINT_MAX < INT_MAX
#line 1178
    if (*ip > IX_UINT_MAX) {
#line 1178
        
#line 1178
        err = NC_ERANGE;
#line 1178
    } 
#line 1178
#endif
#line 1178
    if (*ip < 0) {
#line 1178
        
#line 1178
        err = NC_ERANGE; /* because xp is unsigned */
#line 1178
    } 
#line 1178
        xx = (ix_uint)*ip;
#line 1178

#line 1178
    put_ix_uint(xp, &xx);
#line 1178
    return err;
#line 1178
}
#line 1178

static int
#line 1179
ncx_put_uint_long(void *xp, const long *ip, void *fillp)
#line 1179
{
#line 1179
    int err=NC_NOERR;
#line 1179
    ix_uint xx = NC_FILL_UINT;
#line 1179

#line 1179
#if IX_UINT_MAX < LONG_MAX
#line 1179
    if (*ip > IX_UINT_MAX) {
#line 1179
        
#line 1179
        err = NC_ERANGE;
#line 1179
    } 
#line 1179
#endif
#line 1179
    if (*ip < 0) {
#line 1179
        
#line 1179
        err = NC_ERANGE; /* because xp is unsigned */
#line 1179
    } 
#line 1179
        xx = (ix_uint)*ip;
#line 1179

#line 1179
    put_ix_uint(xp, &xx);
#line 1179
    return err;
#line 1179
}
#line 1179

static int
#line 1180
ncx_put_uint_longlong(void *xp, const longlong *ip, void *fillp)
#line 1180
{
#line 1180
    int err=NC_NOERR;
#line 1180
    ix_uint xx = NC_FILL_UINT;
#line 1180

#line 1180
#if IX_UINT_MAX < LONGLONG_MAX
#line 1180
    if (*ip > IX_UINT_MAX) {
#line 1180
        
#line 1180
        err = NC_ERANGE;
#line 1180
    } 
#line 1180
#endif
#line 1180
    if (*ip < 0) {
#line 1180
        
#line 1180
        err = NC_ERANGE; /* because xp is unsigned */
#line 1180
    } 
#line 1180
        xx = (ix_uint)*ip;
#line 1180

#line 1180
    put_ix_uint(xp, &xx);
#line 1180
    return err;
#line 1180
}
#line 1180

static int
#line 1181
ncx_put_uint_ushort(void *xp, const ushort *ip, void *fillp)
#line 1181
{
#line 1181
    int err=NC_NOERR;
#line 1181
#if SIZEOF_IX_UINT == SIZEOF_USHORT && IX_UINT_MAX == USHORT_MAX
#line 1181
    put_ix_uint(xp, (const ix_uint *)ip);
#line 1181
#else
#line 1181
    ix_uint xx = NC_FILL_UINT;
#line 1181

#line 1181
#if IX_UINT_MAX < USHORT_MAX
#line 1181
    if (*ip > IX_UINT_MAX) {
#line 1181
        
#line 1181
        err = NC_ERANGE;
#line 1181
    } 
#line 1181
#endif
#line 1181
        xx = (ix_uint)*ip;
#line 1181

#line 1181
    put_ix_uint(xp, &xx);
#line 1181
#endif
#line 1181
    return err;
#line 1181
}
#line 1181

static int
#line 1182
ncx_put_uint_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 1182
{
#line 1182
    int err=NC_NOERR;
#line 1182
#if SIZEOF_IX_UINT == SIZEOF_ULONGLONG && IX_UINT_MAX == ULONGLONG_MAX
#line 1182
    put_ix_uint(xp, (const ix_uint *)ip);
#line 1182
#else
#line 1182
    ix_uint xx = NC_FILL_UINT;
#line 1182

#line 1182
#if IX_UINT_MAX < ULONGLONG_MAX
#line 1182
    if (*ip > IX_UINT_MAX) {
#line 1182
        
#line 1182
        err = NC_ERANGE;
#line 1182
    } 
#line 1182
#endif
#line 1182
        xx = (ix_uint)*ip;
#line 1182

#line 1182
    put_ix_uint(xp, &xx);
#line 1182
#endif
#line 1182
    return err;
#line 1182
}
#line 1182

static int
#line 1183
ncx_put_uint_float(void *xp, const float *ip, void *fillp)
#line 1183
{
#line 1183
    int err=NC_NOERR;
#line 1183
    ix_uint xx = NC_FILL_UINT;
#line 1183

#line 1183
    if (*ip > (double)X_UINT_MAX || *ip < 0) {
#line 1183
        
#line 1183
        err = NC_ERANGE;
#line 1183
    } 
#line 1183
        xx = (ix_uint)*ip;
#line 1183

#line 1183
    put_ix_uint(xp, &xx);
#line 1183
    return err;
#line 1183
}
#line 1183

static int
#line 1184
ncx_put_uint_double(void *xp, const double *ip, void *fillp)
#line 1184
{
#line 1184
    int err=NC_NOERR;
#line 1184
    ix_uint xx = NC_FILL_UINT;
#line 1184

#line 1184
    if (*ip > X_UINT_MAX || *ip < 0) {
#line 1184
        
#line 1184
        err = NC_ERANGE;
#line 1184
    } 
#line 1184
        xx = (ix_uint)*ip;
#line 1184

#line 1184
    put_ix_uint(xp, &xx);
#line 1184
    return err;
#line 1184
}
#line 1184



/* external NC_FLOAT --------------------------------------------------------*/

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)

inline static void
get_ix_float(const void *xp, float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, SIZEOF_FLOAT);
#else
	swap4b(ip, xp);
#endif
}

inline static void
put_ix_float(void *xp, const float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_FLOAT);
#else
	swap4b(xp, ip);
#endif
}

#elif defined(vax) && vax != 0

/* What IEEE single precision floating point looks like on a Vax */
struct	ieee_single {
	unsigned int	exp_hi       : 7;
	unsigned int	sign         : 1;
	unsigned int 	mant_hi      : 7;
	unsigned int	exp_lo       : 1;
	unsigned int	mant_lo_hi   : 8;
	unsigned int	mant_lo_lo   : 8;
};

/* Vax single precision floating point */
struct	vax_single {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
};

#define VAX_SNG_BIAS	0x81
#define IEEE_SNG_BIAS	0x7f

static struct sgl_limits {
	struct vax_single s;
	struct ieee_single ieee;
} max = {
	{ 0x7f, 0xff, 0x0, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0x1, 0x0, 0x0 }		/* Max IEEE */
};
static struct sgl_limits min = {
	{ 0x0, 0x0, 0x0, 0x0 },	/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }		/* Min IEEE */
};

#line 1298
static void
get_ix_float(const void *xp, float *ip)
{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 1301
		const struct ieee_single *const isp =
#line 1301
			 (const struct ieee_single *) xp;
#line 1301
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 1301

#line 1301
		switch(exp) {
#line 1301
		case 0 :
#line 1301
			/* ieee subnormal */
#line 1301
			if (isp->mant_hi == min.ieee.mant_hi
#line 1301
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 1301
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 1301
			{
#line 1301
				*vsp = min.s;
#line 1301
			}
#line 1301
			else
#line 1301
			{
#line 1301
				unsigned mantissa = (isp->mant_hi << 16)
#line 1301
					 | isp->mant_lo_hi << 8
#line 1301
					 | isp->mant_lo_lo;
#line 1301
				unsigned tmp = mantissa >> 20;
#line 1301
				if (tmp >= 4) {
#line 1301
					vsp->exp = 2;
#line 1301
				} else if (tmp >= 2) {
#line 1301
					vsp->exp = 1;
#line 1301
				} else {
#line 1301
					*vsp = min.s;
#line 1301
					break;
#line 1301
				} /* else */
#line 1301
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 1301
				tmp <<= 3 - vsp->exp;
#line 1301
				vsp->mantissa2 = tmp;
#line 1301
				vsp->mantissa1 = (tmp >> 16);
#line 1301
			}
#line 1301
			break;
#line 1301
		case 0xfe :
#line 1301
		case 0xff :
#line 1301
			*vsp = max.s;
#line 1301
			break;
#line 1301
		default :
#line 1301
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 1301
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 1301
			vsp->mantissa1 = isp->mant_hi;
#line 1301
		}
#line 1301

#line 1301
		vsp->sign = isp->sign;
#line 1301

}

#line 1355

static void
put_ix_float(void *xp, const float *ip)
{
		const struct vax_single *const vsp =
#line 1359
			 (const struct vax_single *)ip;
#line 1359
		struct ieee_single *const isp = (struct ieee_single *) xp;
#line 1359

#line 1359
		switch(vsp->exp){
#line 1359
		case 0 :
#line 1359
			/* all vax float with zero exponent map to zero */
#line 1359
			*isp = min.ieee;
#line 1359
			break;
#line 1359
		case 2 :
#line 1359
		case 1 :
#line 1359
		{
#line 1359
			/* These will map to subnormals */
#line 1359
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 1359
					 | vsp->mantissa2;
#line 1359
			mantissa >>= 3 - vsp->exp;
#line 1359
			mantissa += (1 << (20 + vsp->exp));
#line 1359
			isp->mant_lo_lo = mantissa;
#line 1359
			isp->mant_lo_hi = mantissa >> 8;
#line 1359
			isp->mant_hi = mantissa >> 16;
#line 1359
			isp->exp_lo = 0;
#line 1359
			isp->exp_hi = 0;
#line 1359
		}
#line 1359
			break;
#line 1359
		case 0xff : /* max.s.exp */
#line 1359
			if (vsp->mantissa2 == max.s.mantissa2 &&
#line 1359
			    vsp->mantissa1 == max.s.mantissa1)
#line 1359
			{
#line 1359
				/* map largest vax float to ieee infinity */
#line 1359
				*isp = max.ieee;
#line 1359
				break;
#line 1359
			} /* else, fall thru */
#line 1359
		default :
#line 1359
		{
#line 1359
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 1359
			isp->exp_hi = exp >> 1;
#line 1359
			isp->exp_lo = exp;
#line 1359
			isp->mant_lo_lo = vsp->mantissa2;
#line 1359
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 1359
			isp->mant_hi = vsp->mantissa1;
#line 1359
		}
#line 1359
		}
#line 1359

#line 1359
		isp->sign = vsp->sign;
#line 1359

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

/*
 * Return the number of bytes until the next "word" boundary
 * N.B. This is based on the very weird YMP address structure,
 * which puts the address within a word in the leftmost 3 bits
 * of the address.
 */
static size_t
word_align(const void *vp)
{
	const size_t rem = ((size_t)vp >> (64 - 3)) & 0x7;
	return (rem != 0);
}

struct ieee_single_hi {
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
	unsigned int	pad	:32;
};
typedef struct ieee_single_hi ieee_single_hi;

struct ieee_single_lo {
	unsigned int	pad	:32;
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
};
typedef struct ieee_single_lo ieee_single_lo;

static const int ieee_single_bias = 0x7f;

struct ieee_double {
	unsigned int	sign	: 1;
	unsigned int	 exp	:11;
	unsigned int	mant	:52;
};
typedef struct ieee_double ieee_double;

static const int ieee_double_bias = 0x3ff;

#if defined(NO_IEEE_FLOAT)

struct cray_single {
	unsigned int	sign	: 1;
	unsigned int	 exp	:15;
	unsigned int	mant	:48;
};
typedef struct cray_single cray_single;

static const int cs_ieis_bias = 0x4000 - 0x7f;

static const int cs_id_bias = 0x4000 - 0x3ff;

#line 1494

static void
get_ix_float(const void *xp, float *ip)
{

	if (word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1502

#line 1502
		if (isp->exp == 0)
#line 1502
		{
#line 1502
			/* ieee subnormal */
#line 1502
			*ip = (double)isp->mant;
#line 1502
			if (isp->mant != 0)
#line 1502
			{
#line 1502
				csp->exp -= (ieee_single_bias + 22);
#line 1502
			}
#line 1502
		}
#line 1502
		else
#line 1502
		{
#line 1502
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1502
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1502
			csp->mant |= (1 << (48 - 1));
#line 1502
		}
#line 1502
		csp->sign = isp->sign;
#line 1502

#line 1502

	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1507

#line 1507
		if (isp->exp == 0)
#line 1507
		{
#line 1507
			/* ieee subnormal */
#line 1507
			*ip = (double)isp->mant;
#line 1507
			if (isp->mant != 0)
#line 1507
			{
#line 1507
				csp->exp -= (ieee_single_bias + 22);
#line 1507
			}
#line 1507
		}
#line 1507
		else
#line 1507
		{
#line 1507
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1507
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1507
			csp->mant |= (1 << (48 - 1));
#line 1507
		}
#line 1507
		csp->sign = isp->sign;
#line 1507

#line 1507

	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	if (word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1517
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1517

#line 1517
	isp->sign = csp->sign;
#line 1517

#line 1517
	if (ieee_exp >= 0xff)
#line 1517
	{
#line 1517
		/* NC_ERANGE => ieee Inf */
#line 1517
		isp->exp = 0xff;
#line 1517
		isp->mant = 0x0;
#line 1517
	}
#line 1517
	else if (ieee_exp > 0)
#line 1517
	{
#line 1517
		/* normal ieee representation */
#line 1517
		isp->exp  = ieee_exp;
#line 1517
		/* assumes cray rep is in normal form */
#line 1517
		assert(csp->mant & 0x800000000000);
#line 1517
		isp->mant = (((csp->mant << 1) &
#line 1517
				0xffffffffffff) >> (48 - 23));
#line 1517
	}
#line 1517
	else if (ieee_exp > -23)
#line 1517
	{
#line 1517
		/* ieee subnormal, right shift */
#line 1517
		const int rshift = (48 - 23 - ieee_exp);
#line 1517

#line 1517
		isp->mant = csp->mant >> rshift;
#line 1517

#line 1517
#if 0
#line 1517
		if (csp->mant & (1 << (rshift -1)))
#line 1517
		{
#line 1517
			/* round up */
#line 1517
			isp->mant++;
#line 1517
		}
#line 1517
#endif
#line 1517

#line 1517
		isp->exp  = 0;
#line 1517
	}
#line 1517
	else
#line 1517
	{
#line 1517
		/* smaller than ieee can represent */
#line 1517
		isp->exp = 0;
#line 1517
		isp->mant = 0;
#line 1517
	}
#line 1517

	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1522
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1522

#line 1522
	isp->sign = csp->sign;
#line 1522

#line 1522
	if (ieee_exp >= 0xff)
#line 1522
	{
#line 1522
		/* NC_ERANGE => ieee Inf */
#line 1522
		isp->exp = 0xff;
#line 1522
		isp->mant = 0x0;
#line 1522
	}
#line 1522
	else if (ieee_exp > 0)
#line 1522
	{
#line 1522
		/* normal ieee representation */
#line 1522
		isp->exp  = ieee_exp;
#line 1522
		/* assumes cray rep is in normal form */
#line 1522
		assert(csp->mant & 0x800000000000);
#line 1522
		isp->mant = (((csp->mant << 1) &
#line 1522
				0xffffffffffff) >> (48 - 23));
#line 1522
	}
#line 1522
	else if (ieee_exp > -23)
#line 1522
	{
#line 1522
		/* ieee subnormal, right shift */
#line 1522
		const int rshift = (48 - 23 - ieee_exp);
#line 1522

#line 1522
		isp->mant = csp->mant >> rshift;
#line 1522

#line 1522
#if 0
#line 1522
		if (csp->mant & (1 << (rshift -1)))
#line 1522
		{
#line 1522
			/* round up */
#line 1522
			isp->mant++;
#line 1522
		}
#line 1522
#endif
#line 1522

#line 1522
		isp->exp  = 0;
#line 1522
	}
#line 1522
	else
#line 1522
	{
#line 1522
		/* smaller than ieee can represent */
#line 1522
		isp->exp = 0;
#line 1522
		isp->mant = 0;
#line 1522
	}
#line 1522

	}
}

#else
	/* IEEE Cray with only doubles */
static void
get_ix_float(const void *xp, float *ip)
{

	ieee_double *idp = (ieee_double *) ip;

	if (word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		if (isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		if (isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	const ieee_double *idp = (const ieee_double *) ip;
	if (word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
		if (idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
		if (idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
}
#endif

#else
#error "ix_float implementation"
#endif

#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
static int
ncx_get_float_float(const void *xp, float *ip, void *fillp)
{
	/* TODO */
	get_ix_float(xp, ip);
	return NC_NOERR;
}
#endif

#define ix_float float

static int
#line 1609
ncx_get_float_schar(const void *xp, schar *ip)
#line 1609
{
#line 1609
	ix_float xx;
#line 1609
	get_ix_float(xp, &xx);
#line 1609
	if (xx > (double)SCHAR_MAX || xx < (double)SCHAR_MIN) {
#line 1609
            
#line 1609
            return NC_ERANGE;
#line 1609
        }
#line 1609
	*ip = (schar)xx;
#line 1609
	return NC_NOERR;
#line 1609
}
#line 1609

static int
#line 1610
ncx_get_float_short(const void *xp, short *ip)
#line 1610
{
#line 1610
	ix_float xx;
#line 1610
	get_ix_float(xp, &xx);
#line 1610
	if (xx > (double)SHORT_MAX || xx < (double)SHORT_MIN) {
#line 1610
            
#line 1610
            return NC_ERANGE;
#line 1610
        }
#line 1610
	*ip = (short)xx;
#line 1610
	return NC_NOERR;
#line 1610
}
#line 1610

static int
#line 1611
ncx_get_float_int(const void *xp, int *ip)
#line 1611
{
#line 1611
	ix_float xx;
#line 1611
	get_ix_float(xp, &xx);
#line 1611
	if (xx > (double)INT_MAX || xx < (double)INT_MIN) {
#line 1611
            
#line 1611
            return NC_ERANGE;
#line 1611
        }
#line 1611
	*ip = (int)xx;
#line 1611
	return NC_NOERR;
#line 1611
}
#line 1611

static int
#line 1612
ncx_get_float_long(const void *xp, long *ip)
#line 1612
{
#line 1612
	ix_float xx;
#line 1612
	get_ix_float(xp, &xx);
#line 1612
	if (xx > (double)LONG_MAX || xx < (double)LONG_MIN) {
#line 1612
            
#line 1612
            return NC_ERANGE;
#line 1612
        }
#line 1612
	*ip = (long)xx;
#line 1612
	return NC_NOERR;
#line 1612
}
#line 1612

static int
#line 1613
ncx_get_float_double(const void *xp, double *ip)
#line 1613
{
#line 1613
	ix_float xx;
#line 1613
	get_ix_float(xp, &xx);
#line 1613
	*ip = (double)xx;
#line 1613
	return NC_NOERR;
#line 1613
}
#line 1613

static int
#line 1614
ncx_get_float_longlong(const void *xp, longlong *ip)
#line 1614
{
#line 1614
	ix_float xx;
#line 1614
	get_ix_float(xp, &xx);
#line 1614
	if (xx == LONGLONG_MAX)      *ip = LONGLONG_MAX;
#line 1614
	else if (xx == LONGLONG_MIN) *ip = LONGLONG_MIN;
#line 1614
	else if (xx > (double)LONGLONG_MAX || xx < (double)LONGLONG_MIN) {
#line 1614
            
#line 1614
            return NC_ERANGE;
#line 1614
        }
#line 1614
	else *ip = (longlong)xx;
#line 1614
	return NC_NOERR;
#line 1614
}
#line 1614

static int
#line 1615
ncx_get_float_uchar(const void *xp, uchar *ip)
#line 1615
{
#line 1615
	ix_float xx;
#line 1615
	get_ix_float(xp, &xx);
#line 1615
	if (xx > (double)UCHAR_MAX || xx < 0) {
#line 1615
            
#line 1615
            return NC_ERANGE;
#line 1615
        }
#line 1615
	*ip = (uchar)xx;
#line 1615
	return NC_NOERR;
#line 1615
}
#line 1615

static int
#line 1616
ncx_get_float_ushort(const void *xp, ushort *ip)
#line 1616
{
#line 1616
	ix_float xx;
#line 1616
	get_ix_float(xp, &xx);
#line 1616
	if (xx > (double)USHORT_MAX || xx < 0) {
#line 1616
            
#line 1616
            return NC_ERANGE;
#line 1616
        }
#line 1616
	*ip = (ushort)xx;
#line 1616
	return NC_NOERR;
#line 1616
}
#line 1616

static int
#line 1617
ncx_get_float_uint(const void *xp, uint *ip)
#line 1617
{
#line 1617
	ix_float xx;
#line 1617
	get_ix_float(xp, &xx);
#line 1617
	if (xx > (double)UINT_MAX || xx < 0) {
#line 1617
            
#line 1617
            return NC_ERANGE;
#line 1617
        }
#line 1617
	*ip = (uint)xx;
#line 1617
	return NC_NOERR;
#line 1617
}
#line 1617

static int
#line 1618
ncx_get_float_ulonglong(const void *xp, ulonglong *ip)
#line 1618
{
#line 1618
	ix_float xx;
#line 1618
	get_ix_float(xp, &xx);
#line 1618
	if (xx == ULONGLONG_MAX)      *ip = ULONGLONG_MAX;
#line 1618
	else if (xx > (double)ULONGLONG_MAX || xx < 0) {
#line 1618
            
#line 1618
            return NC_ERANGE;
#line 1618
        }
#line 1618
	else *ip = (ulonglong)xx;
#line 1618
	return NC_NOERR;
#line 1618
}
#line 1618


#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
static int
ncx_put_float_float(void *xp, const float *ip, void *fillp)
{
    int err=NC_NOERR;
    float *_ip=ip;
#ifdef NO_IEEE_FLOAT
    
    if (*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN) {
        
        
        err = NC_ERANGE;
    }
#endif
    put_ix_float(xp, _ip);
    return err;
}
#endif

static int
#line 1639
ncx_put_float_schar(void *xp, const schar *ip, void *fillp)
#line 1639
{
#line 1639
    int err=NC_NOERR;
#line 1639
    ix_float xx = NC_FILL_FLOAT;
#line 1639

#line 1639
    
#line 1639
        xx = (ix_float)*ip;
#line 1639

#line 1639
    put_ix_float(xp, &xx);
#line 1639
    return err;
#line 1639
}
#line 1639

static int
#line 1640
ncx_put_float_short(void *xp, const short *ip, void *fillp)
#line 1640
{
#line 1640
    int err=NC_NOERR;
#line 1640
    ix_float xx = NC_FILL_FLOAT;
#line 1640

#line 1640
    
#line 1640
        xx = (ix_float)*ip;
#line 1640

#line 1640
    put_ix_float(xp, &xx);
#line 1640
    return err;
#line 1640
}
#line 1640

static int
#line 1641
ncx_put_float_int(void *xp, const int *ip, void *fillp)
#line 1641
{
#line 1641
    int err=NC_NOERR;
#line 1641
    ix_float xx = NC_FILL_FLOAT;
#line 1641

#line 1641
    
#line 1641
        xx = (ix_float)*ip;
#line 1641

#line 1641
    put_ix_float(xp, &xx);
#line 1641
    return err;
#line 1641
}
#line 1641

static int
#line 1642
ncx_put_float_long(void *xp, const long *ip, void *fillp)
#line 1642
{
#line 1642
    int err=NC_NOERR;
#line 1642
    ix_float xx = NC_FILL_FLOAT;
#line 1642

#line 1642
    
#line 1642
        xx = (ix_float)*ip;
#line 1642

#line 1642
    put_ix_float(xp, &xx);
#line 1642
    return err;
#line 1642
}
#line 1642

static int
#line 1643
ncx_put_float_double(void *xp, const double *ip, void *fillp)
#line 1643
{
#line 1643
    int err=NC_NOERR;
#line 1643
    ix_float xx = NC_FILL_FLOAT;
#line 1643

#line 1643
    if (*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN) {
#line 1643
        
#line 1643
        err = NC_ERANGE;
#line 1643
    } 
#line 1643
        xx = (ix_float)*ip;
#line 1643

#line 1643
    put_ix_float(xp, &xx);
#line 1643
    return err;
#line 1643
}
#line 1643

static int
#line 1644
ncx_put_float_longlong(void *xp, const longlong *ip, void *fillp)
#line 1644
{
#line 1644
    int err=NC_NOERR;
#line 1644
    ix_float xx = NC_FILL_FLOAT;
#line 1644

#line 1644
    
#line 1644
        xx = (ix_float)*ip;
#line 1644

#line 1644
    put_ix_float(xp, &xx);
#line 1644
    return err;
#line 1644
}
#line 1644

static int
#line 1645
ncx_put_float_uchar(void *xp, const uchar *ip, void *fillp)
#line 1645
{
#line 1645
    int err=NC_NOERR;
#line 1645
    ix_float xx = NC_FILL_FLOAT;
#line 1645

#line 1645
    
#line 1645
        xx = (ix_float)*ip;
#line 1645

#line 1645
    put_ix_float(xp, &xx);
#line 1645
    return err;
#line 1645
}
#line 1645

static int
#line 1646
ncx_put_float_ushort(void *xp, const ushort *ip, void *fillp)
#line 1646
{
#line 1646
    int err=NC_NOERR;
#line 1646
    ix_float xx = NC_FILL_FLOAT;
#line 1646

#line 1646
    
#line 1646
        xx = (ix_float)*ip;
#line 1646

#line 1646
    put_ix_float(xp, &xx);
#line 1646
    return err;
#line 1646
}
#line 1646

static int
#line 1647
ncx_put_float_uint(void *xp, const uint *ip, void *fillp)
#line 1647
{
#line 1647
    int err=NC_NOERR;
#line 1647
    ix_float xx = NC_FILL_FLOAT;
#line 1647

#line 1647
    
#line 1647
        xx = (ix_float)*ip;
#line 1647

#line 1647
    put_ix_float(xp, &xx);
#line 1647
    return err;
#line 1647
}
#line 1647

static int
#line 1648
ncx_put_float_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 1648
{
#line 1648
    int err=NC_NOERR;
#line 1648
    ix_float xx = NC_FILL_FLOAT;
#line 1648

#line 1648
    
#line 1648
        xx = (ix_float)*ip;
#line 1648

#line 1648
    put_ix_float(xp, &xx);
#line 1648
    return err;
#line 1648
}
#line 1648



/* external NC_DOUBLE -------------------------------------------------------*/

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE  && !defined(NO_IEEE_FLOAT)

static void
get_ix_double(const void *xp, double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, SIZEOF_DOUBLE);
#else
	swap8b(ip, xp);
#endif
}

static void
put_ix_double(void *xp, const double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_DOUBLE);
#else
	swap8b(xp, ip);
#endif
}

#elif defined(vax) && vax != 0

/* What IEEE double precision floating point looks like on a Vax */
struct	ieee_double {
	unsigned int	exp_hi   : 7;
	unsigned int	sign     : 1;
	unsigned int 	mant_6   : 4;
	unsigned int	exp_lo   : 4;
	unsigned int	mant_5   : 8;
	unsigned int	mant_4   : 8;

	unsigned int	mant_lo  : 32;
};

/* Vax double precision floating point */
struct  vax_double {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
	unsigned int	mantissa3 : 16;
	unsigned int	mantissa4 : 16;
};

#define VAX_DBL_BIAS	0x81
#define IEEE_DBL_BIAS	0x3ff
#define MASK(nbits)	((1 << nbits) - 1)

static const struct dbl_limits {
	struct	vax_double d;
	struct	ieee_double ieee;
} dbl_limits[2] = {
	{{ 0x7f, 0xff, 0x0, 0xffff, 0xffff, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0}}, /* Max IEEE */
	{{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},		/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}, /* Min IEEE */
};


#line 1762
static void
get_ix_double(const void *xp, double *ip)
{
	struct vax_double *const vdp =
#line 1765
			 (struct vax_double *)ip;
#line 1765
	const struct ieee_double *const idp =
#line 1765
			 (const struct ieee_double *) xp;
#line 1765
	{
#line 1765
		const struct dbl_limits *lim;
#line 1765
		int ii;
#line 1765
		for (ii = 0, lim = dbl_limits;
#line 1765
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 1765
			ii++, lim++)
#line 1765
		{
#line 1765
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 1765
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 1765
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 1765
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 1765
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 1765
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 1765
				)
#line 1765
			{
#line 1765
				*vdp = lim->d;
#line 1765
				goto doneit;
#line 1765
			}
#line 1765
		}
#line 1765
	}
#line 1765
	{
#line 1765
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 1765
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 1765
	}
#line 1765
	{
#line 1765
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 1765
				 | (idp->mant_5 << 8)
#line 1765
				 | idp->mant_4);
#line 1765
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 1765
		vdp->mantissa1 = (mant_hi >> 13);
#line 1765
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 1765
				| (mant_lo >> 29);
#line 1765
		vdp->mantissa3 = (mant_lo >> 13);
#line 1765
		vdp->mantissa4 = (mant_lo << 3);
#line 1765
	}
#line 1765
	doneit:
#line 1765
		vdp->sign = idp->sign;
#line 1765

}


#line 1835
static void
put_ix_double(void *xp, const double *ip)
{
	const struct vax_double *const vdp =
#line 1838
			(const struct vax_double *)ip;
#line 1838
	struct ieee_double *const idp =
#line 1838
			 (struct ieee_double *) xp;
#line 1838

#line 1838
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 1838
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 1838
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 1838
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 1838
		(vdp->exp == dbl_limits[0].d.exp))
#line 1838
	{
#line 1838
		*idp = dbl_limits[0].ieee;
#line 1838
		goto shipit;
#line 1838
	}
#line 1838
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 1838
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 1838
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 1838
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 1838
		(vdp->exp == dbl_limits[1].d.exp))
#line 1838
	{
#line 1838
		*idp = dbl_limits[1].ieee;
#line 1838
		goto shipit;
#line 1838
	}
#line 1838

#line 1838
	{
#line 1838
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 1838

#line 1838
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 1838
			(vdp->mantissa3 << 13) |
#line 1838
			((vdp->mantissa4 >> 3) & MASK(13));
#line 1838

#line 1838
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 1838
				 | (vdp->mantissa2 >> 3);
#line 1838

#line 1838
		if ((vdp->mantissa4 & 7) > 4)
#line 1838
		{
#line 1838
			/* round up */
#line 1838
			mant_lo++;
#line 1838
			if (mant_lo == 0)
#line 1838
			{
#line 1838
				mant_hi++;
#line 1838
				if (mant_hi > 0xffffff)
#line 1838
				{
#line 1838
					mant_hi = 0;
#line 1838
					exp++;
#line 1838
				}
#line 1838
			}
#line 1838
		}
#line 1838

#line 1838
		idp->mant_lo = SWAP4(mant_lo);
#line 1838
		idp->mant_6 = mant_hi >> 16;
#line 1838
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 1838
		idp->mant_4 = mant_hi;
#line 1838
		idp->exp_hi = exp >> 4;
#line 1838
		idp->exp_lo = exp;
#line 1838
	}
#line 1838

#line 1838
	shipit:
#line 1838
		idp->sign = vdp->sign;
#line 1838

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

static void
get_ix_double(const void *xp, double *ip)
{
	const ieee_double *idp = (const ieee_double *) xp;
	cray_single *csp = (cray_single *) ip;

	if (idp->exp == 0)
	{
		/* ieee subnormal */
		*ip = (double)idp->mant;
		if (idp->mant != 0)
		{
			csp->exp -= (ieee_double_bias + 51);
		}
	}
	else
	{
		csp->exp  = idp->exp + cs_id_bias + 1;
		csp->mant = idp->mant >> (52 - 48 + 1);
		csp->mant |= (1 << (48 - 1));
	}
	csp->sign = idp->sign;
}

static void
put_ix_double(void *xp, const double *ip)
{
	ieee_double *idp = (ieee_double *) xp;
	const cray_single *csp = (const cray_single *) ip;

	int ieee_exp = csp->exp - cs_id_bias -1;

	idp->sign = csp->sign;

	if (ieee_exp >= 0x7ff)
	{
		/* NC_ERANGE => ieee Inf */
		idp->exp = 0x7ff;
		idp->mant = 0x0;
	}
	else if (ieee_exp > 0)
	{
		/* normal ieee representation */
		idp->exp  = ieee_exp;
		/* assumes cray rep is in normal form */
		assert(csp->mant & 0x800000000000);
		idp->mant = (((csp->mant << 1) &
				0xffffffffffff) << (52 - 48));
	}
	else if (ieee_exp >= (-(52 -48)))
	{
		/* ieee subnormal, left shift */
		const int lshift = (52 - 48) + ieee_exp;
		idp->mant = csp->mant << lshift;
		idp->exp  = 0;
	}
	else if (ieee_exp >= -52)
	{
		/* ieee subnormal, right shift */
		const int rshift = (- (52 - 48) - ieee_exp);

		idp->mant = csp->mant >> rshift;

#if 0
		if (csp->mant & (1 << (rshift -1)))
		{
			/* round up */
			idp->mant++;
		}
#endif

		idp->exp  = 0;
	}
	else
	{
		/* smaller than ieee can represent */
		idp->exp = 0;
		idp->mant = 0;
	}
}
#else
#error "ix_double implementation"
#endif

#define ix_double double

static int
#line 1930
ncx_get_double_schar(const void *xp, schar *ip)
#line 1930
{
#line 1930
	ix_double xx;
#line 1930
	get_ix_double(xp, &xx);
#line 1930
	if (xx > (double)SCHAR_MAX || xx < (double)SCHAR_MIN) {
#line 1930
            
#line 1930
            return NC_ERANGE;
#line 1930
        }
#line 1930
	*ip = (schar)xx;
#line 1930
	return NC_NOERR;
#line 1930
}
#line 1930

static int
#line 1931
ncx_get_double_short(const void *xp, short *ip)
#line 1931
{
#line 1931
	ix_double xx;
#line 1931
	get_ix_double(xp, &xx);
#line 1931
	if (xx > (double)SHORT_MAX || xx < (double)SHORT_MIN) {
#line 1931
            
#line 1931
            return NC_ERANGE;
#line 1931
        }
#line 1931
	*ip = (short)xx;
#line 1931
	return NC_NOERR;
#line 1931
}
#line 1931

static int
#line 1932
ncx_get_double_int(const void *xp, int *ip)
#line 1932
{
#line 1932
	ix_double xx;
#line 1932
	get_ix_double(xp, &xx);
#line 1932
	if (xx > (double)INT_MAX || xx < (double)INT_MIN) {
#line 1932
            
#line 1932
            return NC_ERANGE;
#line 1932
        }
#line 1932
	*ip = (int)xx;
#line 1932
	return NC_NOERR;
#line 1932
}
#line 1932

static int
#line 1933
ncx_get_double_long(const void *xp, long *ip)
#line 1933
{
#line 1933
	ix_double xx;
#line 1933
	get_ix_double(xp, &xx);
#line 1933
	if (xx > (double)LONG_MAX || xx < (double)LONG_MIN) {
#line 1933
            
#line 1933
            return NC_ERANGE;
#line 1933
        }
#line 1933
	*ip = (long)xx;
#line 1933
	return NC_NOERR;
#line 1933
}
#line 1933

static int
#line 1934
ncx_get_double_longlong(const void *xp, longlong *ip)
#line 1934
{
#line 1934
	ix_double xx;
#line 1934
	get_ix_double(xp, &xx);
#line 1934
	if (xx == LONGLONG_MAX)      *ip = LONGLONG_MAX;
#line 1934
	else if (xx == LONGLONG_MIN) *ip = LONGLONG_MIN;
#line 1934
	else if (xx > (double)LONGLONG_MAX || xx < (double)LONGLONG_MIN) {
#line 1934
            
#line 1934
            return NC_ERANGE;
#line 1934
        }
#line 1934
	else *ip = (longlong)xx;
#line 1934
	return NC_NOERR;
#line 1934
}
#line 1934

static int
#line 1935
ncx_get_double_uchar(const void *xp, uchar *ip)
#line 1935
{
#line 1935
	ix_double xx;
#line 1935
	get_ix_double(xp, &xx);
#line 1935
	if (xx > (double)UCHAR_MAX || xx < 0) {
#line 1935
            
#line 1935
            return NC_ERANGE;
#line 1935
        }
#line 1935
	*ip = (uchar)xx;
#line 1935
	return NC_NOERR;
#line 1935
}
#line 1935

static int
#line 1936
ncx_get_double_ushort(const void *xp, ushort *ip)
#line 1936
{
#line 1936
	ix_double xx;
#line 1936
	get_ix_double(xp, &xx);
#line 1936
	if (xx > (double)USHORT_MAX || xx < 0) {
#line 1936
            
#line 1936
            return NC_ERANGE;
#line 1936
        }
#line 1936
	*ip = (ushort)xx;
#line 1936
	return NC_NOERR;
#line 1936
}
#line 1936

static int
#line 1937
ncx_get_double_uint(const void *xp, uint *ip)
#line 1937
{
#line 1937
	ix_double xx;
#line 1937
	get_ix_double(xp, &xx);
#line 1937
	if (xx > (double)UINT_MAX || xx < 0) {
#line 1937
            
#line 1937
            return NC_ERANGE;
#line 1937
        }
#line 1937
	*ip = (uint)xx;
#line 1937
	return NC_NOERR;
#line 1937
}
#line 1937

static int
#line 1938
ncx_get_double_ulonglong(const void *xp, ulonglong *ip)
#line 1938
{
#line 1938
	ix_double xx;
#line 1938
	get_ix_double(xp, &xx);
#line 1938
	if (xx == ULONGLONG_MAX)      *ip = ULONGLONG_MAX;
#line 1938
	else if (xx > (double)ULONGLONG_MAX || xx < 0) {
#line 1938
            
#line 1938
            return NC_ERANGE;
#line 1938
        }
#line 1938
	else *ip = (ulonglong)xx;
#line 1938
	return NC_NOERR;
#line 1938
}
#line 1938


static int
ncx_get_double_float(const void *xp, float *ip)
{
    double xx;
    get_ix_double(xp, &xx);
    if (xx > FLT_MAX) {
        *ip = FLT_MAX;
        return NC_ERANGE;
    }
    if (xx < (-FLT_MAX)) {
        *ip = (-FLT_MAX);
        return NC_ERANGE;
    }
    *ip = (float) xx;
    return NC_NOERR;
}

#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
static int
ncx_get_double_double(const void *xp, double *ip, void *fillp)
{
	/* TODO */
	get_ix_double(xp, ip);
	return NC_NOERR;
}
#endif

static int
#line 1967
ncx_put_double_schar(void *xp, const schar *ip, void *fillp)
#line 1967
{
#line 1967
    int err=NC_NOERR;
#line 1967
    ix_double xx = NC_FILL_DOUBLE;
#line 1967

#line 1967
    
#line 1967
        xx = (ix_double)*ip;
#line 1967

#line 1967
    put_ix_double(xp, &xx);
#line 1967
    return err;
#line 1967
}
#line 1967

static int
#line 1968
ncx_put_double_uchar(void *xp, const uchar *ip, void *fillp)
#line 1968
{
#line 1968
    int err=NC_NOERR;
#line 1968
    ix_double xx = NC_FILL_DOUBLE;
#line 1968

#line 1968
    
#line 1968
        xx = (ix_double)*ip;
#line 1968

#line 1968
    put_ix_double(xp, &xx);
#line 1968
    return err;
#line 1968
}
#line 1968

static int
#line 1969
ncx_put_double_short(void *xp, const short *ip, void *fillp)
#line 1969
{
#line 1969
    int err=NC_NOERR;
#line 1969
    ix_double xx = NC_FILL_DOUBLE;
#line 1969

#line 1969
    
#line 1969
        xx = (ix_double)*ip;
#line 1969

#line 1969
    put_ix_double(xp, &xx);
#line 1969
    return err;
#line 1969
}
#line 1969

static int
#line 1970
ncx_put_double_ushort(void *xp, const ushort *ip, void *fillp)
#line 1970
{
#line 1970
    int err=NC_NOERR;
#line 1970
    ix_double xx = NC_FILL_DOUBLE;
#line 1970

#line 1970
    
#line 1970
        xx = (ix_double)*ip;
#line 1970

#line 1970
    put_ix_double(xp, &xx);
#line 1970
    return err;
#line 1970
}
#line 1970

static int
#line 1971
ncx_put_double_int(void *xp, const int *ip, void *fillp)
#line 1971
{
#line 1971
    int err=NC_NOERR;
#line 1971
    ix_double xx = NC_FILL_DOUBLE;
#line 1971

#line 1971
    
#line 1971
        xx = (ix_double)*ip;
#line 1971

#line 1971
    put_ix_double(xp, &xx);
#line 1971
    return err;
#line 1971
}
#line 1971

static int
#line 1972
ncx_put_double_long(void *xp, const long *ip, void *fillp)
#line 1972
{
#line 1972
    int err=NC_NOERR;
#line 1972
    ix_double xx = NC_FILL_DOUBLE;
#line 1972

#line 1972
    
#line 1972
        xx = (ix_double)*ip;
#line 1972

#line 1972
    put_ix_double(xp, &xx);
#line 1972
    return err;
#line 1972
}
#line 1972

static int
#line 1973
ncx_put_double_uint(void *xp, const uint *ip, void *fillp)
#line 1973
{
#line 1973
    int err=NC_NOERR;
#line 1973
    ix_double xx = NC_FILL_DOUBLE;
#line 1973

#line 1973
    
#line 1973
        xx = (ix_double)*ip;
#line 1973

#line 1973
    put_ix_double(xp, &xx);
#line 1973
    return err;
#line 1973
}
#line 1973

static int
#line 1974
ncx_put_double_longlong(void *xp, const longlong *ip, void *fillp)
#line 1974
{
#line 1974
    int err=NC_NOERR;
#line 1974
    ix_double xx = NC_FILL_DOUBLE;
#line 1974

#line 1974
    
#line 1974
        xx = (ix_double)*ip;
#line 1974

#line 1974
    put_ix_double(xp, &xx);
#line 1974
    return err;
#line 1974
}
#line 1974

static int
#line 1975
ncx_put_double_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 1975
{
#line 1975
    int err=NC_NOERR;
#line 1975
    ix_double xx = NC_FILL_DOUBLE;
#line 1975

#line 1975
    
#line 1975
        xx = (ix_double)*ip;
#line 1975

#line 1975
    put_ix_double(xp, &xx);
#line 1975
    return err;
#line 1975
}
#line 1975


static int
ncx_put_double_float(void *xp, const float *ip, void *fillp)
{
    int err=NC_NOERR;
    double xx = NC_FILL_DOUBLE;
#if 1	/* TODO: figure this out (if condition below will never be true)*/
    if ((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN) {
        
        err = NC_ERANGE;
    } 
#endif
        xx = (double) *ip;

    put_ix_double(xp, &xx);
    return err;
}

#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
static int
ncx_put_double_double(void *xp, const double *ip, void *fillp)
{
    int err=NC_NOERR;
    double *_ip = ip;
#ifdef NO_IEEE_FLOAT
    
    if (*ip > X_DOUBLE_MAX || *ip < X_DOUBLE_MIN) {
        
        
        err = NC_ERANGE;
    }
#endif
    put_ix_double(xp, _ip);
    return err;
}
#endif


/* external NC_INT64 --------------------------------------------------------*/

#if SHORT_MAX == X_INT64_MAX
typedef short ix_int64;
#define SIZEOF_IX_INT64 SIZEOF_SHORT
#define IX_INT64_MAX SHORT_MAX
#elif LONG_LONG_MAX  >= X_INT64_MAX
typedef longlong ix_int64;
#define SIZEOF_IX_INT64 SIZEOF_LONGLONG
#define IX_INT64_MAX LONG_LONG_MAX
#elif LONG_MAX  >= X_INT64_MAX
typedef long ix_int64;
#define SIZEOF_IX_INT64 SIZEOF_LONG
#define IX_INT64_MAX LONG_MAX
#else
#error "ix_int64 implementation"
#endif


static void
get_ix_int64(const void *xp, ix_int64 *ip)
{
    const uchar *cp = (const uchar *) xp;

    *ip  = ((ix_int64)(*cp++) << 56);
    *ip |= ((ix_int64)(*cp++) << 48);
    *ip |= ((ix_int64)(*cp++) << 40);
    *ip |= ((ix_int64)(*cp++) << 32);
    *ip |= ((ix_int64)(*cp++) << 24);
    *ip |= ((ix_int64)(*cp++) << 16);
    *ip |= ((ix_int64)(*cp++) <<  8);
    *ip |=  (ix_int64)*cp;
}

static void
put_ix_int64(void *xp, const ix_int64 *ip)
{
    uchar *cp = (uchar *) xp;

    *cp++ = (uchar)((*ip) >> 56);
    *cp++ = (uchar)(((*ip) & 0x00ff000000000000LL) >> 48);
    *cp++ = (uchar)(((*ip) & 0x0000ff0000000000LL) >> 40);
    *cp++ = (uchar)(((*ip) & 0x000000ff00000000LL) >> 32);
    *cp++ = (uchar)(((*ip) & 0x00000000ff000000LL) >> 24);
    *cp++ = (uchar)(((*ip) & 0x0000000000ff0000LL) >> 16);
    *cp++ = (uchar)(((*ip) & 0x000000000000ff00LL) >>  8);
    *cp   = (uchar)( (*ip) & 0x00000000000000ffLL);
}

#if X_SIZEOF_INT64 != SIZEOF_LONGLONG
static int
#line 2064
ncx_get_longlong_longlong(const void *xp, longlong *ip)
#line 2064
{
#line 2064
    int err=NC_NOERR;
#line 2064
#if SIZEOF_IX_INT64 == SIZEOF_LONGLONG && IX_INT64_MAX == LONGLONG_MAX
#line 2064
    get_ix_int64(xp, (ix_int64 *)ip);
#line 2064
#else
#line 2064
    ix_int64 xx;
#line 2064
    get_ix_int64(xp, &xx);
#line 2064

#line 2064
#if IX_INT64_MAX > LONGLONG_MAX
#line 2064
    if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) {
#line 2064

#line 2064
        err = NC_ERANGE;
#line 2064
    }
#line 2064
#endif
#line 2064

#line 2064

#line 2064
    *ip = (longlong) xx;
#line 2064
#endif
#line 2064
    return err;
#line 2064
}
#line 2064

#endif
static int
#line 2066
ncx_get_longlong_schar(const void *xp, schar *ip)
#line 2066
{
#line 2066
    int err=NC_NOERR;
#line 2066
    ix_int64 xx;
#line 2066
    get_ix_int64(xp, &xx);
#line 2066

#line 2066
#if IX_INT64_MAX > SCHAR_MAX
#line 2066
    if (xx > SCHAR_MAX || xx < SCHAR_MIN) {
#line 2066

#line 2066
        err = NC_ERANGE;
#line 2066
    }
#line 2066
#endif
#line 2066

#line 2066

#line 2066
    *ip = (schar) xx;
#line 2066
    return err;
#line 2066
}
#line 2066

static int
#line 2067
ncx_get_longlong_short(const void *xp, short *ip)
#line 2067
{
#line 2067
    int err=NC_NOERR;
#line 2067
#if SIZEOF_IX_INT64 == SIZEOF_SHORT && IX_INT64_MAX == SHORT_MAX
#line 2067
    get_ix_int64(xp, (ix_int64 *)ip);
#line 2067
#else
#line 2067
    ix_int64 xx;
#line 2067
    get_ix_int64(xp, &xx);
#line 2067

#line 2067
#if IX_INT64_MAX > SHORT_MAX
#line 2067
    if (xx > SHORT_MAX || xx < SHORT_MIN) {
#line 2067

#line 2067
        err = NC_ERANGE;
#line 2067
    }
#line 2067
#endif
#line 2067

#line 2067

#line 2067
    *ip = (short) xx;
#line 2067
#endif
#line 2067
    return err;
#line 2067
}
#line 2067

static int
#line 2068
ncx_get_longlong_int(const void *xp, int *ip)
#line 2068
{
#line 2068
    int err=NC_NOERR;
#line 2068
#if SIZEOF_IX_INT64 == SIZEOF_INT && IX_INT64_MAX == INT_MAX
#line 2068
    get_ix_int64(xp, (ix_int64 *)ip);
#line 2068
#else
#line 2068
    ix_int64 xx;
#line 2068
    get_ix_int64(xp, &xx);
#line 2068

#line 2068
#if IX_INT64_MAX > INT_MAX
#line 2068
    if (xx > INT_MAX || xx < INT_MIN) {
#line 2068

#line 2068
        err = NC_ERANGE;
#line 2068
    }
#line 2068
#endif
#line 2068

#line 2068

#line 2068
    *ip = (int) xx;
#line 2068
#endif
#line 2068
    return err;
#line 2068
}
#line 2068

static int
#line 2069
ncx_get_longlong_long(const void *xp, long *ip)
#line 2069
{
#line 2069
    int err=NC_NOERR;
#line 2069
#if SIZEOF_IX_INT64 == SIZEOF_LONG && IX_INT64_MAX == LONG_MAX
#line 2069
    get_ix_int64(xp, (ix_int64 *)ip);
#line 2069
#else
#line 2069
    ix_int64 xx;
#line 2069
    get_ix_int64(xp, &xx);
#line 2069

#line 2069
#if IX_INT64_MAX > LONG_MAX
#line 2069
    if (xx > LONG_MAX || xx < LONG_MIN) {
#line 2069

#line 2069
        err = NC_ERANGE;
#line 2069
    }
#line 2069
#endif
#line 2069

#line 2069

#line 2069
    *ip = (long) xx;
#line 2069
#endif
#line 2069
    return err;
#line 2069
}
#line 2069

static int
#line 2070
ncx_get_longlong_ushort(const void *xp, ushort *ip)
#line 2070
{
#line 2070
    int err=NC_NOERR;
#line 2070
    ix_int64 xx;
#line 2070
    get_ix_int64(xp, &xx);
#line 2070

#line 2070
#if IX_INT64_MAX > USHORT_MAX
#line 2070
    if (xx > USHORT_MAX) {
#line 2070

#line 2070
        err = NC_ERANGE;
#line 2070
    }
#line 2070
#endif
#line 2070

#line 2070
    if (xx < 0) {
#line 2070

#line 2070
        err = NC_ERANGE; /* because ip is unsigned */
#line 2070
    }
#line 2070
    *ip = (ushort) xx;
#line 2070
    return err;
#line 2070
}
#line 2070

static int
#line 2071
ncx_get_longlong_uchar(const void *xp, uchar *ip)
#line 2071
{
#line 2071
    int err=NC_NOERR;
#line 2071
    ix_int64 xx;
#line 2071
    get_ix_int64(xp, &xx);
#line 2071

#line 2071
#if IX_INT64_MAX > UCHAR_MAX
#line 2071
    if (xx > UCHAR_MAX) {
#line 2071

#line 2071
        err = NC_ERANGE;
#line 2071
    }
#line 2071
#endif
#line 2071

#line 2071
    if (xx < 0) {
#line 2071

#line 2071
        err = NC_ERANGE; /* because ip is unsigned */
#line 2071
    }
#line 2071
    *ip = (uchar) xx;
#line 2071
    return err;
#line 2071
}
#line 2071

static int
#line 2072
ncx_get_longlong_uint(const void *xp, uint *ip)
#line 2072
{
#line 2072
    int err=NC_NOERR;
#line 2072
    ix_int64 xx;
#line 2072
    get_ix_int64(xp, &xx);
#line 2072

#line 2072
#if IX_INT64_MAX > UINT_MAX
#line 2072
    if (xx > UINT_MAX) {
#line 2072

#line 2072
        err = NC_ERANGE;
#line 2072
    }
#line 2072
#endif
#line 2072

#line 2072
    if (xx < 0) {
#line 2072

#line 2072
        err = NC_ERANGE; /* because ip is unsigned */
#line 2072
    }
#line 2072
    *ip = (uint) xx;
#line 2072
    return err;
#line 2072
}
#line 2072

static int
#line 2073
ncx_get_longlong_ulonglong(const void *xp, ulonglong *ip)
#line 2073
{
#line 2073
    int err=NC_NOERR;
#line 2073
    ix_int64 xx;
#line 2073
    get_ix_int64(xp, &xx);
#line 2073

#line 2073
#if IX_INT64_MAX > ULONGLONG_MAX
#line 2073
    if (xx > ULONGLONG_MAX) {
#line 2073

#line 2073
        err = NC_ERANGE;
#line 2073
    }
#line 2073
#endif
#line 2073

#line 2073
    if (xx < 0) {
#line 2073

#line 2073
        err = NC_ERANGE; /* because ip is unsigned */
#line 2073
    }
#line 2073
    *ip = (ulonglong) xx;
#line 2073
    return err;
#line 2073
}
#line 2073

static int
#line 2074
ncx_get_longlong_float(const void *xp, float *ip)
#line 2074
{
#line 2074
	ix_int64 xx;
#line 2074
	get_ix_int64(xp, &xx);
#line 2074
	*ip = (float)xx;
#line 2074
	return NC_NOERR;
#line 2074
}
#line 2074

static int
#line 2075
ncx_get_longlong_double(const void *xp, double *ip)
#line 2075
{
#line 2075
	ix_int64 xx;
#line 2075
	get_ix_int64(xp, &xx);
#line 2075
	*ip = (double)xx;
#line 2075
	return NC_NOERR;
#line 2075
}
#line 2075


#if X_SIZEOF_INT64 != SIZEOF_LONGLONG
static int
#line 2078
ncx_put_longlong_longlong(void *xp, const longlong *ip, void *fillp)
#line 2078
{
#line 2078
    int err=NC_NOERR;
#line 2078
#if SIZEOF_IX_INT64 == SIZEOF_LONGLONG && IX_INT64_MAX == LONGLONG_MAX
#line 2078
    put_ix_int64(xp, (const ix_int64 *)ip);
#line 2078
#else
#line 2078
    ix_int64 xx = NC_FILL_INT64;
#line 2078

#line 2078
#if IX_INT64_MAX < LONGLONG_MAX
#line 2078
    if (*ip > IX_INT64_MAX || *ip < X_INT64_MIN) {
#line 2078
        
#line 2078
        err = NC_ERANGE;
#line 2078
    } 
#line 2078
#endif
#line 2078
        xx = (ix_int64)*ip;
#line 2078

#line 2078
    put_ix_int64(xp, &xx);
#line 2078
#endif
#line 2078
    return err;
#line 2078
}
#line 2078

#endif
static int
#line 2080
ncx_put_longlong_schar(void *xp, const schar *ip, void *fillp)
#line 2080
{
#line 2080
    int err=NC_NOERR;
#line 2080
    ix_int64 xx = NC_FILL_INT64;
#line 2080

#line 2080
#if IX_INT64_MAX < SCHAR_MAX
#line 2080
    if (*ip > IX_INT64_MAX || *ip < X_INT64_MIN) {
#line 2080
        
#line 2080
        err = NC_ERANGE;
#line 2080
    } 
#line 2080
#endif
#line 2080
        xx = (ix_int64)*ip;
#line 2080

#line 2080
    put_ix_int64(xp, &xx);
#line 2080
    return err;
#line 2080
}
#line 2080

static int
#line 2081
ncx_put_longlong_short(void *xp, const short *ip, void *fillp)
#line 2081
{
#line 2081
    int err=NC_NOERR;
#line 2081
#if SIZEOF_IX_INT64 == SIZEOF_SHORT && IX_INT64_MAX == SHORT_MAX
#line 2081
    put_ix_int64(xp, (const ix_int64 *)ip);
#line 2081
#else
#line 2081
    ix_int64 xx = NC_FILL_INT64;
#line 2081

#line 2081
#if IX_INT64_MAX < SHORT_MAX
#line 2081
    if (*ip > IX_INT64_MAX || *ip < X_INT64_MIN) {
#line 2081
        
#line 2081
        err = NC_ERANGE;
#line 2081
    } 
#line 2081
#endif
#line 2081
        xx = (ix_int64)*ip;
#line 2081

#line 2081
    put_ix_int64(xp, &xx);
#line 2081
#endif
#line 2081
    return err;
#line 2081
}
#line 2081

static int
#line 2082
ncx_put_longlong_int(void *xp, const int *ip, void *fillp)
#line 2082
{
#line 2082
    int err=NC_NOERR;
#line 2082
#if SIZEOF_IX_INT64 == SIZEOF_INT && IX_INT64_MAX == INT_MAX
#line 2082
    put_ix_int64(xp, (const ix_int64 *)ip);
#line 2082
#else
#line 2082
    ix_int64 xx = NC_FILL_INT64;
#line 2082

#line 2082
#if IX_INT64_MAX < INT_MAX
#line 2082
    if (*ip > IX_INT64_MAX || *ip < X_INT64_MIN) {
#line 2082
        
#line 2082
        err = NC_ERANGE;
#line 2082
    } 
#line 2082
#endif
#line 2082
        xx = (ix_int64)*ip;
#line 2082

#line 2082
    put_ix_int64(xp, &xx);
#line 2082
#endif
#line 2082
    return err;
#line 2082
}
#line 2082

static int
#line 2083
ncx_put_longlong_long(void *xp, const long *ip, void *fillp)
#line 2083
{
#line 2083
    int err=NC_NOERR;
#line 2083
#if SIZEOF_IX_INT64 == SIZEOF_LONG && IX_INT64_MAX == LONG_MAX
#line 2083
    put_ix_int64(xp, (const ix_int64 *)ip);
#line 2083
#else
#line 2083
    ix_int64 xx = NC_FILL_INT64;
#line 2083

#line 2083
#if IX_INT64_MAX < LONG_MAX
#line 2083
    if (*ip > IX_INT64_MAX || *ip < X_INT64_MIN) {
#line 2083
        
#line 2083
        err = NC_ERANGE;
#line 2083
    } 
#line 2083
#endif
#line 2083
        xx = (ix_int64)*ip;
#line 2083

#line 2083
    put_ix_int64(xp, &xx);
#line 2083
#endif
#line 2083
    return err;
#line 2083
}
#line 2083

static int
#line 2084
ncx_put_longlong_ushort(void *xp, const ushort *ip, void *fillp)
#line 2084
{
#line 2084
    int err=NC_NOERR;
#line 2084
    ix_int64 xx = NC_FILL_INT64;
#line 2084

#line 2084
#if IX_INT64_MAX < USHORT_MAX
#line 2084
    if (*ip > IX_INT64_MAX) {
#line 2084
        
#line 2084
        err = NC_ERANGE;
#line 2084
    } 
#line 2084
#endif
#line 2084
        xx = (ix_int64)*ip;
#line 2084

#line 2084
    put_ix_int64(xp, &xx);
#line 2084
    return err;
#line 2084
}
#line 2084

static int
#line 2085
ncx_put_longlong_uchar(void *xp, const uchar *ip, void *fillp)
#line 2085
{
#line 2085
    int err=NC_NOERR;
#line 2085
    ix_int64 xx = NC_FILL_INT64;
#line 2085

#line 2085
#if IX_INT64_MAX < UCHAR_MAX
#line 2085
    if (*ip > IX_INT64_MAX) {
#line 2085
        
#line 2085
        err = NC_ERANGE;
#line 2085
    } 
#line 2085
#endif
#line 2085
        xx = (ix_int64)*ip;
#line 2085

#line 2085
    put_ix_int64(xp, &xx);
#line 2085
    return err;
#line 2085
}
#line 2085

static int
#line 2086
ncx_put_longlong_uint(void *xp, const uint *ip, void *fillp)
#line 2086
{
#line 2086
    int err=NC_NOERR;
#line 2086
    ix_int64 xx = NC_FILL_INT64;
#line 2086

#line 2086
#if IX_INT64_MAX < UINT_MAX
#line 2086
    if (*ip > IX_INT64_MAX) {
#line 2086
        
#line 2086
        err = NC_ERANGE;
#line 2086
    } 
#line 2086
#endif
#line 2086
        xx = (ix_int64)*ip;
#line 2086

#line 2086
    put_ix_int64(xp, &xx);
#line 2086
    return err;
#line 2086
}
#line 2086

static int
#line 2087
ncx_put_longlong_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 2087
{
#line 2087
    int err=NC_NOERR;
#line 2087
    ix_int64 xx = NC_FILL_INT64;
#line 2087

#line 2087
#if IX_INT64_MAX < ULONGLONG_MAX
#line 2087
    if (*ip > IX_INT64_MAX) {
#line 2087
        
#line 2087
        err = NC_ERANGE;
#line 2087
    } 
#line 2087
#endif
#line 2087
        xx = (ix_int64)*ip;
#line 2087

#line 2087
    put_ix_int64(xp, &xx);
#line 2087
    return err;
#line 2087
}
#line 2087

static int
#line 2088
ncx_put_longlong_float(void *xp, const float *ip, void *fillp)
#line 2088
{
#line 2088
    int err=NC_NOERR;
#line 2088
    ix_int64 xx = NC_FILL_INT64;
#line 2088

#line 2088
    if (*ip > (double)X_INT64_MAX || *ip < (double)X_INT64_MIN) {
#line 2088
        
#line 2088
        err = NC_ERANGE;
#line 2088
    } 
#line 2088
        xx = (ix_int64)*ip;
#line 2088

#line 2088
    put_ix_int64(xp, &xx);
#line 2088
    return err;
#line 2088
}
#line 2088

static int
#line 2089
ncx_put_longlong_double(void *xp, const double *ip, void *fillp)
#line 2089
{
#line 2089
    int err=NC_NOERR;
#line 2089
    ix_int64 xx = NC_FILL_INT64;
#line 2089

#line 2089
    if (*ip > X_INT64_MAX || *ip < X_INT64_MIN) {
#line 2089
        
#line 2089
        err = NC_ERANGE;
#line 2089
    } 
#line 2089
        xx = (ix_int64)*ip;
#line 2089

#line 2089
    put_ix_int64(xp, &xx);
#line 2089
    return err;
#line 2089
}
#line 2089



/* external NC_UINT64 -------------------------------------------------------*/

#if USHORT_MAX == X_UINT64_MAX
typedef ushort ix_uint64;
#define SIZEOF_IX_UINT64 SIZEOF_USHORT
#define IX_UINT64_MAX USHORT_MAX
#elif ULONG_LONG_MAX  >= X_UINT64_MAX
typedef ulonglong ix_uint64;
#define SIZEOF_IX_UINT64 SIZEOF_ULONGLONG
#define IX_UINT64_MAX ULONG_LONG_MAX
#elif ULONG_MAX  >= X_UINT64_MAX
typedef ulong ix_uint64;
#define SIZEOF_IX_UINT64 SIZEOF_ULONG
#define IX_UINT64_MAX ULONG_MAX
#else
#error "ix_uint64 implementation"
#endif


static void
get_ix_uint64(const void *xp, ix_uint64 *ip)
{
    const uchar *cp = (const uchar *) xp;

    *ip  = ((ix_uint64)(*cp++) << 56);
    *ip |= ((ix_uint64)(*cp++) << 48);
    *ip |= ((ix_uint64)(*cp++) << 40);
    *ip |= ((ix_uint64)(*cp++) << 32);
    *ip |= ((ix_uint64)(*cp++) << 24);
    *ip |= ((ix_uint64)(*cp++) << 16);
    *ip |= ((ix_uint64)(*cp++) <<  8);
    *ip |=  (ix_uint64)*cp;
}

static void
put_ix_uint64(void *xp, const ix_uint64 *ip)
{
    uchar *cp = (uchar *) xp;

    *cp++ = (uchar)((*ip) >> 56);
    *cp++ = (uchar)(((*ip) & 0x00ff000000000000ULL) >> 48);
    *cp++ = (uchar)(((*ip) & 0x0000ff0000000000ULL) >> 40);
    *cp++ = (uchar)(((*ip) & 0x000000ff00000000ULL) >> 32);
    *cp++ = (uchar)(((*ip) & 0x00000000ff000000ULL) >> 24);
    *cp++ = (uchar)(((*ip) & 0x0000000000ff0000ULL) >> 16);
    *cp++ = (uchar)(((*ip) & 0x000000000000ff00ULL) >>  8);
    *cp   = (uchar)( (*ip) & 0x00000000000000ffULL);
}

#if X_SIZEOF_UINT64 != SIZEOF_ULONGLONG
static int
#line 2142
ncx_get_ulonglong_ulonglong(const void *xp, ulonglong *ip)
#line 2142
{
#line 2142
    int err=NC_NOERR;
#line 2142
#if SIZEOF_IX_UINT64 == SIZEOF_ULONGLONG && IX_UINT64_MAX == ULONGLONG_MAX
#line 2142
    get_ix_uint64(xp, (ix_uint64 *)ip);
#line 2142
#else
#line 2142
    ix_uint64 xx;
#line 2142
    get_ix_uint64(xp, &xx);
#line 2142

#line 2142
#if IX_UINT64_MAX > ULONGLONG_MAX
#line 2142
    if (xx > ULONGLONG_MAX) {
#line 2142

#line 2142
        err = NC_ERANGE;
#line 2142
    }
#line 2142
#endif
#line 2142

#line 2142

#line 2142
    *ip = (ulonglong) xx;
#line 2142
#endif
#line 2142
    return err;
#line 2142
}
#line 2142

#endif
static int
#line 2144
ncx_get_ulonglong_schar(const void *xp, schar *ip)
#line 2144
{
#line 2144
    int err=NC_NOERR;
#line 2144
    ix_uint64 xx;
#line 2144
    get_ix_uint64(xp, &xx);
#line 2144

#line 2144
#if IX_UINT64_MAX > SCHAR_MAX
#line 2144
    if (xx > SCHAR_MAX) {
#line 2144

#line 2144
        err = NC_ERANGE;
#line 2144
    }
#line 2144
#endif
#line 2144

#line 2144

#line 2144
    *ip = (schar) xx;
#line 2144
    return err;
#line 2144
}
#line 2144

static int
#line 2145
ncx_get_ulonglong_short(const void *xp, short *ip)
#line 2145
{
#line 2145
    int err=NC_NOERR;
#line 2145
    ix_uint64 xx;
#line 2145
    get_ix_uint64(xp, &xx);
#line 2145

#line 2145
#if IX_UINT64_MAX > SHORT_MAX
#line 2145
    if (xx > SHORT_MAX) {
#line 2145

#line 2145
        err = NC_ERANGE;
#line 2145
    }
#line 2145
#endif
#line 2145

#line 2145

#line 2145
    *ip = (short) xx;
#line 2145
    return err;
#line 2145
}
#line 2145

static int
#line 2146
ncx_get_ulonglong_int(const void *xp, int *ip)
#line 2146
{
#line 2146
    int err=NC_NOERR;
#line 2146
    ix_uint64 xx;
#line 2146
    get_ix_uint64(xp, &xx);
#line 2146

#line 2146
#if IX_UINT64_MAX > INT_MAX
#line 2146
    if (xx > INT_MAX) {
#line 2146

#line 2146
        err = NC_ERANGE;
#line 2146
    }
#line 2146
#endif
#line 2146

#line 2146

#line 2146
    *ip = (int) xx;
#line 2146
    return err;
#line 2146
}
#line 2146

static int
#line 2147
ncx_get_ulonglong_long(const void *xp, long *ip)
#line 2147
{
#line 2147
    int err=NC_NOERR;
#line 2147
    ix_uint64 xx;
#line 2147
    get_ix_uint64(xp, &xx);
#line 2147

#line 2147
#if IX_UINT64_MAX > LONG_MAX
#line 2147
    if (xx > LONG_MAX) {
#line 2147

#line 2147
        err = NC_ERANGE;
#line 2147
    }
#line 2147
#endif
#line 2147

#line 2147

#line 2147
    *ip = (long) xx;
#line 2147
    return err;
#line 2147
}
#line 2147

static int
#line 2148
ncx_get_ulonglong_longlong(const void *xp, longlong *ip)
#line 2148
{
#line 2148
    int err=NC_NOERR;
#line 2148
    ix_uint64 xx;
#line 2148
    get_ix_uint64(xp, &xx);
#line 2148

#line 2148
#if IX_UINT64_MAX > LONGLONG_MAX
#line 2148
    if (xx > LONGLONG_MAX) {
#line 2148

#line 2148
        err = NC_ERANGE;
#line 2148
    }
#line 2148
#endif
#line 2148

#line 2148

#line 2148
    *ip = (longlong) xx;
#line 2148
    return err;
#line 2148
}
#line 2148

static int
#line 2149
ncx_get_ulonglong_ushort(const void *xp, ushort *ip)
#line 2149
{
#line 2149
    int err=NC_NOERR;
#line 2149
#if SIZEOF_IX_UINT64 == SIZEOF_USHORT && IX_UINT64_MAX == USHORT_MAX
#line 2149
    get_ix_uint64(xp, (ix_uint64 *)ip);
#line 2149
#else
#line 2149
    ix_uint64 xx;
#line 2149
    get_ix_uint64(xp, &xx);
#line 2149

#line 2149
#if IX_UINT64_MAX > USHORT_MAX
#line 2149
    if (xx > USHORT_MAX) {
#line 2149

#line 2149
        err = NC_ERANGE;
#line 2149
    }
#line 2149
#endif
#line 2149

#line 2149

#line 2149
    *ip = (ushort) xx;
#line 2149
#endif
#line 2149
    return err;
#line 2149
}
#line 2149

static int
#line 2150
ncx_get_ulonglong_uchar(const void *xp, uchar *ip)
#line 2150
{
#line 2150
    int err=NC_NOERR;
#line 2150
#if SIZEOF_IX_UINT64 == SIZEOF_UCHAR && IX_UINT64_MAX == UCHAR_MAX
#line 2150
    get_ix_uint64(xp, (ix_uint64 *)ip);
#line 2150
#else
#line 2150
    ix_uint64 xx;
#line 2150
    get_ix_uint64(xp, &xx);
#line 2150

#line 2150
#if IX_UINT64_MAX > UCHAR_MAX
#line 2150
    if (xx > UCHAR_MAX) {
#line 2150

#line 2150
        err = NC_ERANGE;
#line 2150
    }
#line 2150
#endif
#line 2150

#line 2150

#line 2150
    *ip = (uchar) xx;
#line 2150
#endif
#line 2150
    return err;
#line 2150
}
#line 2150

static int
#line 2151
ncx_get_ulonglong_uint(const void *xp, uint *ip)
#line 2151
{
#line 2151
    int err=NC_NOERR;
#line 2151
#if SIZEOF_IX_UINT64 == SIZEOF_UINT && IX_UINT64_MAX == UINT_MAX
#line 2151
    get_ix_uint64(xp, (ix_uint64 *)ip);
#line 2151
#else
#line 2151
    ix_uint64 xx;
#line 2151
    get_ix_uint64(xp, &xx);
#line 2151

#line 2151
#if IX_UINT64_MAX > UINT_MAX
#line 2151
    if (xx > UINT_MAX) {
#line 2151

#line 2151
        err = NC_ERANGE;
#line 2151
    }
#line 2151
#endif
#line 2151

#line 2151

#line 2151
    *ip = (uint) xx;
#line 2151
#endif
#line 2151
    return err;
#line 2151
}
#line 2151

static int
#line 2152
ncx_get_ulonglong_float(const void *xp, float *ip)
#line 2152
{
#line 2152
	ix_uint64 xx;
#line 2152
	get_ix_uint64(xp, &xx);
#line 2152
	*ip = (float)xx;
#line 2152
	return NC_NOERR;
#line 2152
}
#line 2152

static int
#line 2153
ncx_get_ulonglong_double(const void *xp, double *ip)
#line 2153
{
#line 2153
	ix_uint64 xx;
#line 2153
	get_ix_uint64(xp, &xx);
#line 2153
	*ip = (double)xx;
#line 2153
	return NC_NOERR;
#line 2153
}
#line 2153


#if X_SIZEOF_UINT64 != SIZEOF_ULONGLONG
static int
#line 2156
ncx_put_ulonglong_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 2156
{
#line 2156
    int err=NC_NOERR;
#line 2156
#if SIZEOF_IX_UINT64 == SIZEOF_ULONGLONG && IX_UINT64_MAX == ULONGLONG_MAX
#line 2156
    put_ix_uint64(xp, (const ix_uint64 *)ip);
#line 2156
#else
#line 2156
    ix_uint64 xx = NC_FILL_UINT64;
#line 2156

#line 2156
#if IX_UINT64_MAX < ULONGLONG_MAX
#line 2156
    if (*ip > IX_UINT64_MAX) {
#line 2156
        
#line 2156
        err = NC_ERANGE;
#line 2156
    } 
#line 2156
#endif
#line 2156
        xx = (ix_uint64)*ip;
#line 2156

#line 2156
    put_ix_uint64(xp, &xx);
#line 2156
#endif
#line 2156
    return err;
#line 2156
}
#line 2156

#endif
static int
#line 2158
ncx_put_ulonglong_schar(void *xp, const schar *ip, void *fillp)
#line 2158
{
#line 2158
    int err=NC_NOERR;
#line 2158
    ix_uint64 xx = NC_FILL_UINT64;
#line 2158

#line 2158
#if IX_UINT64_MAX < SCHAR_MAX
#line 2158
    if (*ip > IX_UINT64_MAX) {
#line 2158
        
#line 2158
        err = NC_ERANGE;
#line 2158
    } 
#line 2158
#endif
#line 2158
    if (*ip < 0) {
#line 2158
        
#line 2158
        err = NC_ERANGE; /* because xp is unsigned */
#line 2158
    } 
#line 2158
        xx = (ix_uint64)*ip;
#line 2158

#line 2158
    put_ix_uint64(xp, &xx);
#line 2158
    return err;
#line 2158
}
#line 2158

static int
#line 2159
ncx_put_ulonglong_short(void *xp, const short *ip, void *fillp)
#line 2159
{
#line 2159
    int err=NC_NOERR;
#line 2159
    ix_uint64 xx = NC_FILL_UINT64;
#line 2159

#line 2159
#if IX_UINT64_MAX < SHORT_MAX
#line 2159
    if (*ip > IX_UINT64_MAX) {
#line 2159
        
#line 2159
        err = NC_ERANGE;
#line 2159
    } 
#line 2159
#endif
#line 2159
    if (*ip < 0) {
#line 2159
        
#line 2159
        err = NC_ERANGE; /* because xp is unsigned */
#line 2159
    } 
#line 2159
        xx = (ix_uint64)*ip;
#line 2159

#line 2159
    put_ix_uint64(xp, &xx);
#line 2159
    return err;
#line 2159
}
#line 2159

static int
#line 2160
ncx_put_ulonglong_int(void *xp, const int *ip, void *fillp)
#line 2160
{
#line 2160
    int err=NC_NOERR;
#line 2160
    ix_uint64 xx = NC_FILL_UINT64;
#line 2160

#line 2160
#if IX_UINT64_MAX < INT_MAX
#line 2160
    if (*ip > IX_UINT64_MAX) {
#line 2160
        
#line 2160
        err = NC_ERANGE;
#line 2160
    } 
#line 2160
#endif
#line 2160
    if (*ip < 0) {
#line 2160
        
#line 2160
        err = NC_ERANGE; /* because xp is unsigned */
#line 2160
    } 
#line 2160
        xx = (ix_uint64)*ip;
#line 2160

#line 2160
    put_ix_uint64(xp, &xx);
#line 2160
    return err;
#line 2160
}
#line 2160

static int
#line 2161
ncx_put_ulonglong_long(void *xp, const long *ip, void *fillp)
#line 2161
{
#line 2161
    int err=NC_NOERR;
#line 2161
    ix_uint64 xx = NC_FILL_UINT64;
#line 2161

#line 2161
#if IX_UINT64_MAX < LONG_MAX
#line 2161
    if (*ip > IX_UINT64_MAX) {
#line 2161
        
#line 2161
        err = NC_ERANGE;
#line 2161
    } 
#line 2161
#endif
#line 2161
    if (*ip < 0) {
#line 2161
        
#line 2161
        err = NC_ERANGE; /* because xp is unsigned */
#line 2161
    } 
#line 2161
        xx = (ix_uint64)*ip;
#line 2161

#line 2161
    put_ix_uint64(xp, &xx);
#line 2161
    return err;
#line 2161
}
#line 2161

static int
#line 2162
ncx_put_ulonglong_longlong(void *xp, const longlong *ip, void *fillp)
#line 2162
{
#line 2162
    int err=NC_NOERR;
#line 2162
    ix_uint64 xx = NC_FILL_UINT64;
#line 2162

#line 2162
#if IX_UINT64_MAX < LONGLONG_MAX
#line 2162
    if (*ip > IX_UINT64_MAX) {
#line 2162
        
#line 2162
        err = NC_ERANGE;
#line 2162
    } 
#line 2162
#endif
#line 2162
    if (*ip < 0) {
#line 2162
        
#line 2162
        err = NC_ERANGE; /* because xp is unsigned */
#line 2162
    } 
#line 2162
        xx = (ix_uint64)*ip;
#line 2162

#line 2162
    put_ix_uint64(xp, &xx);
#line 2162
    return err;
#line 2162
}
#line 2162

static int
#line 2163
ncx_put_ulonglong_uchar(void *xp, const uchar *ip, void *fillp)
#line 2163
{
#line 2163
    int err=NC_NOERR;
#line 2163
#if SIZEOF_IX_UINT64 == SIZEOF_UCHAR && IX_UINT64_MAX == UCHAR_MAX
#line 2163
    put_ix_uint64(xp, (const ix_uint64 *)ip);
#line 2163
#else
#line 2163
    ix_uint64 xx = NC_FILL_UINT64;
#line 2163

#line 2163
#if IX_UINT64_MAX < UCHAR_MAX
#line 2163
    if (*ip > IX_UINT64_MAX) {
#line 2163
        
#line 2163
        err = NC_ERANGE;
#line 2163
    } 
#line 2163
#endif
#line 2163
        xx = (ix_uint64)*ip;
#line 2163

#line 2163
    put_ix_uint64(xp, &xx);
#line 2163
#endif
#line 2163
    return err;
#line 2163
}
#line 2163

static int
#line 2164
ncx_put_ulonglong_ushort(void *xp, const ushort *ip, void *fillp)
#line 2164
{
#line 2164
    int err=NC_NOERR;
#line 2164
#if SIZEOF_IX_UINT64 == SIZEOF_USHORT && IX_UINT64_MAX == USHORT_MAX
#line 2164
    put_ix_uint64(xp, (const ix_uint64 *)ip);
#line 2164
#else
#line 2164
    ix_uint64 xx = NC_FILL_UINT64;
#line 2164

#line 2164
#if IX_UINT64_MAX < USHORT_MAX
#line 2164
    if (*ip > IX_UINT64_MAX) {
#line 2164
        
#line 2164
        err = NC_ERANGE;
#line 2164
    } 
#line 2164
#endif
#line 2164
        xx = (ix_uint64)*ip;
#line 2164

#line 2164
    put_ix_uint64(xp, &xx);
#line 2164
#endif
#line 2164
    return err;
#line 2164
}
#line 2164

static int
#line 2165
ncx_put_ulonglong_uint(void *xp, const uint *ip, void *fillp)
#line 2165
{
#line 2165
    int err=NC_NOERR;
#line 2165
#if SIZEOF_IX_UINT64 == SIZEOF_UINT && IX_UINT64_MAX == UINT_MAX
#line 2165
    put_ix_uint64(xp, (const ix_uint64 *)ip);
#line 2165
#else
#line 2165
    ix_uint64 xx = NC_FILL_UINT64;
#line 2165

#line 2165
#if IX_UINT64_MAX < UINT_MAX
#line 2165
    if (*ip > IX_UINT64_MAX) {
#line 2165
        
#line 2165
        err = NC_ERANGE;
#line 2165
    } 
#line 2165
#endif
#line 2165
        xx = (ix_uint64)*ip;
#line 2165

#line 2165
    put_ix_uint64(xp, &xx);
#line 2165
#endif
#line 2165
    return err;
#line 2165
}
#line 2165

static int
#line 2166
ncx_put_ulonglong_float(void *xp, const float *ip, void *fillp)
#line 2166
{
#line 2166
    int err=NC_NOERR;
#line 2166
    ix_uint64 xx = NC_FILL_UINT64;
#line 2166

#line 2166
    if (*ip > (double)X_UINT64_MAX || *ip < 0) {
#line 2166
        
#line 2166
        err = NC_ERANGE;
#line 2166
    } 
#line 2166
        xx = (ix_uint64)*ip;
#line 2166

#line 2166
    put_ix_uint64(xp, &xx);
#line 2166
    return err;
#line 2166
}
#line 2166

static int
#line 2167
ncx_put_ulonglong_double(void *xp, const double *ip, void *fillp)
#line 2167
{
#line 2167
    int err=NC_NOERR;
#line 2167
    ix_uint64 xx = NC_FILL_UINT64;
#line 2167

#line 2167
    if (*ip > X_UINT64_MAX || *ip < 0) {
#line 2167
        
#line 2167
        err = NC_ERANGE;
#line 2167
    } 
#line 2167
        xx = (ix_uint64)*ip;
#line 2167

#line 2167
    put_ix_uint64(xp, &xx);
#line 2167
    return err;
#line 2167
}
#line 2167



/* x_size_t */

#if SIZEOF_SIZE_T < X_SIZEOF_SIZE_T
#error "x_size_t implementation"
/* netcdf requires size_t which can hold a values from 0 to 2^32 -1 */
#endif

int
ncx_put_size_t(void **xpp, const size_t *ulp)
{
	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;
	assert(*ulp <= X_SIZE_MAX);

	*cp++ = (uchar)((*ulp) >> 24);
	*cp++ = (uchar)(((*ulp) & 0x00ff0000) >> 16);
	*cp++ = (uchar)(((*ulp) & 0x0000ff00) >>  8);
	*cp   = (uchar)((*ulp) & 0x000000ff);

	*xpp = (void *)((char *)(*xpp) + X_SIZEOF_SIZE_T);
	return NC_NOERR;
}

int
ncx_get_size_t(const void **xpp,  size_t *ulp)
{
	/* similar to get_ix_int */
	const uchar *cp = (const uchar *) *xpp;

	*ulp  = (unsigned)(*cp++ << 24);
	*ulp |= (*cp++ << 16);
	*ulp |= (*cp++ << 8);
	*ulp |= *cp;

	*xpp = (const void *)((const char *)(*xpp) + X_SIZEOF_SIZE_T);
	return NC_NOERR;
}

/* x_off_t */

int
ncx_put_off_t(void **xpp, const off_t *lp, size_t sizeof_off_t)
{
	/* No negative offsets stored in netcdf */
	if (*lp < 0) {
	  /* Assume this is an overflow of a 32-bit int... */
	  return NC_ERANGE;
	}

	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;

	if (sizeof_off_t == 4) {
		*cp++ = (uchar) ((*lp)               >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
	} else {
#if SIZEOF_OFF_T == 4
/* Write a 64-bit offset on a system with only a 32-bit offset */
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;

		*cp++ = (uchar)(((*lp) & 0xff000000) >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
#else
		*cp++ = (uchar) ((*lp)                          >> 56);
		*cp++ = (uchar)(((*lp) & 0x00ff000000000000LL) >> 48);
		*cp++ = (uchar)(((*lp) & 0x0000ff0000000000LL) >> 40);
		*cp++ = (uchar)(((*lp) & 0x000000ff00000000LL) >> 32);
		*cp++ = (uchar)(((*lp) & 0x00000000ff000000LL) >> 24);
		*cp++ = (uchar)(((*lp) & 0x0000000000ff0000LL) >> 16);
		*cp++ = (uchar)(((*lp) & 0x000000000000ff00LL) >>  8);
		*cp   = (uchar)( (*lp) & 0x00000000000000ffLL);
#endif
	}
	*xpp = (void *)((char *)(*xpp) + sizeof_off_t);
	return NC_NOERR;
}

int
ncx_get_off_t(const void **xpp, off_t *lp, size_t sizeof_off_t)
{
	/* similar to get_ix_int() */
	const uchar *cp = (const uchar *) *xpp;
	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

 	if (sizeof_off_t == 4) {
		*lp =  (off_t)(*cp++ << 24);
		*lp |= (off_t)(*cp++ << 16);
		*lp |= (off_t)(*cp++ <<  8);
		*lp |= (off_t)*cp;
	} else {
#if SIZEOF_OFF_T == 4
/* Read a 64-bit offset on a system with only a 32-bit offset */
/* If the offset overflows, set an error code and return */
		*lp =  ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |= ((off_t)(*cp++));
/*
 * lp now contains the upper 32-bits of the 64-bit offset.  if lp is
 * not zero, then the dataset is larger than can be represented
 * on this system.  Set an error code and return.
 */
		if (*lp != 0) {
		  return NC_ERANGE;
		}

		*lp  = ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;

		if (*lp < 0) {
		  /*
		   * If this fails, then the offset is >2^31, but less
		   * than 2^32 which is not allowed, but is not caught
		   * by the previous check
		   */
		  return NC_ERANGE;
		}
#else
		*lp =  ((off_t)(*cp++) << 56);
		*lp |= ((off_t)(*cp++) << 48);
		*lp |= ((off_t)(*cp++) << 40);
		*lp |= ((off_t)(*cp++) << 32);
		*lp |= ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;
#endif
	}
	*xpp = (const void *)((const char *)(*xpp) + sizeof_off_t);
	return NC_NOERR;
}

/*----< ncx_get_uint32() >------------------------------------------*/
int
ncx_get_uint32(const void **xpp, uint *ip)
{
#ifdef WORDS_BIGENDIAN
    /* use memcpy instead of assignment to avoid BUS_ADRALN alignment error on
     * some system, such as HPUX */
    (void) memcpy(ip, *xpp, SIZEOF_UINT);
#else
    const uchar *cp = (const uchar *) *xpp;

    *ip = (uint)(*cp++ << 24);
    *ip = (uint)(*ip | (uint)(*cp++ << 16));
    *ip = (uint)(*ip | (uint)(*cp++ <<  8));
    *ip = (uint)(*ip | *cp);
#endif
    /* advance *xpp 4 bytes */
    *xpp = (void *)((const char *)(*xpp) + 4);

    return NC_NOERR;
}

/*----< ncx_get_uint64() >------------------------------------------*/
int
ncx_get_uint64(const void **xpp, unsigned long long *ullp)
{
#ifdef WORDS_BIGENDIAN
    /* use memcpy instead of assignment to avoid BUS_ADRALN alignment error on
     * some system, such as HPUX */
    (void) memcpy(ullp, *xpp, SIZEOF_UINT64);
#else
    const uchar *cp = (const uchar *) *xpp;

    /* below is the same as calling swap8b(ullp, *xpp) */
    *ullp = (unsigned long long)(*cp++) << 56;
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) << 48);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) << 40);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) << 32);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) << 24);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) << 16);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) <<  8);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp));
#endif
    /* advance *xpp 8 bytes */
    *xpp = (void *)((const char *)(*xpp) + 8);

    return NC_NOERR;
}

/*---< ncx_put_uint32() >-------------------------------------------*/
/* copy the contents of ip (an unsigned 32-bit integer) to xpp in Big Endian
 * form and advance *xpp 4 bytes
 */
int
ncx_put_uint32(void **xpp, const unsigned int ip)
{
#ifdef WORDS_BIGENDIAN
    /* use memcpy instead of assignment to avoid BUS_ADRALN alignment error on
     * some system, such as HPUX */
    (void) memcpy(*xpp, &ip, X_SIZEOF_UINT);
#else
    /* bitwise shifts below are to produce an integer in Big Endian */
    uchar *cp = (uchar *) *xpp;
    *cp++ = (uchar)((ip & 0xff000000) >> 24);
    *cp++ = (uchar)((ip & 0x00ff0000) >> 16);
    *cp++ = (uchar)((ip & 0x0000ff00) >>  8);
    *cp   = (uchar)( ip & 0x000000ff);
#endif
    /* advance *xpp 4 bytes */
    *xpp  = (void *)((char *)(*xpp) + 4);

    return NC_NOERR;
}

/*---< ncx_put_uint64() >-------------------------------------------*/
/* copy the contents of ip (an unsigned 64-bit integer) to xpp in Big Endian
 * form and advance *xpp 8 bytes
 */
int
ncx_put_uint64(void **xpp, const unsigned long long ip)
{
#ifdef WORDS_BIGENDIAN
    /* use memcpy instead of assignment to avoid BUS_ADRALN alignment error on
     * some system, such as HPUX */
    (void) memcpy(*xpp, &ip, X_SIZEOF_UINT64);
#else
    uchar *cp = (uchar *) *xpp;
    /* below is the same as calling swap8b(*xpp, &ip) */
    *cp++ = (uchar) (ip                         >> 56);
    *cp++ = (uchar)((ip & 0x00ff000000000000LL) >> 48);
    *cp++ = (uchar)((ip & 0x0000ff0000000000LL) >> 40);
    *cp++ = (uchar)((ip & 0x000000ff00000000LL) >> 32);
    *cp++ = (uchar)((ip & 0x00000000ff000000LL) >> 24);
    *cp++ = (uchar)((ip & 0x0000000000ff0000LL) >> 16);
    *cp++ = (uchar)((ip & 0x000000000000ff00LL) >>  8);
    *cp   = (uchar) (ip & 0x00000000000000ffLL);
#endif
    /* advance *xpp 8 bytes */
    *xpp  = (void *)((char *)(*xpp) + 8);

    return NC_NOERR;
}


/*
 * Aggregate numeric conversion functions.
 */
#line 2423

#line 2822

#line 2828

/* schar ---------------------------------------------------------------------*/

#line 2832
int
ncx_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, (size_t)nelems);
#line 2835
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2835
	return NC_NOERR;
#line 2835

}
int
#line 2837
ncx_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2837
{
#line 2837
    int status = NC_NOERR;
#line 2837
    schar *xp = (schar *)(*xpp);
#line 2837

#line 2837
    while (nelems-- != 0) {
#line 2837
        
#line 2837
        if (*xp < 0) {
#line 2837
            
#line 2837
            status = NC_ERANGE; /* because tp is unsigned */
#line 2837
            
#line 2837
        }
#line 2837
        *tp++ = (uchar) (signed) (*xp++);  /* type cast from schar to uchar */
#line 2837
    }
#line 2837

#line 2837
    *xpp = (const void *)xp;
#line 2837
    return status;
#line 2837
}
#line 2837

int
#line 2838
ncx_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2838
{
#line 2838
    int status = NC_NOERR;
#line 2838
    schar *xp = (schar *)(*xpp);
#line 2838

#line 2838
    while (nelems-- != 0) {
#line 2838
        
#line 2838
        *tp++ = (short)  (*xp++);  /* type cast from schar to short */
#line 2838
    }
#line 2838

#line 2838
    *xpp = (const void *)xp;
#line 2838
    return status;
#line 2838
}
#line 2838

int
#line 2839
ncx_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2839
{
#line 2839
    int status = NC_NOERR;
#line 2839
    schar *xp = (schar *)(*xpp);
#line 2839

#line 2839
    while (nelems-- != 0) {
#line 2839
        
#line 2839
        *tp++ = (int)  (*xp++);  /* type cast from schar to int */
#line 2839
    }
#line 2839

#line 2839
    *xpp = (const void *)xp;
#line 2839
    return status;
#line 2839
}
#line 2839

int
#line 2840
ncx_getn_schar_long(const void **xpp, size_t nelems, long *tp)
#line 2840
{
#line 2840
    int status = NC_NOERR;
#line 2840
    schar *xp = (schar *)(*xpp);
#line 2840

#line 2840
    while (nelems-- != 0) {
#line 2840
        
#line 2840
        *tp++ = (long)  (*xp++);  /* type cast from schar to long */
#line 2840
    }
#line 2840

#line 2840
    *xpp = (const void *)xp;
#line 2840
    return status;
#line 2840
}
#line 2840

int
#line 2841
ncx_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2841
{
#line 2841
    int status = NC_NOERR;
#line 2841
    schar *xp = (schar *)(*xpp);
#line 2841

#line 2841
    while (nelems-- != 0) {
#line 2841
        
#line 2841
        *tp++ = (float)  (*xp++);  /* type cast from schar to float */
#line 2841
    }
#line 2841

#line 2841
    *xpp = (const void *)xp;
#line 2841
    return status;
#line 2841
}
#line 2841

int
#line 2842
ncx_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2842
{
#line 2842
    int status = NC_NOERR;
#line 2842
    schar *xp = (schar *)(*xpp);
#line 2842

#line 2842
    while (nelems-- != 0) {
#line 2842
        
#line 2842
        *tp++ = (double)  (*xp++);  /* type cast from schar to double */
#line 2842
    }
#line 2842

#line 2842
    *xpp = (const void *)xp;
#line 2842
    return status;
#line 2842
}
#line 2842

int
#line 2843
ncx_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2843
{
#line 2843
    int status = NC_NOERR;
#line 2843
    schar *xp = (schar *)(*xpp);
#line 2843

#line 2843
    while (nelems-- != 0) {
#line 2843
        
#line 2843
        *tp++ = (longlong)  (*xp++);  /* type cast from schar to longlong */
#line 2843
    }
#line 2843

#line 2843
    *xpp = (const void *)xp;
#line 2843
    return status;
#line 2843
}
#line 2843

int
#line 2844
ncx_getn_schar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2844
{
#line 2844
    int status = NC_NOERR;
#line 2844
    schar *xp = (schar *)(*xpp);
#line 2844

#line 2844
    while (nelems-- != 0) {
#line 2844
        
#line 2844
        if (*xp < 0) {
#line 2844
            
#line 2844
            status = NC_ERANGE; /* because tp is unsigned */
#line 2844
            
#line 2844
        }
#line 2844
        *tp++ = (ushort) (signed) (*xp++);  /* type cast from schar to ushort */
#line 2844
    }
#line 2844

#line 2844
    *xpp = (const void *)xp;
#line 2844
    return status;
#line 2844
}
#line 2844

int
#line 2845
ncx_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2845
{
#line 2845
    int status = NC_NOERR;
#line 2845
    schar *xp = (schar *)(*xpp);
#line 2845

#line 2845
    while (nelems-- != 0) {
#line 2845
        
#line 2845
        if (*xp < 0) {
#line 2845
            
#line 2845
            status = NC_ERANGE; /* because tp is unsigned */
#line 2845
            
#line 2845
        }
#line 2845
        *tp++ = (uint) (signed) (*xp++);  /* type cast from schar to uint */
#line 2845
    }
#line 2845

#line 2845
    *xpp = (const void *)xp;
#line 2845
    return status;
#line 2845
}
#line 2845

int
#line 2846
ncx_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2846
{
#line 2846
    int status = NC_NOERR;
#line 2846
    schar *xp = (schar *)(*xpp);
#line 2846

#line 2846
    while (nelems-- != 0) {
#line 2846
        
#line 2846
        if (*xp < 0) {
#line 2846
            
#line 2846
            status = NC_ERANGE; /* because tp is unsigned */
#line 2846
            
#line 2846
        }
#line 2846
        *tp++ = (ulonglong) (signed) (*xp++);  /* type cast from schar to ulonglong */
#line 2846
    }
#line 2846

#line 2846
    *xpp = (const void *)xp;
#line 2846
    return status;
#line 2846
}
#line 2846


#line 2849
int
ncx_pad_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2852

#line 2852
	if (rndup)
#line 2852
		rndup = X_ALIGN - rndup;
#line 2852

#line 2852
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 2852
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2852

#line 2852
	return NC_NOERR;
#line 2852

}
int
#line 2854
ncx_pad_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2854
{
#line 2854
    int status = NC_NOERR;
#line 2854
    size_t rndup = nelems % X_ALIGN;
#line 2854
    schar *xp = (schar *) *xpp;
#line 2854

#line 2854
    if (rndup)
#line 2854
        rndup = X_ALIGN - rndup;
#line 2854

#line 2854
    while (nelems-- != 0) {
#line 2854
        
#line 2854
        if (*xp < 0) {
#line 2854
            
#line 2854
            status = NC_ERANGE; /* because tp is unsigned */
#line 2854
            
#line 2854
        }
#line 2854
        *tp++ = (uchar) (signed) (*xp++);  /* type cast from schar to uchar */
#line 2854
    }
#line 2854

#line 2854
    *xpp = (void *)(xp + rndup);
#line 2854
    return status;
#line 2854
}
#line 2854

int
#line 2855
ncx_pad_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2855
{
#line 2855
    int status = NC_NOERR;
#line 2855
    size_t rndup = nelems % X_ALIGN;
#line 2855
    schar *xp = (schar *) *xpp;
#line 2855

#line 2855
    if (rndup)
#line 2855
        rndup = X_ALIGN - rndup;
#line 2855

#line 2855
    while (nelems-- != 0) {
#line 2855
        
#line 2855
        *tp++ = (short)  (*xp++);  /* type cast from schar to short */
#line 2855
    }
#line 2855

#line 2855
    *xpp = (void *)(xp + rndup);
#line 2855
    return status;
#line 2855
}
#line 2855

int
#line 2856
ncx_pad_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2856
{
#line 2856
    int status = NC_NOERR;
#line 2856
    size_t rndup = nelems % X_ALIGN;
#line 2856
    schar *xp = (schar *) *xpp;
#line 2856

#line 2856
    if (rndup)
#line 2856
        rndup = X_ALIGN - rndup;
#line 2856

#line 2856
    while (nelems-- != 0) {
#line 2856
        
#line 2856
        *tp++ = (int)  (*xp++);  /* type cast from schar to int */
#line 2856
    }
#line 2856

#line 2856
    *xpp = (void *)(xp + rndup);
#line 2856
    return status;
#line 2856
}
#line 2856

int
#line 2857
ncx_pad_getn_schar_long(const void **xpp, size_t nelems, long *tp)
#line 2857
{
#line 2857
    int status = NC_NOERR;
#line 2857
    size_t rndup = nelems % X_ALIGN;
#line 2857
    schar *xp = (schar *) *xpp;
#line 2857

#line 2857
    if (rndup)
#line 2857
        rndup = X_ALIGN - rndup;
#line 2857

#line 2857
    while (nelems-- != 0) {
#line 2857
        
#line 2857
        *tp++ = (long)  (*xp++);  /* type cast from schar to long */
#line 2857
    }
#line 2857

#line 2857
    *xpp = (void *)(xp + rndup);
#line 2857
    return status;
#line 2857
}
#line 2857

int
#line 2858
ncx_pad_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2858
{
#line 2858
    int status = NC_NOERR;
#line 2858
    size_t rndup = nelems % X_ALIGN;
#line 2858
    schar *xp = (schar *) *xpp;
#line 2858

#line 2858
    if (rndup)
#line 2858
        rndup = X_ALIGN - rndup;
#line 2858

#line 2858
    while (nelems-- != 0) {
#line 2858
        
#line 2858
        *tp++ = (float)  (*xp++);  /* type cast from schar to float */
#line 2858
    }
#line 2858

#line 2858
    *xpp = (void *)(xp + rndup);
#line 2858
    return status;
#line 2858
}
#line 2858

int
#line 2859
ncx_pad_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2859
{
#line 2859
    int status = NC_NOERR;
#line 2859
    size_t rndup = nelems % X_ALIGN;
#line 2859
    schar *xp = (schar *) *xpp;
#line 2859

#line 2859
    if (rndup)
#line 2859
        rndup = X_ALIGN - rndup;
#line 2859

#line 2859
    while (nelems-- != 0) {
#line 2859
        
#line 2859
        *tp++ = (double)  (*xp++);  /* type cast from schar to double */
#line 2859
    }
#line 2859

#line 2859
    *xpp = (void *)(xp + rndup);
#line 2859
    return status;
#line 2859
}
#line 2859

int
#line 2860
ncx_pad_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2860
{
#line 2860
    int status = NC_NOERR;
#line 2860
    size_t rndup = nelems % X_ALIGN;
#line 2860
    schar *xp = (schar *) *xpp;
#line 2860

#line 2860
    if (rndup)
#line 2860
        rndup = X_ALIGN - rndup;
#line 2860

#line 2860
    while (nelems-- != 0) {
#line 2860
        
#line 2860
        *tp++ = (longlong)  (*xp++);  /* type cast from schar to longlong */
#line 2860
    }
#line 2860

#line 2860
    *xpp = (void *)(xp + rndup);
#line 2860
    return status;
#line 2860
}
#line 2860

int
#line 2861
ncx_pad_getn_schar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2861
{
#line 2861
    int status = NC_NOERR;
#line 2861
    size_t rndup = nelems % X_ALIGN;
#line 2861
    schar *xp = (schar *) *xpp;
#line 2861

#line 2861
    if (rndup)
#line 2861
        rndup = X_ALIGN - rndup;
#line 2861

#line 2861
    while (nelems-- != 0) {
#line 2861
        
#line 2861
        if (*xp < 0) {
#line 2861
            
#line 2861
            status = NC_ERANGE; /* because tp is unsigned */
#line 2861
            
#line 2861
        }
#line 2861
        *tp++ = (ushort) (signed) (*xp++);  /* type cast from schar to ushort */
#line 2861
    }
#line 2861

#line 2861
    *xpp = (void *)(xp + rndup);
#line 2861
    return status;
#line 2861
}
#line 2861

int
#line 2862
ncx_pad_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2862
{
#line 2862
    int status = NC_NOERR;
#line 2862
    size_t rndup = nelems % X_ALIGN;
#line 2862
    schar *xp = (schar *) *xpp;
#line 2862

#line 2862
    if (rndup)
#line 2862
        rndup = X_ALIGN - rndup;
#line 2862

#line 2862
    while (nelems-- != 0) {
#line 2862
        
#line 2862
        if (*xp < 0) {
#line 2862
            
#line 2862
            status = NC_ERANGE; /* because tp is unsigned */
#line 2862
            
#line 2862
        }
#line 2862
        *tp++ = (uint) (signed) (*xp++);  /* type cast from schar to uint */
#line 2862
    }
#line 2862

#line 2862
    *xpp = (void *)(xp + rndup);
#line 2862
    return status;
#line 2862
}
#line 2862

int
#line 2863
ncx_pad_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2863
{
#line 2863
    int status = NC_NOERR;
#line 2863
    size_t rndup = nelems % X_ALIGN;
#line 2863
    schar *xp = (schar *) *xpp;
#line 2863

#line 2863
    if (rndup)
#line 2863
        rndup = X_ALIGN - rndup;
#line 2863

#line 2863
    while (nelems-- != 0) {
#line 2863
        
#line 2863
        if (*xp < 0) {
#line 2863
            
#line 2863
            status = NC_ERANGE; /* because tp is unsigned */
#line 2863
            
#line 2863
        }
#line 2863
        *tp++ = (ulonglong) (signed) (*xp++);  /* type cast from schar to ulonglong */
#line 2863
    }
#line 2863

#line 2863
    *xpp = (void *)(xp + rndup);
#line 2863
    return status;
#line 2863
}
#line 2863


#line 2866
int
ncx_putn_schar_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
{
		(void) memcpy(*xpp, tp, (size_t)nelems);
#line 2869
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2869

#line 2869
	return NC_NOERR;
#line 2869

}
int
#line 2871
ncx_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 2871
{
#line 2871
    int status = NC_NOERR;
#line 2871
    schar *xp = (schar *) *xpp;
#line 2871

#line 2871
    while (nelems-- != 0) {
#line 2871
        if (*tp > (uchar)X_SCHAR_MAX ) {
#line 2871
            
#line 2871
            status = NC_ERANGE;
#line 2871
            
#line 2871
        }
#line 2871
        *xp++ = (schar)  *tp++; /* type cast from uchar to schar */
#line 2871
    }
#line 2871

#line 2871
    *xpp = (void *)xp;
#line 2871
    return status;
#line 2871
}
#line 2871

int
#line 2872
ncx_putn_schar_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 2872
{
#line 2872
    int status = NC_NOERR;
#line 2872
    schar *xp = (schar *) *xpp;
#line 2872

#line 2872
    while (nelems-- != 0) {
#line 2872
        if (*tp > (short)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2872
            
#line 2872
            status = NC_ERANGE;
#line 2872
            
#line 2872
        }
#line 2872
        *xp++ = (schar)  *tp++; /* type cast from short to schar */
#line 2872
    }
#line 2872

#line 2872
    *xpp = (void *)xp;
#line 2872
    return status;
#line 2872
}
#line 2872

int
#line 2873
ncx_putn_schar_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 2873
{
#line 2873
    int status = NC_NOERR;
#line 2873
    schar *xp = (schar *) *xpp;
#line 2873

#line 2873
    while (nelems-- != 0) {
#line 2873
        if (*tp > (int)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2873
            
#line 2873
            status = NC_ERANGE;
#line 2873
            
#line 2873
        }
#line 2873
        *xp++ = (schar)  *tp++; /* type cast from int to schar */
#line 2873
    }
#line 2873

#line 2873
    *xpp = (void *)xp;
#line 2873
    return status;
#line 2873
}
#line 2873

int
#line 2874
ncx_putn_schar_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 2874
{
#line 2874
    int status = NC_NOERR;
#line 2874
    schar *xp = (schar *) *xpp;
#line 2874

#line 2874
    while (nelems-- != 0) {
#line 2874
        if (*tp > (long)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2874
            
#line 2874
            status = NC_ERANGE;
#line 2874
            
#line 2874
        }
#line 2874
        *xp++ = (schar)  *tp++; /* type cast from long to schar */
#line 2874
    }
#line 2874

#line 2874
    *xpp = (void *)xp;
#line 2874
    return status;
#line 2874
}
#line 2874

int
#line 2875
ncx_putn_schar_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 2875
{
#line 2875
    int status = NC_NOERR;
#line 2875
    schar *xp = (schar *) *xpp;
#line 2875

#line 2875
    while (nelems-- != 0) {
#line 2875
        if (*tp > (float)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2875
            
#line 2875
            status = NC_ERANGE;
#line 2875
            
#line 2875
        }
#line 2875
        *xp++ = (schar)  *tp++; /* type cast from float to schar */
#line 2875
    }
#line 2875

#line 2875
    *xpp = (void *)xp;
#line 2875
    return status;
#line 2875
}
#line 2875

int
#line 2876
ncx_putn_schar_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 2876
{
#line 2876
    int status = NC_NOERR;
#line 2876
    schar *xp = (schar *) *xpp;
#line 2876

#line 2876
    while (nelems-- != 0) {
#line 2876
        if (*tp > (double)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2876
            
#line 2876
            status = NC_ERANGE;
#line 2876
            
#line 2876
        }
#line 2876
        *xp++ = (schar)  *tp++; /* type cast from double to schar */
#line 2876
    }
#line 2876

#line 2876
    *xpp = (void *)xp;
#line 2876
    return status;
#line 2876
}
#line 2876

int
#line 2877
ncx_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 2877
{
#line 2877
    int status = NC_NOERR;
#line 2877
    schar *xp = (schar *) *xpp;
#line 2877

#line 2877
    while (nelems-- != 0) {
#line 2877
        if (*tp > (longlong)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2877
            
#line 2877
            status = NC_ERANGE;
#line 2877
            
#line 2877
        }
#line 2877
        *xp++ = (schar)  *tp++; /* type cast from longlong to schar */
#line 2877
    }
#line 2877

#line 2877
    *xpp = (void *)xp;
#line 2877
    return status;
#line 2877
}
#line 2877

int
#line 2878
ncx_putn_schar_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 2878
{
#line 2878
    int status = NC_NOERR;
#line 2878
    schar *xp = (schar *) *xpp;
#line 2878

#line 2878
    while (nelems-- != 0) {
#line 2878
        if (*tp > (ushort)X_SCHAR_MAX ) {
#line 2878
            
#line 2878
            status = NC_ERANGE;
#line 2878
            
#line 2878
        }
#line 2878
        *xp++ = (schar)  *tp++; /* type cast from ushort to schar */
#line 2878
    }
#line 2878

#line 2878
    *xpp = (void *)xp;
#line 2878
    return status;
#line 2878
}
#line 2878

int
#line 2879
ncx_putn_schar_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 2879
{
#line 2879
    int status = NC_NOERR;
#line 2879
    schar *xp = (schar *) *xpp;
#line 2879

#line 2879
    while (nelems-- != 0) {
#line 2879
        if (*tp > (uint)X_SCHAR_MAX ) {
#line 2879
            
#line 2879
            status = NC_ERANGE;
#line 2879
            
#line 2879
        }
#line 2879
        *xp++ = (schar)  *tp++; /* type cast from uint to schar */
#line 2879
    }
#line 2879

#line 2879
    *xpp = (void *)xp;
#line 2879
    return status;
#line 2879
}
#line 2879

int
#line 2880
ncx_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 2880
{
#line 2880
    int status = NC_NOERR;
#line 2880
    schar *xp = (schar *) *xpp;
#line 2880

#line 2880
    while (nelems-- != 0) {
#line 2880
        if (*tp > (ulonglong)X_SCHAR_MAX ) {
#line 2880
            
#line 2880
            status = NC_ERANGE;
#line 2880
            
#line 2880
        }
#line 2880
        *xp++ = (schar)  *tp++; /* type cast from ulonglong to schar */
#line 2880
    }
#line 2880

#line 2880
    *xpp = (void *)xp;
#line 2880
    return status;
#line 2880
}
#line 2880


#line 2883
int
ncx_pad_putn_schar_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2886

#line 2886
	if (rndup)
#line 2886
		rndup = X_ALIGN - rndup;
#line 2886

#line 2886
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 2886
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2886

#line 2886
	if (rndup)
#line 2886
	{
#line 2886
		(void) memcpy(*xpp, nada, (size_t)rndup);
#line 2886
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2886
	}
#line 2886

#line 2886
	return NC_NOERR;
#line 2886

}
int
#line 2888
ncx_pad_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 2888
{
#line 2888
    int status = NC_NOERR;
#line 2888
    size_t rndup = nelems % X_ALIGN;
#line 2888
    schar *xp = (schar *) *xpp;
#line 2888

#line 2888
    if (rndup) rndup = X_ALIGN - rndup;
#line 2888

#line 2888
    while (nelems-- != 0) {
#line 2888
        if (*tp > (uchar)X_SCHAR_MAX ) {
#line 2888
            
#line 2888
            status = NC_ERANGE;
#line 2888
            
#line 2888
        }
#line 2888
        *xp++ = (schar)  *tp++; /* type cast from uchar to schar */
#line 2888
    }
#line 2888

#line 2888

#line 2888
    if (rndup) {
#line 2888
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2888
        xp += rndup;
#line 2888
    }
#line 2888

#line 2888
    *xpp = (void *)xp;
#line 2888
    return status;
#line 2888
}
#line 2888

int
#line 2889
ncx_pad_putn_schar_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 2889
{
#line 2889
    int status = NC_NOERR;
#line 2889
    size_t rndup = nelems % X_ALIGN;
#line 2889
    schar *xp = (schar *) *xpp;
#line 2889

#line 2889
    if (rndup) rndup = X_ALIGN - rndup;
#line 2889

#line 2889
    while (nelems-- != 0) {
#line 2889
        if (*tp > (short)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2889
            
#line 2889
            status = NC_ERANGE;
#line 2889
            
#line 2889
        }
#line 2889
        *xp++ = (schar)  *tp++; /* type cast from short to schar */
#line 2889
    }
#line 2889

#line 2889

#line 2889
    if (rndup) {
#line 2889
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2889
        xp += rndup;
#line 2889
    }
#line 2889

#line 2889
    *xpp = (void *)xp;
#line 2889
    return status;
#line 2889
}
#line 2889

int
#line 2890
ncx_pad_putn_schar_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 2890
{
#line 2890
    int status = NC_NOERR;
#line 2890
    size_t rndup = nelems % X_ALIGN;
#line 2890
    schar *xp = (schar *) *xpp;
#line 2890

#line 2890
    if (rndup) rndup = X_ALIGN - rndup;
#line 2890

#line 2890
    while (nelems-- != 0) {
#line 2890
        if (*tp > (int)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2890
            
#line 2890
            status = NC_ERANGE;
#line 2890
            
#line 2890
        }
#line 2890
        *xp++ = (schar)  *tp++; /* type cast from int to schar */
#line 2890
    }
#line 2890

#line 2890

#line 2890
    if (rndup) {
#line 2890
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2890
        xp += rndup;
#line 2890
    }
#line 2890

#line 2890
    *xpp = (void *)xp;
#line 2890
    return status;
#line 2890
}
#line 2890

int
#line 2891
ncx_pad_putn_schar_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 2891
{
#line 2891
    int status = NC_NOERR;
#line 2891
    size_t rndup = nelems % X_ALIGN;
#line 2891
    schar *xp = (schar *) *xpp;
#line 2891

#line 2891
    if (rndup) rndup = X_ALIGN - rndup;
#line 2891

#line 2891
    while (nelems-- != 0) {
#line 2891
        if (*tp > (long)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2891
            
#line 2891
            status = NC_ERANGE;
#line 2891
            
#line 2891
        }
#line 2891
        *xp++ = (schar)  *tp++; /* type cast from long to schar */
#line 2891
    }
#line 2891

#line 2891

#line 2891
    if (rndup) {
#line 2891
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2891
        xp += rndup;
#line 2891
    }
#line 2891

#line 2891
    *xpp = (void *)xp;
#line 2891
    return status;
#line 2891
}
#line 2891

int
#line 2892
ncx_pad_putn_schar_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 2892
{
#line 2892
    int status = NC_NOERR;
#line 2892
    size_t rndup = nelems % X_ALIGN;
#line 2892
    schar *xp = (schar *) *xpp;
#line 2892

#line 2892
    if (rndup) rndup = X_ALIGN - rndup;
#line 2892

#line 2892
    while (nelems-- != 0) {
#line 2892
        if (*tp > (float)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2892
            
#line 2892
            status = NC_ERANGE;
#line 2892
            
#line 2892
        }
#line 2892
        *xp++ = (schar)  *tp++; /* type cast from float to schar */
#line 2892
    }
#line 2892

#line 2892

#line 2892
    if (rndup) {
#line 2892
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2892
        xp += rndup;
#line 2892
    }
#line 2892

#line 2892
    *xpp = (void *)xp;
#line 2892
    return status;
#line 2892
}
#line 2892

int
#line 2893
ncx_pad_putn_schar_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 2893
{
#line 2893
    int status = NC_NOERR;
#line 2893
    size_t rndup = nelems % X_ALIGN;
#line 2893
    schar *xp = (schar *) *xpp;
#line 2893

#line 2893
    if (rndup) rndup = X_ALIGN - rndup;
#line 2893

#line 2893
    while (nelems-- != 0) {
#line 2893
        if (*tp > (double)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2893
            
#line 2893
            status = NC_ERANGE;
#line 2893
            
#line 2893
        }
#line 2893
        *xp++ = (schar)  *tp++; /* type cast from double to schar */
#line 2893
    }
#line 2893

#line 2893

#line 2893
    if (rndup) {
#line 2893
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2893
        xp += rndup;
#line 2893
    }
#line 2893

#line 2893
    *xpp = (void *)xp;
#line 2893
    return status;
#line 2893
}
#line 2893

int
#line 2894
ncx_pad_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 2894
{
#line 2894
    int status = NC_NOERR;
#line 2894
    size_t rndup = nelems % X_ALIGN;
#line 2894
    schar *xp = (schar *) *xpp;
#line 2894

#line 2894
    if (rndup) rndup = X_ALIGN - rndup;
#line 2894

#line 2894
    while (nelems-- != 0) {
#line 2894
        if (*tp > (longlong)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2894
            
#line 2894
            status = NC_ERANGE;
#line 2894
            
#line 2894
        }
#line 2894
        *xp++ = (schar)  *tp++; /* type cast from longlong to schar */
#line 2894
    }
#line 2894

#line 2894

#line 2894
    if (rndup) {
#line 2894
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2894
        xp += rndup;
#line 2894
    }
#line 2894

#line 2894
    *xpp = (void *)xp;
#line 2894
    return status;
#line 2894
}
#line 2894

int
#line 2895
ncx_pad_putn_schar_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 2895
{
#line 2895
    int status = NC_NOERR;
#line 2895
    size_t rndup = nelems % X_ALIGN;
#line 2895
    schar *xp = (schar *) *xpp;
#line 2895

#line 2895
    if (rndup) rndup = X_ALIGN - rndup;
#line 2895

#line 2895
    while (nelems-- != 0) {
#line 2895
        if (*tp > (ushort)X_SCHAR_MAX ) {
#line 2895
            
#line 2895
            status = NC_ERANGE;
#line 2895
            
#line 2895
        }
#line 2895
        *xp++ = (schar)  *tp++; /* type cast from ushort to schar */
#line 2895
    }
#line 2895

#line 2895

#line 2895
    if (rndup) {
#line 2895
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2895
        xp += rndup;
#line 2895
    }
#line 2895

#line 2895
    *xpp = (void *)xp;
#line 2895
    return status;
#line 2895
}
#line 2895

int
#line 2896
ncx_pad_putn_schar_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 2896
{
#line 2896
    int status = NC_NOERR;
#line 2896
    size_t rndup = nelems % X_ALIGN;
#line 2896
    schar *xp = (schar *) *xpp;
#line 2896

#line 2896
    if (rndup) rndup = X_ALIGN - rndup;
#line 2896

#line 2896
    while (nelems-- != 0) {
#line 2896
        if (*tp > (uint)X_SCHAR_MAX ) {
#line 2896
            
#line 2896
            status = NC_ERANGE;
#line 2896
            
#line 2896
        }
#line 2896
        *xp++ = (schar)  *tp++; /* type cast from uint to schar */
#line 2896
    }
#line 2896

#line 2896

#line 2896
    if (rndup) {
#line 2896
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2896
        xp += rndup;
#line 2896
    }
#line 2896

#line 2896
    *xpp = (void *)xp;
#line 2896
    return status;
#line 2896
}
#line 2896

int
#line 2897
ncx_pad_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 2897
{
#line 2897
    int status = NC_NOERR;
#line 2897
    size_t rndup = nelems % X_ALIGN;
#line 2897
    schar *xp = (schar *) *xpp;
#line 2897

#line 2897
    if (rndup) rndup = X_ALIGN - rndup;
#line 2897

#line 2897
    while (nelems-- != 0) {
#line 2897
        if (*tp > (ulonglong)X_SCHAR_MAX ) {
#line 2897
            
#line 2897
            status = NC_ERANGE;
#line 2897
            
#line 2897
        }
#line 2897
        *xp++ = (schar)  *tp++; /* type cast from ulonglong to schar */
#line 2897
    }
#line 2897

#line 2897

#line 2897
    if (rndup) {
#line 2897
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2897
        xp += rndup;
#line 2897
    }
#line 2897

#line 2897
    *xpp = (void *)xp;
#line 2897
    return status;
#line 2897
}
#line 2897



/* uchar ---------------------------------------------------------------------*/
#line 2903
int
ncx_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
    int status = NC_NOERR;
    uchar *xp = (uchar *)(*xpp);

    while (nelems-- != 0) {
        if (*xp > SCHAR_MAX) {
            *tp = NC_FILL_BYTE;
       	    status = NC_ERANGE;
            
        }
	*tp++ = (schar) *xp++; /* type cast from uchar to schar */
    }

    *xpp = (const void *)xp;
    return status;
}
#line 2922
int
ncx_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, (size_t)nelems);
#line 2925
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2925
	return NC_NOERR;
#line 2925

}
int
#line 2927
ncx_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2927
{
#line 2927
    int status = NC_NOERR;
#line 2927
    uchar *xp = (uchar *)(*xpp);
#line 2927

#line 2927
    while (nelems-- != 0) {
#line 2927
        
#line 2927
        *tp++ = (short)  (*xp++);  /* type cast from uchar to short */
#line 2927
    }
#line 2927

#line 2927
    *xpp = (const void *)xp;
#line 2927
    return status;
#line 2927
}
#line 2927

int
#line 2928
ncx_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2928
{
#line 2928
    int status = NC_NOERR;
#line 2928
    uchar *xp = (uchar *)(*xpp);
#line 2928

#line 2928
    while (nelems-- != 0) {
#line 2928
        
#line 2928
        *tp++ = (int)  (*xp++);  /* type cast from uchar to int */
#line 2928
    }
#line 2928

#line 2928
    *xpp = (const void *)xp;
#line 2928
    return status;
#line 2928
}
#line 2928

int
#line 2929
ncx_getn_uchar_long(const void **xpp, size_t nelems, long *tp)
#line 2929
{
#line 2929
    int status = NC_NOERR;
#line 2929
    uchar *xp = (uchar *)(*xpp);
#line 2929

#line 2929
    while (nelems-- != 0) {
#line 2929
        
#line 2929
        *tp++ = (long)  (*xp++);  /* type cast from uchar to long */
#line 2929
    }
#line 2929

#line 2929
    *xpp = (const void *)xp;
#line 2929
    return status;
#line 2929
}
#line 2929

int
#line 2930
ncx_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2930
{
#line 2930
    int status = NC_NOERR;
#line 2930
    uchar *xp = (uchar *)(*xpp);
#line 2930

#line 2930
    while (nelems-- != 0) {
#line 2930
        
#line 2930
        *tp++ = (float)  (*xp++);  /* type cast from uchar to float */
#line 2930
    }
#line 2930

#line 2930
    *xpp = (const void *)xp;
#line 2930
    return status;
#line 2930
}
#line 2930

int
#line 2931
ncx_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2931
{
#line 2931
    int status = NC_NOERR;
#line 2931
    uchar *xp = (uchar *)(*xpp);
#line 2931

#line 2931
    while (nelems-- != 0) {
#line 2931
        
#line 2931
        *tp++ = (double)  (*xp++);  /* type cast from uchar to double */
#line 2931
    }
#line 2931

#line 2931
    *xpp = (const void *)xp;
#line 2931
    return status;
#line 2931
}
#line 2931

int
#line 2932
ncx_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2932
{
#line 2932
    int status = NC_NOERR;
#line 2932
    uchar *xp = (uchar *)(*xpp);
#line 2932

#line 2932
    while (nelems-- != 0) {
#line 2932
        
#line 2932
        *tp++ = (longlong)  (*xp++);  /* type cast from uchar to longlong */
#line 2932
    }
#line 2932

#line 2932
    *xpp = (const void *)xp;
#line 2932
    return status;
#line 2932
}
#line 2932

int
#line 2933
ncx_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2933
{
#line 2933
    int status = NC_NOERR;
#line 2933
    uchar *xp = (uchar *)(*xpp);
#line 2933

#line 2933
    while (nelems-- != 0) {
#line 2933
        
#line 2933
        *tp++ = (ushort)  (*xp++);  /* type cast from uchar to ushort */
#line 2933
    }
#line 2933

#line 2933
    *xpp = (const void *)xp;
#line 2933
    return status;
#line 2933
}
#line 2933

int
#line 2934
ncx_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2934
{
#line 2934
    int status = NC_NOERR;
#line 2934
    uchar *xp = (uchar *)(*xpp);
#line 2934

#line 2934
    while (nelems-- != 0) {
#line 2934
        
#line 2934
        *tp++ = (uint)  (*xp++);  /* type cast from uchar to uint */
#line 2934
    }
#line 2934

#line 2934
    *xpp = (const void *)xp;
#line 2934
    return status;
#line 2934
}
#line 2934

int
#line 2935
ncx_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2935
{
#line 2935
    int status = NC_NOERR;
#line 2935
    uchar *xp = (uchar *)(*xpp);
#line 2935

#line 2935
    while (nelems-- != 0) {
#line 2935
        
#line 2935
        *tp++ = (ulonglong)  (*xp++);  /* type cast from uchar to ulonglong */
#line 2935
    }
#line 2935

#line 2935
    *xpp = (const void *)xp;
#line 2935
    return status;
#line 2935
}
#line 2935


#line 2938
int
ncx_pad_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
    int status = NC_NOERR;
    size_t rndup = nelems % X_ALIGN;
    uchar *xp = (uchar *) *xpp;

    if (rndup) rndup = X_ALIGN - rndup;

    while (nelems-- != 0) {
        if (*xp > SCHAR_MAX) {
            *tp = NC_FILL_BYTE;
            status = NC_ERANGE;
            
        }
        *tp++ = (schar) *xp++; /* type cast from uchar to schar */
    }

    *xpp = (void *)(xp + rndup);
    return status;
}
#line 2960
int
ncx_pad_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2963

#line 2963
	if (rndup)
#line 2963
		rndup = X_ALIGN - rndup;
#line 2963

#line 2963
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 2963
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2963

#line 2963
	return NC_NOERR;
#line 2963

}
int
#line 2965
ncx_pad_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2965
{
#line 2965
    int status = NC_NOERR;
#line 2965
    size_t rndup = nelems % X_ALIGN;
#line 2965
    uchar *xp = (uchar *) *xpp;
#line 2965

#line 2965
    if (rndup)
#line 2965
        rndup = X_ALIGN - rndup;
#line 2965

#line 2965
    while (nelems-- != 0) {
#line 2965
        
#line 2965
        *tp++ = (short)  (*xp++);  /* type cast from uchar to short */
#line 2965
    }
#line 2965

#line 2965
    *xpp = (void *)(xp + rndup);
#line 2965
    return status;
#line 2965
}
#line 2965

int
#line 2966
ncx_pad_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2966
{
#line 2966
    int status = NC_NOERR;
#line 2966
    size_t rndup = nelems % X_ALIGN;
#line 2966
    uchar *xp = (uchar *) *xpp;
#line 2966

#line 2966
    if (rndup)
#line 2966
        rndup = X_ALIGN - rndup;
#line 2966

#line 2966
    while (nelems-- != 0) {
#line 2966
        
#line 2966
        *tp++ = (int)  (*xp++);  /* type cast from uchar to int */
#line 2966
    }
#line 2966

#line 2966
    *xpp = (void *)(xp + rndup);
#line 2966
    return status;
#line 2966
}
#line 2966

int
#line 2967
ncx_pad_getn_uchar_long(const void **xpp, size_t nelems, long *tp)
#line 2967
{
#line 2967
    int status = NC_NOERR;
#line 2967
    size_t rndup = nelems % X_ALIGN;
#line 2967
    uchar *xp = (uchar *) *xpp;
#line 2967

#line 2967
    if (rndup)
#line 2967
        rndup = X_ALIGN - rndup;
#line 2967

#line 2967
    while (nelems-- != 0) {
#line 2967
        
#line 2967
        *tp++ = (long)  (*xp++);  /* type cast from uchar to long */
#line 2967
    }
#line 2967

#line 2967
    *xpp = (void *)(xp + rndup);
#line 2967
    return status;
#line 2967
}
#line 2967

int
#line 2968
ncx_pad_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2968
{
#line 2968
    int status = NC_NOERR;
#line 2968
    size_t rndup = nelems % X_ALIGN;
#line 2968
    uchar *xp = (uchar *) *xpp;
#line 2968

#line 2968
    if (rndup)
#line 2968
        rndup = X_ALIGN - rndup;
#line 2968

#line 2968
    while (nelems-- != 0) {
#line 2968
        
#line 2968
        *tp++ = (float)  (*xp++);  /* type cast from uchar to float */
#line 2968
    }
#line 2968

#line 2968
    *xpp = (void *)(xp + rndup);
#line 2968
    return status;
#line 2968
}
#line 2968

int
#line 2969
ncx_pad_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2969
{
#line 2969
    int status = NC_NOERR;
#line 2969
    size_t rndup = nelems % X_ALIGN;
#line 2969
    uchar *xp = (uchar *) *xpp;
#line 2969

#line 2969
    if (rndup)
#line 2969
        rndup = X_ALIGN - rndup;
#line 2969

#line 2969
    while (nelems-- != 0) {
#line 2969
        
#line 2969
        *tp++ = (double)  (*xp++);  /* type cast from uchar to double */
#line 2969
    }
#line 2969

#line 2969
    *xpp = (void *)(xp + rndup);
#line 2969
    return status;
#line 2969
}
#line 2969

int
#line 2970
ncx_pad_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2970
{
#line 2970
    int status = NC_NOERR;
#line 2970
    size_t rndup = nelems % X_ALIGN;
#line 2970
    uchar *xp = (uchar *) *xpp;
#line 2970

#line 2970
    if (rndup)
#line 2970
        rndup = X_ALIGN - rndup;
#line 2970

#line 2970
    while (nelems-- != 0) {
#line 2970
        
#line 2970
        *tp++ = (longlong)  (*xp++);  /* type cast from uchar to longlong */
#line 2970
    }
#line 2970

#line 2970
    *xpp = (void *)(xp + rndup);
#line 2970
    return status;
#line 2970
}
#line 2970

int
#line 2971
ncx_pad_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2971
{
#line 2971
    int status = NC_NOERR;
#line 2971
    size_t rndup = nelems % X_ALIGN;
#line 2971
    uchar *xp = (uchar *) *xpp;
#line 2971

#line 2971
    if (rndup)
#line 2971
        rndup = X_ALIGN - rndup;
#line 2971

#line 2971
    while (nelems-- != 0) {
#line 2971
        
#line 2971
        *tp++ = (ushort)  (*xp++);  /* type cast from uchar to ushort */
#line 2971
    }
#line 2971

#line 2971
    *xpp = (void *)(xp + rndup);
#line 2971
    return status;
#line 2971
}
#line 2971

int
#line 2972
ncx_pad_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2972
{
#line 2972
    int status = NC_NOERR;
#line 2972
    size_t rndup = nelems % X_ALIGN;
#line 2972
    uchar *xp = (uchar *) *xpp;
#line 2972

#line 2972
    if (rndup)
#line 2972
        rndup = X_ALIGN - rndup;
#line 2972

#line 2972
    while (nelems-- != 0) {
#line 2972
        
#line 2972
        *tp++ = (uint)  (*xp++);  /* type cast from uchar to uint */
#line 2972
    }
#line 2972

#line 2972
    *xpp = (void *)(xp + rndup);
#line 2972
    return status;
#line 2972
}
#line 2972

int
#line 2973
ncx_pad_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2973
{
#line 2973
    int status = NC_NOERR;
#line 2973
    size_t rndup = nelems % X_ALIGN;
#line 2973
    uchar *xp = (uchar *) *xpp;
#line 2973

#line 2973
    if (rndup)
#line 2973
        rndup = X_ALIGN - rndup;
#line 2973

#line 2973
    while (nelems-- != 0) {
#line 2973
        
#line 2973
        *tp++ = (ulonglong)  (*xp++);  /* type cast from uchar to ulonglong */
#line 2973
    }
#line 2973

#line 2973
    *xpp = (void *)(xp + rndup);
#line 2973
    return status;
#line 2973
}
#line 2973


#line 2976
int
ncx_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
{
    int status = NC_NOERR;
    uchar *xp = (uchar *) *xpp;

    while (nelems-- != 0) {
        if (*tp < 0) {
            
            status = NC_ERANGE;
            
        }
        *xp++ = (uchar) (signed) *tp++; /* type cast from schar to uchar */
    }

    *xpp = (void *)xp;
    return status;
}
#line 2995
int
ncx_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
{
		(void) memcpy(*xpp, tp, (size_t)nelems);
#line 2998
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2998

#line 2998
	return NC_NOERR;
#line 2998

}
int
#line 3000
ncx_putn_uchar_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3000
{
#line 3000
    int status = NC_NOERR;
#line 3000
    uchar *xp = (uchar *) *xpp;
#line 3000

#line 3000
    while (nelems-- != 0) {
#line 3000
        if (*tp > (short)X_UCHAR_MAX || *tp < 0) {
#line 3000
            
#line 3000
            status = NC_ERANGE;
#line 3000
            
#line 3000
        }
#line 3000
        *xp++ = (uchar) (signed) *tp++; /* type cast from short to uchar */
#line 3000
    }
#line 3000

#line 3000
    *xpp = (void *)xp;
#line 3000
    return status;
#line 3000
}
#line 3000

int
#line 3001
ncx_putn_uchar_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3001
{
#line 3001
    int status = NC_NOERR;
#line 3001
    uchar *xp = (uchar *) *xpp;
#line 3001

#line 3001
    while (nelems-- != 0) {
#line 3001
        if (*tp > (int)X_UCHAR_MAX || *tp < 0) {
#line 3001
            
#line 3001
            status = NC_ERANGE;
#line 3001
            
#line 3001
        }
#line 3001
        *xp++ = (uchar) (signed) *tp++; /* type cast from int to uchar */
#line 3001
    }
#line 3001

#line 3001
    *xpp = (void *)xp;
#line 3001
    return status;
#line 3001
}
#line 3001

int
#line 3002
ncx_putn_uchar_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3002
{
#line 3002
    int status = NC_NOERR;
#line 3002
    uchar *xp = (uchar *) *xpp;
#line 3002

#line 3002
    while (nelems-- != 0) {
#line 3002
        if (*tp > (long)X_UCHAR_MAX || *tp < 0) {
#line 3002
            
#line 3002
            status = NC_ERANGE;
#line 3002
            
#line 3002
        }
#line 3002
        *xp++ = (uchar) (signed) *tp++; /* type cast from long to uchar */
#line 3002
    }
#line 3002

#line 3002
    *xpp = (void *)xp;
#line 3002
    return status;
#line 3002
}
#line 3002

int
#line 3003
ncx_putn_uchar_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3003
{
#line 3003
    int status = NC_NOERR;
#line 3003
    uchar *xp = (uchar *) *xpp;
#line 3003

#line 3003
    while (nelems-- != 0) {
#line 3003
        if (*tp > (float)X_UCHAR_MAX || *tp < 0) {
#line 3003
            
#line 3003
            status = NC_ERANGE;
#line 3003
            
#line 3003
        }
#line 3003
        *xp++ = (uchar) (signed) *tp++; /* type cast from float to uchar */
#line 3003
    }
#line 3003

#line 3003
    *xpp = (void *)xp;
#line 3003
    return status;
#line 3003
}
#line 3003

int
#line 3004
ncx_putn_uchar_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3004
{
#line 3004
    int status = NC_NOERR;
#line 3004
    uchar *xp = (uchar *) *xpp;
#line 3004

#line 3004
    while (nelems-- != 0) {
#line 3004
        if (*tp > (double)X_UCHAR_MAX || *tp < 0) {
#line 3004
            
#line 3004
            status = NC_ERANGE;
#line 3004
            
#line 3004
        }
#line 3004
        *xp++ = (uchar) (signed) *tp++; /* type cast from double to uchar */
#line 3004
    }
#line 3004

#line 3004
    *xpp = (void *)xp;
#line 3004
    return status;
#line 3004
}
#line 3004

int
#line 3005
ncx_putn_uchar_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3005
{
#line 3005
    int status = NC_NOERR;
#line 3005
    uchar *xp = (uchar *) *xpp;
#line 3005

#line 3005
    while (nelems-- != 0) {
#line 3005
        if (*tp > (longlong)X_UCHAR_MAX || *tp < 0) {
#line 3005
            
#line 3005
            status = NC_ERANGE;
#line 3005
            
#line 3005
        }
#line 3005
        *xp++ = (uchar) (signed) *tp++; /* type cast from longlong to uchar */
#line 3005
    }
#line 3005

#line 3005
    *xpp = (void *)xp;
#line 3005
    return status;
#line 3005
}
#line 3005

int
#line 3006
ncx_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3006
{
#line 3006
    int status = NC_NOERR;
#line 3006
    uchar *xp = (uchar *) *xpp;
#line 3006

#line 3006
    while (nelems-- != 0) {
#line 3006
        if (*tp > (ushort)X_UCHAR_MAX ) {
#line 3006
            
#line 3006
            status = NC_ERANGE;
#line 3006
            
#line 3006
        }
#line 3006
        *xp++ = (uchar)  *tp++; /* type cast from ushort to uchar */
#line 3006
    }
#line 3006

#line 3006
    *xpp = (void *)xp;
#line 3006
    return status;
#line 3006
}
#line 3006

int
#line 3007
ncx_putn_uchar_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3007
{
#line 3007
    int status = NC_NOERR;
#line 3007
    uchar *xp = (uchar *) *xpp;
#line 3007

#line 3007
    while (nelems-- != 0) {
#line 3007
        if (*tp > (uint)X_UCHAR_MAX ) {
#line 3007
            
#line 3007
            status = NC_ERANGE;
#line 3007
            
#line 3007
        }
#line 3007
        *xp++ = (uchar)  *tp++; /* type cast from uint to uchar */
#line 3007
    }
#line 3007

#line 3007
    *xpp = (void *)xp;
#line 3007
    return status;
#line 3007
}
#line 3007

int
#line 3008
ncx_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3008
{
#line 3008
    int status = NC_NOERR;
#line 3008
    uchar *xp = (uchar *) *xpp;
#line 3008

#line 3008
    while (nelems-- != 0) {
#line 3008
        if (*tp > (ulonglong)X_UCHAR_MAX ) {
#line 3008
            
#line 3008
            status = NC_ERANGE;
#line 3008
            
#line 3008
        }
#line 3008
        *xp++ = (uchar)  *tp++; /* type cast from ulonglong to uchar */
#line 3008
    }
#line 3008

#line 3008
    *xpp = (void *)xp;
#line 3008
    return status;
#line 3008
}
#line 3008


#line 3011
int
ncx_pad_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
{
    int status = NC_NOERR;
    size_t rndup = nelems % X_ALIGN;
    uchar *xp = (uchar *) *xpp;

    if (rndup) rndup = X_ALIGN - rndup;

    while (nelems-- != 0) {
        if (*tp < 0) {
            
            status = NC_ERANGE;
            
        }
        *xp++ = (uchar) (signed) *tp++; /* type cast from schar to uchar */
    }

    if (rndup) {
        (void) memcpy(xp, nada, (size_t)rndup);
        xp += rndup;
    }

    *xpp = (void *)xp;
    return status;
}
#line 3038
int
ncx_pad_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
{
		size_t rndup = nelems % X_ALIGN;
#line 3041

#line 3041
	if (rndup)
#line 3041
		rndup = X_ALIGN - rndup;
#line 3041

#line 3041
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3041
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3041

#line 3041
	if (rndup)
#line 3041
	{
#line 3041
		(void) memcpy(*xpp, nada, (size_t)rndup);
#line 3041
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3041
	}
#line 3041

#line 3041
	return NC_NOERR;
#line 3041

}
int
#line 3043
ncx_pad_putn_uchar_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3043
{
#line 3043
    int status = NC_NOERR;
#line 3043
    size_t rndup = nelems % X_ALIGN;
#line 3043
    uchar *xp = (uchar *) *xpp;
#line 3043

#line 3043
    if (rndup) rndup = X_ALIGN - rndup;
#line 3043

#line 3043
    while (nelems-- != 0) {
#line 3043
        if (*tp > (short)X_UCHAR_MAX || *tp < 0) {
#line 3043
            
#line 3043
            status = NC_ERANGE;
#line 3043
            
#line 3043
        }
#line 3043
        *xp++ = (uchar) (signed) *tp++; /* type cast from short to uchar */
#line 3043
    }
#line 3043

#line 3043

#line 3043
    if (rndup) {
#line 3043
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3043
        xp += rndup;
#line 3043
    }
#line 3043

#line 3043
    *xpp = (void *)xp;
#line 3043
    return status;
#line 3043
}
#line 3043

int
#line 3044
ncx_pad_putn_uchar_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3044
{
#line 3044
    int status = NC_NOERR;
#line 3044
    size_t rndup = nelems % X_ALIGN;
#line 3044
    uchar *xp = (uchar *) *xpp;
#line 3044

#line 3044
    if (rndup) rndup = X_ALIGN - rndup;
#line 3044

#line 3044
    while (nelems-- != 0) {
#line 3044
        if (*tp > (int)X_UCHAR_MAX || *tp < 0) {
#line 3044
            
#line 3044
            status = NC_ERANGE;
#line 3044
            
#line 3044
        }
#line 3044
        *xp++ = (uchar) (signed) *tp++; /* type cast from int to uchar */
#line 3044
    }
#line 3044

#line 3044

#line 3044
    if (rndup) {
#line 3044
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3044
        xp += rndup;
#line 3044
    }
#line 3044

#line 3044
    *xpp = (void *)xp;
#line 3044
    return status;
#line 3044
}
#line 3044

int
#line 3045
ncx_pad_putn_uchar_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3045
{
#line 3045
    int status = NC_NOERR;
#line 3045
    size_t rndup = nelems % X_ALIGN;
#line 3045
    uchar *xp = (uchar *) *xpp;
#line 3045

#line 3045
    if (rndup) rndup = X_ALIGN - rndup;
#line 3045

#line 3045
    while (nelems-- != 0) {
#line 3045
        if (*tp > (long)X_UCHAR_MAX || *tp < 0) {
#line 3045
            
#line 3045
            status = NC_ERANGE;
#line 3045
            
#line 3045
        }
#line 3045
        *xp++ = (uchar) (signed) *tp++; /* type cast from long to uchar */
#line 3045
    }
#line 3045

#line 3045

#line 3045
    if (rndup) {
#line 3045
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3045
        xp += rndup;
#line 3045
    }
#line 3045

#line 3045
    *xpp = (void *)xp;
#line 3045
    return status;
#line 3045
}
#line 3045

int
#line 3046
ncx_pad_putn_uchar_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3046
{
#line 3046
    int status = NC_NOERR;
#line 3046
    size_t rndup = nelems % X_ALIGN;
#line 3046
    uchar *xp = (uchar *) *xpp;
#line 3046

#line 3046
    if (rndup) rndup = X_ALIGN - rndup;
#line 3046

#line 3046
    while (nelems-- != 0) {
#line 3046
        if (*tp > (float)X_UCHAR_MAX || *tp < 0) {
#line 3046
            
#line 3046
            status = NC_ERANGE;
#line 3046
            
#line 3046
        }
#line 3046
        *xp++ = (uchar) (signed) *tp++; /* type cast from float to uchar */
#line 3046
    }
#line 3046

#line 3046

#line 3046
    if (rndup) {
#line 3046
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3046
        xp += rndup;
#line 3046
    }
#line 3046

#line 3046
    *xpp = (void *)xp;
#line 3046
    return status;
#line 3046
}
#line 3046

int
#line 3047
ncx_pad_putn_uchar_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3047
{
#line 3047
    int status = NC_NOERR;
#line 3047
    size_t rndup = nelems % X_ALIGN;
#line 3047
    uchar *xp = (uchar *) *xpp;
#line 3047

#line 3047
    if (rndup) rndup = X_ALIGN - rndup;
#line 3047

#line 3047
    while (nelems-- != 0) {
#line 3047
        if (*tp > (double)X_UCHAR_MAX || *tp < 0) {
#line 3047
            
#line 3047
            status = NC_ERANGE;
#line 3047
            
#line 3047
        }
#line 3047
        *xp++ = (uchar) (signed) *tp++; /* type cast from double to uchar */
#line 3047
    }
#line 3047

#line 3047

#line 3047
    if (rndup) {
#line 3047
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3047
        xp += rndup;
#line 3047
    }
#line 3047

#line 3047
    *xpp = (void *)xp;
#line 3047
    return status;
#line 3047
}
#line 3047

int
#line 3048
ncx_pad_putn_uchar_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3048
{
#line 3048
    int status = NC_NOERR;
#line 3048
    size_t rndup = nelems % X_ALIGN;
#line 3048
    uchar *xp = (uchar *) *xpp;
#line 3048

#line 3048
    if (rndup) rndup = X_ALIGN - rndup;
#line 3048

#line 3048
    while (nelems-- != 0) {
#line 3048
        if (*tp > (longlong)X_UCHAR_MAX || *tp < 0) {
#line 3048
            
#line 3048
            status = NC_ERANGE;
#line 3048
            
#line 3048
        }
#line 3048
        *xp++ = (uchar) (signed) *tp++; /* type cast from longlong to uchar */
#line 3048
    }
#line 3048

#line 3048

#line 3048
    if (rndup) {
#line 3048
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3048
        xp += rndup;
#line 3048
    }
#line 3048

#line 3048
    *xpp = (void *)xp;
#line 3048
    return status;
#line 3048
}
#line 3048

int
#line 3049
ncx_pad_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3049
{
#line 3049
    int status = NC_NOERR;
#line 3049
    size_t rndup = nelems % X_ALIGN;
#line 3049
    uchar *xp = (uchar *) *xpp;
#line 3049

#line 3049
    if (rndup) rndup = X_ALIGN - rndup;
#line 3049

#line 3049
    while (nelems-- != 0) {
#line 3049
        if (*tp > (ushort)X_UCHAR_MAX ) {
#line 3049
            
#line 3049
            status = NC_ERANGE;
#line 3049
            
#line 3049
        }
#line 3049
        *xp++ = (uchar)  *tp++; /* type cast from ushort to uchar */
#line 3049
    }
#line 3049

#line 3049

#line 3049
    if (rndup) {
#line 3049
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3049
        xp += rndup;
#line 3049
    }
#line 3049

#line 3049
    *xpp = (void *)xp;
#line 3049
    return status;
#line 3049
}
#line 3049

int
#line 3050
ncx_pad_putn_uchar_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3050
{
#line 3050
    int status = NC_NOERR;
#line 3050
    size_t rndup = nelems % X_ALIGN;
#line 3050
    uchar *xp = (uchar *) *xpp;
#line 3050

#line 3050
    if (rndup) rndup = X_ALIGN - rndup;
#line 3050

#line 3050
    while (nelems-- != 0) {
#line 3050
        if (*tp > (uint)X_UCHAR_MAX ) {
#line 3050
            
#line 3050
            status = NC_ERANGE;
#line 3050
            
#line 3050
        }
#line 3050
        *xp++ = (uchar)  *tp++; /* type cast from uint to uchar */
#line 3050
    }
#line 3050

#line 3050

#line 3050
    if (rndup) {
#line 3050
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3050
        xp += rndup;
#line 3050
    }
#line 3050

#line 3050
    *xpp = (void *)xp;
#line 3050
    return status;
#line 3050
}
#line 3050

int
#line 3051
ncx_pad_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3051
{
#line 3051
    int status = NC_NOERR;
#line 3051
    size_t rndup = nelems % X_ALIGN;
#line 3051
    uchar *xp = (uchar *) *xpp;
#line 3051

#line 3051
    if (rndup) rndup = X_ALIGN - rndup;
#line 3051

#line 3051
    while (nelems-- != 0) {
#line 3051
        if (*tp > (ulonglong)X_UCHAR_MAX ) {
#line 3051
            
#line 3051
            status = NC_ERANGE;
#line 3051
            
#line 3051
        }
#line 3051
        *xp++ = (uchar)  *tp++; /* type cast from ulonglong to uchar */
#line 3051
    }
#line 3051

#line 3051

#line 3051
    if (rndup) {
#line 3051
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3051
        xp += rndup;
#line 3051
    }
#line 3051

#line 3051
    *xpp = (void *)xp;
#line 3051
    return status;
#line 3051
}
#line 3051


/* short ---------------------------------------------------------------------*/

#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_SHORT);
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return NC_NOERR;
}
#else
int
#line 3069
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 3069
{
#line 3069
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3069

#line 3069
 /* basic algorithm is:
#line 3069
  *   - ensure sane alignment of input data
#line 3069
  *   - copy (conversion happens automatically) input data
#line 3069
  *     to output
#line 3069
  *   - update xpp to point at next unconverted input, and tp to point
#line 3069
  *     at next location for converted output
#line 3069
  */
#line 3069
  long i, j, ni;
#line 3069
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3069
  short *xp;
#line 3069
  int nrange = 0;         /* number of range errors */
#line 3069
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3069
  long cxp = (long) *((char**)xpp);
#line 3069

#line 3069
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3069
  /* sjl: manually stripmine so we can limit amount of
#line 3069
   * vector work space reserved to LOOPCNT elements. Also
#line 3069
   * makes vectorisation easy */
#line 3069
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3069
    ni=Min(nelems-j,LOOPCNT);
#line 3069
    if (realign) {
#line 3069
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3069
      xp = tmp;
#line 3069
    } else {
#line 3069
      xp = (short *) *xpp;
#line 3069
    }
#line 3069
   /* copy the next block */
#line 3069
#pragma cdir loopcnt=LOOPCNT
#line 3069
#pragma cdir shortloop
#line 3069
    for (i=0; i<ni; i++) {
#line 3069
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3069
     /* test for range errors (not always needed but do it anyway) */
#line 3069
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3069
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3069
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3069
    }
#line 3069
   /* update xpp and tp */
#line 3069
    if (realign) xp = (short *) *xpp;
#line 3069
    xp += ni;
#line 3069
    tp += ni;
#line 3069
    *xpp = (void*)xp;
#line 3069
  }
#line 3069
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3069

#line 3069
#else   /* not SX */
#line 3069
	const char *xp = (const char *) *xpp;
#line 3069
	int status = NC_NOERR;
#line 3069

#line 3069
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3069
	{
#line 3069
		const int lstatus = ncx_get_short_short(xp, tp);
#line 3069
		if (status == NC_NOERR) /* report the first encountered error */
#line 3069
			status = lstatus;
#line 3069
	}
#line 3069

#line 3069
	*xpp = (const void *)xp;
#line 3069
	return status;
#line 3069
#endif
#line 3069
}
#line 3069

#endif
int
#line 3071
ncx_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 3071
{
#line 3071
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3071

#line 3071
 /* basic algorithm is:
#line 3071
  *   - ensure sane alignment of input data
#line 3071
  *   - copy (conversion happens automatically) input data
#line 3071
  *     to output
#line 3071
  *   - update xpp to point at next unconverted input, and tp to point
#line 3071
  *     at next location for converted output
#line 3071
  */
#line 3071
  long i, j, ni;
#line 3071
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3071
  short *xp;
#line 3071
  int nrange = 0;         /* number of range errors */
#line 3071
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3071
  long cxp = (long) *((char**)xpp);
#line 3071

#line 3071
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3071
  /* sjl: manually stripmine so we can limit amount of
#line 3071
   * vector work space reserved to LOOPCNT elements. Also
#line 3071
   * makes vectorisation easy */
#line 3071
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3071
    ni=Min(nelems-j,LOOPCNT);
#line 3071
    if (realign) {
#line 3071
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3071
      xp = tmp;
#line 3071
    } else {
#line 3071
      xp = (short *) *xpp;
#line 3071
    }
#line 3071
   /* copy the next block */
#line 3071
#pragma cdir loopcnt=LOOPCNT
#line 3071
#pragma cdir shortloop
#line 3071
    for (i=0; i<ni; i++) {
#line 3071
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3071
     /* test for range errors (not always needed but do it anyway) */
#line 3071
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3071
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3071
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3071
    }
#line 3071
   /* update xpp and tp */
#line 3071
    if (realign) xp = (short *) *xpp;
#line 3071
    xp += ni;
#line 3071
    tp += ni;
#line 3071
    *xpp = (void*)xp;
#line 3071
  }
#line 3071
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3071

#line 3071
#else   /* not SX */
#line 3071
	const char *xp = (const char *) *xpp;
#line 3071
	int status = NC_NOERR;
#line 3071

#line 3071
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3071
	{
#line 3071
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 3071
		if (status == NC_NOERR) /* report the first encountered error */
#line 3071
			status = lstatus;
#line 3071
	}
#line 3071

#line 3071
	*xpp = (const void *)xp;
#line 3071
	return status;
#line 3071
#endif
#line 3071
}
#line 3071

int
#line 3072
ncx_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 3072
{
#line 3072
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3072

#line 3072
 /* basic algorithm is:
#line 3072
  *   - ensure sane alignment of input data
#line 3072
  *   - copy (conversion happens automatically) input data
#line 3072
  *     to output
#line 3072
  *   - update xpp to point at next unconverted input, and tp to point
#line 3072
  *     at next location for converted output
#line 3072
  */
#line 3072
  long i, j, ni;
#line 3072
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3072
  short *xp;
#line 3072
  int nrange = 0;         /* number of range errors */
#line 3072
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3072
  long cxp = (long) *((char**)xpp);
#line 3072

#line 3072
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3072
  /* sjl: manually stripmine so we can limit amount of
#line 3072
   * vector work space reserved to LOOPCNT elements. Also
#line 3072
   * makes vectorisation easy */
#line 3072
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3072
    ni=Min(nelems-j,LOOPCNT);
#line 3072
    if (realign) {
#line 3072
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3072
      xp = tmp;
#line 3072
    } else {
#line 3072
      xp = (short *) *xpp;
#line 3072
    }
#line 3072
   /* copy the next block */
#line 3072
#pragma cdir loopcnt=LOOPCNT
#line 3072
#pragma cdir shortloop
#line 3072
    for (i=0; i<ni; i++) {
#line 3072
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3072
     /* test for range errors (not always needed but do it anyway) */
#line 3072
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3072
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3072
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3072
    }
#line 3072
   /* update xpp and tp */
#line 3072
    if (realign) xp = (short *) *xpp;
#line 3072
    xp += ni;
#line 3072
    tp += ni;
#line 3072
    *xpp = (void*)xp;
#line 3072
  }
#line 3072
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3072

#line 3072
#else   /* not SX */
#line 3072
	const char *xp = (const char *) *xpp;
#line 3072
	int status = NC_NOERR;
#line 3072

#line 3072
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3072
	{
#line 3072
		const int lstatus = ncx_get_short_int(xp, tp);
#line 3072
		if (status == NC_NOERR) /* report the first encountered error */
#line 3072
			status = lstatus;
#line 3072
	}
#line 3072

#line 3072
	*xpp = (const void *)xp;
#line 3072
	return status;
#line 3072
#endif
#line 3072
}
#line 3072

int
#line 3073
ncx_getn_short_long(const void **xpp, size_t nelems, long *tp)
#line 3073
{
#line 3073
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3073

#line 3073
 /* basic algorithm is:
#line 3073
  *   - ensure sane alignment of input data
#line 3073
  *   - copy (conversion happens automatically) input data
#line 3073
  *     to output
#line 3073
  *   - update xpp to point at next unconverted input, and tp to point
#line 3073
  *     at next location for converted output
#line 3073
  */
#line 3073
  long i, j, ni;
#line 3073
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3073
  short *xp;
#line 3073
  int nrange = 0;         /* number of range errors */
#line 3073
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3073
  long cxp = (long) *((char**)xpp);
#line 3073

#line 3073
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3073
  /* sjl: manually stripmine so we can limit amount of
#line 3073
   * vector work space reserved to LOOPCNT elements. Also
#line 3073
   * makes vectorisation easy */
#line 3073
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3073
    ni=Min(nelems-j,LOOPCNT);
#line 3073
    if (realign) {
#line 3073
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3073
      xp = tmp;
#line 3073
    } else {
#line 3073
      xp = (short *) *xpp;
#line 3073
    }
#line 3073
   /* copy the next block */
#line 3073
#pragma cdir loopcnt=LOOPCNT
#line 3073
#pragma cdir shortloop
#line 3073
    for (i=0; i<ni; i++) {
#line 3073
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3073
     /* test for range errors (not always needed but do it anyway) */
#line 3073
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3073
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3073
      nrange += xp[i] > LONG_MAX || xp[i] < LONG_MIN;
#line 3073
    }
#line 3073
   /* update xpp and tp */
#line 3073
    if (realign) xp = (short *) *xpp;
#line 3073
    xp += ni;
#line 3073
    tp += ni;
#line 3073
    *xpp = (void*)xp;
#line 3073
  }
#line 3073
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3073

#line 3073
#else   /* not SX */
#line 3073
	const char *xp = (const char *) *xpp;
#line 3073
	int status = NC_NOERR;
#line 3073

#line 3073
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3073
	{
#line 3073
		const int lstatus = ncx_get_short_long(xp, tp);
#line 3073
		if (status == NC_NOERR) /* report the first encountered error */
#line 3073
			status = lstatus;
#line 3073
	}
#line 3073

#line 3073
	*xpp = (const void *)xp;
#line 3073
	return status;
#line 3073
#endif
#line 3073
}
#line 3073

int
#line 3074
ncx_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 3074
{
#line 3074
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3074

#line 3074
 /* basic algorithm is:
#line 3074
  *   - ensure sane alignment of input data
#line 3074
  *   - copy (conversion happens automatically) input data
#line 3074
  *     to output
#line 3074
  *   - update xpp to point at next unconverted input, and tp to point
#line 3074
  *     at next location for converted output
#line 3074
  */
#line 3074
  long i, j, ni;
#line 3074
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3074
  short *xp;
#line 3074
  int nrange = 0;         /* number of range errors */
#line 3074
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3074
  long cxp = (long) *((char**)xpp);
#line 3074

#line 3074
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3074
  /* sjl: manually stripmine so we can limit amount of
#line 3074
   * vector work space reserved to LOOPCNT elements. Also
#line 3074
   * makes vectorisation easy */
#line 3074
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3074
    ni=Min(nelems-j,LOOPCNT);
#line 3074
    if (realign) {
#line 3074
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3074
      xp = tmp;
#line 3074
    } else {
#line 3074
      xp = (short *) *xpp;
#line 3074
    }
#line 3074
   /* copy the next block */
#line 3074
#pragma cdir loopcnt=LOOPCNT
#line 3074
#pragma cdir shortloop
#line 3074
    for (i=0; i<ni; i++) {
#line 3074
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3074
     /* test for range errors (not always needed but do it anyway) */
#line 3074
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3074
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3074
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3074
    }
#line 3074
   /* update xpp and tp */
#line 3074
    if (realign) xp = (short *) *xpp;
#line 3074
    xp += ni;
#line 3074
    tp += ni;
#line 3074
    *xpp = (void*)xp;
#line 3074
  }
#line 3074
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3074

#line 3074
#else   /* not SX */
#line 3074
	const char *xp = (const char *) *xpp;
#line 3074
	int status = NC_NOERR;
#line 3074

#line 3074
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3074
	{
#line 3074
		const int lstatus = ncx_get_short_float(xp, tp);
#line 3074
		if (status == NC_NOERR) /* report the first encountered error */
#line 3074
			status = lstatus;
#line 3074
	}
#line 3074

#line 3074
	*xpp = (const void *)xp;
#line 3074
	return status;
#line 3074
#endif
#line 3074
}
#line 3074

int
#line 3075
ncx_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 3075
{
#line 3075
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3075

#line 3075
 /* basic algorithm is:
#line 3075
  *   - ensure sane alignment of input data
#line 3075
  *   - copy (conversion happens automatically) input data
#line 3075
  *     to output
#line 3075
  *   - update xpp to point at next unconverted input, and tp to point
#line 3075
  *     at next location for converted output
#line 3075
  */
#line 3075
  long i, j, ni;
#line 3075
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3075
  short *xp;
#line 3075
  int nrange = 0;         /* number of range errors */
#line 3075
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3075
  long cxp = (long) *((char**)xpp);
#line 3075

#line 3075
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3075
  /* sjl: manually stripmine so we can limit amount of
#line 3075
   * vector work space reserved to LOOPCNT elements. Also
#line 3075
   * makes vectorisation easy */
#line 3075
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3075
    ni=Min(nelems-j,LOOPCNT);
#line 3075
    if (realign) {
#line 3075
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3075
      xp = tmp;
#line 3075
    } else {
#line 3075
      xp = (short *) *xpp;
#line 3075
    }
#line 3075
   /* copy the next block */
#line 3075
#pragma cdir loopcnt=LOOPCNT
#line 3075
#pragma cdir shortloop
#line 3075
    for (i=0; i<ni; i++) {
#line 3075
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3075
     /* test for range errors (not always needed but do it anyway) */
#line 3075
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3075
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3075
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3075
    }
#line 3075
   /* update xpp and tp */
#line 3075
    if (realign) xp = (short *) *xpp;
#line 3075
    xp += ni;
#line 3075
    tp += ni;
#line 3075
    *xpp = (void*)xp;
#line 3075
  }
#line 3075
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3075

#line 3075
#else   /* not SX */
#line 3075
	const char *xp = (const char *) *xpp;
#line 3075
	int status = NC_NOERR;
#line 3075

#line 3075
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3075
	{
#line 3075
		const int lstatus = ncx_get_short_double(xp, tp);
#line 3075
		if (status == NC_NOERR) /* report the first encountered error */
#line 3075
			status = lstatus;
#line 3075
	}
#line 3075

#line 3075
	*xpp = (const void *)xp;
#line 3075
	return status;
#line 3075
#endif
#line 3075
}
#line 3075

int
#line 3076
ncx_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3076
{
#line 3076
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3076

#line 3076
 /* basic algorithm is:
#line 3076
  *   - ensure sane alignment of input data
#line 3076
  *   - copy (conversion happens automatically) input data
#line 3076
  *     to output
#line 3076
  *   - update xpp to point at next unconverted input, and tp to point
#line 3076
  *     at next location for converted output
#line 3076
  */
#line 3076
  long i, j, ni;
#line 3076
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3076
  short *xp;
#line 3076
  int nrange = 0;         /* number of range errors */
#line 3076
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3076
  long cxp = (long) *((char**)xpp);
#line 3076

#line 3076
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3076
  /* sjl: manually stripmine so we can limit amount of
#line 3076
   * vector work space reserved to LOOPCNT elements. Also
#line 3076
   * makes vectorisation easy */
#line 3076
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3076
    ni=Min(nelems-j,LOOPCNT);
#line 3076
    if (realign) {
#line 3076
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3076
      xp = tmp;
#line 3076
    } else {
#line 3076
      xp = (short *) *xpp;
#line 3076
    }
#line 3076
   /* copy the next block */
#line 3076
#pragma cdir loopcnt=LOOPCNT
#line 3076
#pragma cdir shortloop
#line 3076
    for (i=0; i<ni; i++) {
#line 3076
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3076
     /* test for range errors (not always needed but do it anyway) */
#line 3076
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3076
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3076
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3076
    }
#line 3076
   /* update xpp and tp */
#line 3076
    if (realign) xp = (short *) *xpp;
#line 3076
    xp += ni;
#line 3076
    tp += ni;
#line 3076
    *xpp = (void*)xp;
#line 3076
  }
#line 3076
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3076

#line 3076
#else   /* not SX */
#line 3076
	const char *xp = (const char *) *xpp;
#line 3076
	int status = NC_NOERR;
#line 3076

#line 3076
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3076
	{
#line 3076
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 3076
		if (status == NC_NOERR) /* report the first encountered error */
#line 3076
			status = lstatus;
#line 3076
	}
#line 3076

#line 3076
	*xpp = (const void *)xp;
#line 3076
	return status;
#line 3076
#endif
#line 3076
}
#line 3076

int
#line 3077
ncx_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3077
{
#line 3077
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3077

#line 3077
 /* basic algorithm is:
#line 3077
  *   - ensure sane alignment of input data
#line 3077
  *   - copy (conversion happens automatically) input data
#line 3077
  *     to output
#line 3077
  *   - update xpp to point at next unconverted input, and tp to point
#line 3077
  *     at next location for converted output
#line 3077
  */
#line 3077
  long i, j, ni;
#line 3077
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3077
  short *xp;
#line 3077
  int nrange = 0;         /* number of range errors */
#line 3077
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3077
  long cxp = (long) *((char**)xpp);
#line 3077

#line 3077
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3077
  /* sjl: manually stripmine so we can limit amount of
#line 3077
   * vector work space reserved to LOOPCNT elements. Also
#line 3077
   * makes vectorisation easy */
#line 3077
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3077
    ni=Min(nelems-j,LOOPCNT);
#line 3077
    if (realign) {
#line 3077
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3077
      xp = tmp;
#line 3077
    } else {
#line 3077
      xp = (short *) *xpp;
#line 3077
    }
#line 3077
   /* copy the next block */
#line 3077
#pragma cdir loopcnt=LOOPCNT
#line 3077
#pragma cdir shortloop
#line 3077
    for (i=0; i<ni; i++) {
#line 3077
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3077
     /* test for range errors (not always needed but do it anyway) */
#line 3077
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3077
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3077
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3077
    }
#line 3077
   /* update xpp and tp */
#line 3077
    if (realign) xp = (short *) *xpp;
#line 3077
    xp += ni;
#line 3077
    tp += ni;
#line 3077
    *xpp = (void*)xp;
#line 3077
  }
#line 3077
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3077

#line 3077
#else   /* not SX */
#line 3077
	const char *xp = (const char *) *xpp;
#line 3077
	int status = NC_NOERR;
#line 3077

#line 3077
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3077
	{
#line 3077
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 3077
		if (status == NC_NOERR) /* report the first encountered error */
#line 3077
			status = lstatus;
#line 3077
	}
#line 3077

#line 3077
	*xpp = (const void *)xp;
#line 3077
	return status;
#line 3077
#endif
#line 3077
}
#line 3077

int
#line 3078
ncx_getn_short_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3078
{
#line 3078
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3078

#line 3078
 /* basic algorithm is:
#line 3078
  *   - ensure sane alignment of input data
#line 3078
  *   - copy (conversion happens automatically) input data
#line 3078
  *     to output
#line 3078
  *   - update xpp to point at next unconverted input, and tp to point
#line 3078
  *     at next location for converted output
#line 3078
  */
#line 3078
  long i, j, ni;
#line 3078
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3078
  short *xp;
#line 3078
  int nrange = 0;         /* number of range errors */
#line 3078
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3078
  long cxp = (long) *((char**)xpp);
#line 3078

#line 3078
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3078
  /* sjl: manually stripmine so we can limit amount of
#line 3078
   * vector work space reserved to LOOPCNT elements. Also
#line 3078
   * makes vectorisation easy */
#line 3078
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3078
    ni=Min(nelems-j,LOOPCNT);
#line 3078
    if (realign) {
#line 3078
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3078
      xp = tmp;
#line 3078
    } else {
#line 3078
      xp = (short *) *xpp;
#line 3078
    }
#line 3078
   /* copy the next block */
#line 3078
#pragma cdir loopcnt=LOOPCNT
#line 3078
#pragma cdir shortloop
#line 3078
    for (i=0; i<ni; i++) {
#line 3078
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3078
     /* test for range errors (not always needed but do it anyway) */
#line 3078
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3078
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3078
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3078
    }
#line 3078
   /* update xpp and tp */
#line 3078
    if (realign) xp = (short *) *xpp;
#line 3078
    xp += ni;
#line 3078
    tp += ni;
#line 3078
    *xpp = (void*)xp;
#line 3078
  }
#line 3078
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3078

#line 3078
#else   /* not SX */
#line 3078
	const char *xp = (const char *) *xpp;
#line 3078
	int status = NC_NOERR;
#line 3078

#line 3078
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3078
	{
#line 3078
		const int lstatus = ncx_get_short_ushort(xp, tp);
#line 3078
		if (status == NC_NOERR) /* report the first encountered error */
#line 3078
			status = lstatus;
#line 3078
	}
#line 3078

#line 3078
	*xpp = (const void *)xp;
#line 3078
	return status;
#line 3078
#endif
#line 3078
}
#line 3078

int
#line 3079
ncx_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 3079
{
#line 3079
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3079

#line 3079
 /* basic algorithm is:
#line 3079
  *   - ensure sane alignment of input data
#line 3079
  *   - copy (conversion happens automatically) input data
#line 3079
  *     to output
#line 3079
  *   - update xpp to point at next unconverted input, and tp to point
#line 3079
  *     at next location for converted output
#line 3079
  */
#line 3079
  long i, j, ni;
#line 3079
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3079
  short *xp;
#line 3079
  int nrange = 0;         /* number of range errors */
#line 3079
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3079
  long cxp = (long) *((char**)xpp);
#line 3079

#line 3079
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3079
  /* sjl: manually stripmine so we can limit amount of
#line 3079
   * vector work space reserved to LOOPCNT elements. Also
#line 3079
   * makes vectorisation easy */
#line 3079
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3079
    ni=Min(nelems-j,LOOPCNT);
#line 3079
    if (realign) {
#line 3079
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3079
      xp = tmp;
#line 3079
    } else {
#line 3079
      xp = (short *) *xpp;
#line 3079
    }
#line 3079
   /* copy the next block */
#line 3079
#pragma cdir loopcnt=LOOPCNT
#line 3079
#pragma cdir shortloop
#line 3079
    for (i=0; i<ni; i++) {
#line 3079
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3079
     /* test for range errors (not always needed but do it anyway) */
#line 3079
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3079
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3079
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3079
    }
#line 3079
   /* update xpp and tp */
#line 3079
    if (realign) xp = (short *) *xpp;
#line 3079
    xp += ni;
#line 3079
    tp += ni;
#line 3079
    *xpp = (void*)xp;
#line 3079
  }
#line 3079
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3079

#line 3079
#else   /* not SX */
#line 3079
	const char *xp = (const char *) *xpp;
#line 3079
	int status = NC_NOERR;
#line 3079

#line 3079
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3079
	{
#line 3079
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 3079
		if (status == NC_NOERR) /* report the first encountered error */
#line 3079
			status = lstatus;
#line 3079
	}
#line 3079

#line 3079
	*xpp = (const void *)xp;
#line 3079
	return status;
#line 3079
#endif
#line 3079
}
#line 3079

int
#line 3080
ncx_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3080
{
#line 3080
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3080

#line 3080
 /* basic algorithm is:
#line 3080
  *   - ensure sane alignment of input data
#line 3080
  *   - copy (conversion happens automatically) input data
#line 3080
  *     to output
#line 3080
  *   - update xpp to point at next unconverted input, and tp to point
#line 3080
  *     at next location for converted output
#line 3080
  */
#line 3080
  long i, j, ni;
#line 3080
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3080
  short *xp;
#line 3080
  int nrange = 0;         /* number of range errors */
#line 3080
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3080
  long cxp = (long) *((char**)xpp);
#line 3080

#line 3080
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3080
  /* sjl: manually stripmine so we can limit amount of
#line 3080
   * vector work space reserved to LOOPCNT elements. Also
#line 3080
   * makes vectorisation easy */
#line 3080
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3080
    ni=Min(nelems-j,LOOPCNT);
#line 3080
    if (realign) {
#line 3080
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3080
      xp = tmp;
#line 3080
    } else {
#line 3080
      xp = (short *) *xpp;
#line 3080
    }
#line 3080
   /* copy the next block */
#line 3080
#pragma cdir loopcnt=LOOPCNT
#line 3080
#pragma cdir shortloop
#line 3080
    for (i=0; i<ni; i++) {
#line 3080
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3080
     /* test for range errors (not always needed but do it anyway) */
#line 3080
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3080
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3080
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3080
    }
#line 3080
   /* update xpp and tp */
#line 3080
    if (realign) xp = (short *) *xpp;
#line 3080
    xp += ni;
#line 3080
    tp += ni;
#line 3080
    *xpp = (void*)xp;
#line 3080
  }
#line 3080
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3080

#line 3080
#else   /* not SX */
#line 3080
	const char *xp = (const char *) *xpp;
#line 3080
	int status = NC_NOERR;
#line 3080

#line 3080
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3080
	{
#line 3080
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 3080
		if (status == NC_NOERR) /* report the first encountered error */
#line 3080
			status = lstatus;
#line 3080
	}
#line 3080

#line 3080
	*xpp = (const void *)xp;
#line 3080
	return status;
#line 3080
#endif
#line 3080
}
#line 3080


int
#line 3082
ncx_pad_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 3082
{
#line 3082
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3082

#line 3082
	const char *xp = (const char *) *xpp;
#line 3082
	int status = NC_NOERR;
#line 3082

#line 3082
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3082
	{
#line 3082
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 3082
		if (status == NC_NOERR) /* report the first encountered error */
#line 3082
			status = lstatus;
#line 3082
	}
#line 3082

#line 3082
	if (rndup != 0)
#line 3082
		xp += X_SIZEOF_SHORT;
#line 3082

#line 3082
	*xpp = (void *)xp;
#line 3082
	return status;
#line 3082
}
#line 3082

int
#line 3083
ncx_pad_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3083
{
#line 3083
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3083

#line 3083
	const char *xp = (const char *) *xpp;
#line 3083
	int status = NC_NOERR;
#line 3083

#line 3083
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3083
	{
#line 3083
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 3083
		if (status == NC_NOERR) /* report the first encountered error */
#line 3083
			status = lstatus;
#line 3083
	}
#line 3083

#line 3083
	if (rndup != 0)
#line 3083
		xp += X_SIZEOF_SHORT;
#line 3083

#line 3083
	*xpp = (void *)xp;
#line 3083
	return status;
#line 3083
}
#line 3083

int
#line 3084
ncx_pad_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 3084
{
#line 3084
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3084

#line 3084
	const char *xp = (const char *) *xpp;
#line 3084
	int status = NC_NOERR;
#line 3084

#line 3084
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3084
	{
#line 3084
		const int lstatus = ncx_get_short_short(xp, tp);
#line 3084
		if (status == NC_NOERR) /* report the first encountered error */
#line 3084
			status = lstatus;
#line 3084
	}
#line 3084

#line 3084
	if (rndup != 0)
#line 3084
		xp += X_SIZEOF_SHORT;
#line 3084

#line 3084
	*xpp = (void *)xp;
#line 3084
	return status;
#line 3084
}
#line 3084

int
#line 3085
ncx_pad_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 3085
{
#line 3085
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3085

#line 3085
	const char *xp = (const char *) *xpp;
#line 3085
	int status = NC_NOERR;
#line 3085

#line 3085
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3085
	{
#line 3085
		const int lstatus = ncx_get_short_int(xp, tp);
#line 3085
		if (status == NC_NOERR) /* report the first encountered error */
#line 3085
			status = lstatus;
#line 3085
	}
#line 3085

#line 3085
	if (rndup != 0)
#line 3085
		xp += X_SIZEOF_SHORT;
#line 3085

#line 3085
	*xpp = (void *)xp;
#line 3085
	return status;
#line 3085
}
#line 3085

int
#line 3086
ncx_pad_getn_short_long(const void **xpp, size_t nelems, long *tp)
#line 3086
{
#line 3086
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3086

#line 3086
	const char *xp = (const char *) *xpp;
#line 3086
	int status = NC_NOERR;
#line 3086

#line 3086
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3086
	{
#line 3086
		const int lstatus = ncx_get_short_long(xp, tp);
#line 3086
		if (status == NC_NOERR) /* report the first encountered error */
#line 3086
			status = lstatus;
#line 3086
	}
#line 3086

#line 3086
	if (rndup != 0)
#line 3086
		xp += X_SIZEOF_SHORT;
#line 3086

#line 3086
	*xpp = (void *)xp;
#line 3086
	return status;
#line 3086
}
#line 3086

int
#line 3087
ncx_pad_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 3087
{
#line 3087
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3087

#line 3087
	const char *xp = (const char *) *xpp;
#line 3087
	int status = NC_NOERR;
#line 3087

#line 3087
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3087
	{
#line 3087
		const int lstatus = ncx_get_short_float(xp, tp);
#line 3087
		if (status == NC_NOERR) /* report the first encountered error */
#line 3087
			status = lstatus;
#line 3087
	}
#line 3087

#line 3087
	if (rndup != 0)
#line 3087
		xp += X_SIZEOF_SHORT;
#line 3087

#line 3087
	*xpp = (void *)xp;
#line 3087
	return status;
#line 3087
}
#line 3087

int
#line 3088
ncx_pad_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 3088
{
#line 3088
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3088

#line 3088
	const char *xp = (const char *) *xpp;
#line 3088
	int status = NC_NOERR;
#line 3088

#line 3088
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3088
	{
#line 3088
		const int lstatus = ncx_get_short_double(xp, tp);
#line 3088
		if (status == NC_NOERR) /* report the first encountered error */
#line 3088
			status = lstatus;
#line 3088
	}
#line 3088

#line 3088
	if (rndup != 0)
#line 3088
		xp += X_SIZEOF_SHORT;
#line 3088

#line 3088
	*xpp = (void *)xp;
#line 3088
	return status;
#line 3088
}
#line 3088

int
#line 3089
ncx_pad_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 3089
{
#line 3089
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3089

#line 3089
	const char *xp = (const char *) *xpp;
#line 3089
	int status = NC_NOERR;
#line 3089

#line 3089
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3089
	{
#line 3089
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 3089
		if (status == NC_NOERR) /* report the first encountered error */
#line 3089
			status = lstatus;
#line 3089
	}
#line 3089

#line 3089
	if (rndup != 0)
#line 3089
		xp += X_SIZEOF_SHORT;
#line 3089

#line 3089
	*xpp = (void *)xp;
#line 3089
	return status;
#line 3089
}
#line 3089

int
#line 3090
ncx_pad_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3090
{
#line 3090
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3090

#line 3090
	const char *xp = (const char *) *xpp;
#line 3090
	int status = NC_NOERR;
#line 3090

#line 3090
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3090
	{
#line 3090
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 3090
		if (status == NC_NOERR) /* report the first encountered error */
#line 3090
			status = lstatus;
#line 3090
	}
#line 3090

#line 3090
	if (rndup != 0)
#line 3090
		xp += X_SIZEOF_SHORT;
#line 3090

#line 3090
	*xpp = (void *)xp;
#line 3090
	return status;
#line 3090
}
#line 3090

int
#line 3091
ncx_pad_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3091
{
#line 3091
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3091

#line 3091
	const char *xp = (const char *) *xpp;
#line 3091
	int status = NC_NOERR;
#line 3091

#line 3091
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3091
	{
#line 3091
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 3091
		if (status == NC_NOERR) /* report the first encountered error */
#line 3091
			status = lstatus;
#line 3091
	}
#line 3091

#line 3091
	if (rndup != 0)
#line 3091
		xp += X_SIZEOF_SHORT;
#line 3091

#line 3091
	*xpp = (void *)xp;
#line 3091
	return status;
#line 3091
}
#line 3091

int
#line 3092
ncx_pad_getn_short_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3092
{
#line 3092
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3092

#line 3092
	const char *xp = (const char *) *xpp;
#line 3092
	int status = NC_NOERR;
#line 3092

#line 3092
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3092
	{
#line 3092
		const int lstatus = ncx_get_short_ushort(xp, tp);
#line 3092
		if (status == NC_NOERR) /* report the first encountered error */
#line 3092
			status = lstatus;
#line 3092
	}
#line 3092

#line 3092
	if (rndup != 0)
#line 3092
		xp += X_SIZEOF_SHORT;
#line 3092

#line 3092
	*xpp = (void *)xp;
#line 3092
	return status;
#line 3092
}
#line 3092


#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_SHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return NC_NOERR;
}
#else
int
#line 3108
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3108
{
#line 3108
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3108

#line 3108
 /* basic algorithm is:
#line 3108
  *   - ensure sane alignment of output data
#line 3108
  *   - copy (conversion happens automatically) input data
#line 3108
  *     to output
#line 3108
  *   - update tp to point at next unconverted input, and xpp to point
#line 3108
  *     at next location for converted output
#line 3108
  */
#line 3108
  long i, j, ni;
#line 3108
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3108
  short *xp;
#line 3108
  int nrange = 0;         /* number of range errors */
#line 3108
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3108
  long cxp = (long) *((char**)xpp);
#line 3108

#line 3108
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3108
  /* sjl: manually stripmine so we can limit amount of
#line 3108
   * vector work space reserved to LOOPCNT elements. Also
#line 3108
   * makes vectorisation easy */
#line 3108
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3108
    ni=Min(nelems-j,LOOPCNT);
#line 3108
    if (realign) {
#line 3108
      xp = tmp;
#line 3108
    } else {
#line 3108
      xp = (short *) *xpp;
#line 3108
    }
#line 3108
   /* copy the next block */
#line 3108
#pragma cdir loopcnt=LOOPCNT
#line 3108
#pragma cdir shortloop
#line 3108
    for (i=0; i<ni; i++) {
#line 3108
      /* the normal case: */
#line 3108
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3108
     /* test for range errors (not always needed but do it anyway) */
#line 3108
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3108
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3108
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3108
    }
#line 3108
   /* copy workspace back if necessary */
#line 3108
    if (realign) {
#line 3108
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3108
      xp = (short *) *xpp;
#line 3108
    }
#line 3108
   /* update xpp and tp */
#line 3108
    xp += ni;
#line 3108
    tp += ni;
#line 3108
    *xpp = (void*)xp;
#line 3108
  }
#line 3108
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3108

#line 3108
#else   /* not SX */
#line 3108

#line 3108
	char *xp = (char *) *xpp;
#line 3108
	int status = NC_NOERR;
#line 3108

#line 3108
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3108
	{
#line 3108
		int lstatus = ncx_put_short_short(xp, tp, fillp);
#line 3108
		if (status == NC_NOERR) /* report the first encountered error */
#line 3108
			status = lstatus;
#line 3108
	}
#line 3108

#line 3108
	*xpp = (void *)xp;
#line 3108
	return status;
#line 3108
#endif
#line 3108
}
#line 3108

#endif
int
#line 3110
ncx_putn_short_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3110
{
#line 3110
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3110

#line 3110
 /* basic algorithm is:
#line 3110
  *   - ensure sane alignment of output data
#line 3110
  *   - copy (conversion happens automatically) input data
#line 3110
  *     to output
#line 3110
  *   - update tp to point at next unconverted input, and xpp to point
#line 3110
  *     at next location for converted output
#line 3110
  */
#line 3110
  long i, j, ni;
#line 3110
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3110
  short *xp;
#line 3110
  int nrange = 0;         /* number of range errors */
#line 3110
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3110
  long cxp = (long) *((char**)xpp);
#line 3110

#line 3110
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3110
  /* sjl: manually stripmine so we can limit amount of
#line 3110
   * vector work space reserved to LOOPCNT elements. Also
#line 3110
   * makes vectorisation easy */
#line 3110
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3110
    ni=Min(nelems-j,LOOPCNT);
#line 3110
    if (realign) {
#line 3110
      xp = tmp;
#line 3110
    } else {
#line 3110
      xp = (short *) *xpp;
#line 3110
    }
#line 3110
   /* copy the next block */
#line 3110
#pragma cdir loopcnt=LOOPCNT
#line 3110
#pragma cdir shortloop
#line 3110
    for (i=0; i<ni; i++) {
#line 3110
      /* the normal case: */
#line 3110
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3110
     /* test for range errors (not always needed but do it anyway) */
#line 3110
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3110
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3110
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3110
    }
#line 3110
   /* copy workspace back if necessary */
#line 3110
    if (realign) {
#line 3110
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3110
      xp = (short *) *xpp;
#line 3110
    }
#line 3110
   /* update xpp and tp */
#line 3110
    xp += ni;
#line 3110
    tp += ni;
#line 3110
    *xpp = (void*)xp;
#line 3110
  }
#line 3110
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3110

#line 3110
#else   /* not SX */
#line 3110

#line 3110
	char *xp = (char *) *xpp;
#line 3110
	int status = NC_NOERR;
#line 3110

#line 3110
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3110
	{
#line 3110
		int lstatus = ncx_put_short_schar(xp, tp, fillp);
#line 3110
		if (status == NC_NOERR) /* report the first encountered error */
#line 3110
			status = lstatus;
#line 3110
	}
#line 3110

#line 3110
	*xpp = (void *)xp;
#line 3110
	return status;
#line 3110
#endif
#line 3110
}
#line 3110

int
#line 3111
ncx_putn_short_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3111
{
#line 3111
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3111

#line 3111
 /* basic algorithm is:
#line 3111
  *   - ensure sane alignment of output data
#line 3111
  *   - copy (conversion happens automatically) input data
#line 3111
  *     to output
#line 3111
  *   - update tp to point at next unconverted input, and xpp to point
#line 3111
  *     at next location for converted output
#line 3111
  */
#line 3111
  long i, j, ni;
#line 3111
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3111
  short *xp;
#line 3111
  int nrange = 0;         /* number of range errors */
#line 3111
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3111
  long cxp = (long) *((char**)xpp);
#line 3111

#line 3111
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3111
  /* sjl: manually stripmine so we can limit amount of
#line 3111
   * vector work space reserved to LOOPCNT elements. Also
#line 3111
   * makes vectorisation easy */
#line 3111
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3111
    ni=Min(nelems-j,LOOPCNT);
#line 3111
    if (realign) {
#line 3111
      xp = tmp;
#line 3111
    } else {
#line 3111
      xp = (short *) *xpp;
#line 3111
    }
#line 3111
   /* copy the next block */
#line 3111
#pragma cdir loopcnt=LOOPCNT
#line 3111
#pragma cdir shortloop
#line 3111
    for (i=0; i<ni; i++) {
#line 3111
      /* the normal case: */
#line 3111
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3111
     /* test for range errors (not always needed but do it anyway) */
#line 3111
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3111
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3111
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3111
    }
#line 3111
   /* copy workspace back if necessary */
#line 3111
    if (realign) {
#line 3111
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3111
      xp = (short *) *xpp;
#line 3111
    }
#line 3111
   /* update xpp and tp */
#line 3111
    xp += ni;
#line 3111
    tp += ni;
#line 3111
    *xpp = (void*)xp;
#line 3111
  }
#line 3111
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3111

#line 3111
#else   /* not SX */
#line 3111

#line 3111
	char *xp = (char *) *xpp;
#line 3111
	int status = NC_NOERR;
#line 3111

#line 3111
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3111
	{
#line 3111
		int lstatus = ncx_put_short_int(xp, tp, fillp);
#line 3111
		if (status == NC_NOERR) /* report the first encountered error */
#line 3111
			status = lstatus;
#line 3111
	}
#line 3111

#line 3111
	*xpp = (void *)xp;
#line 3111
	return status;
#line 3111
#endif
#line 3111
}
#line 3111

int
#line 3112
ncx_putn_short_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3112
{
#line 3112
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3112

#line 3112
 /* basic algorithm is:
#line 3112
  *   - ensure sane alignment of output data
#line 3112
  *   - copy (conversion happens automatically) input data
#line 3112
  *     to output
#line 3112
  *   - update tp to point at next unconverted input, and xpp to point
#line 3112
  *     at next location for converted output
#line 3112
  */
#line 3112
  long i, j, ni;
#line 3112
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3112
  short *xp;
#line 3112
  int nrange = 0;         /* number of range errors */
#line 3112
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3112
  long cxp = (long) *((char**)xpp);
#line 3112

#line 3112
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3112
  /* sjl: manually stripmine so we can limit amount of
#line 3112
   * vector work space reserved to LOOPCNT elements. Also
#line 3112
   * makes vectorisation easy */
#line 3112
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3112
    ni=Min(nelems-j,LOOPCNT);
#line 3112
    if (realign) {
#line 3112
      xp = tmp;
#line 3112
    } else {
#line 3112
      xp = (short *) *xpp;
#line 3112
    }
#line 3112
   /* copy the next block */
#line 3112
#pragma cdir loopcnt=LOOPCNT
#line 3112
#pragma cdir shortloop
#line 3112
    for (i=0; i<ni; i++) {
#line 3112
      /* the normal case: */
#line 3112
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3112
     /* test for range errors (not always needed but do it anyway) */
#line 3112
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3112
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3112
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3112
    }
#line 3112
   /* copy workspace back if necessary */
#line 3112
    if (realign) {
#line 3112
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3112
      xp = (short *) *xpp;
#line 3112
    }
#line 3112
   /* update xpp and tp */
#line 3112
    xp += ni;
#line 3112
    tp += ni;
#line 3112
    *xpp = (void*)xp;
#line 3112
  }
#line 3112
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3112

#line 3112
#else   /* not SX */
#line 3112

#line 3112
	char *xp = (char *) *xpp;
#line 3112
	int status = NC_NOERR;
#line 3112

#line 3112
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3112
	{
#line 3112
		int lstatus = ncx_put_short_long(xp, tp, fillp);
#line 3112
		if (status == NC_NOERR) /* report the first encountered error */
#line 3112
			status = lstatus;
#line 3112
	}
#line 3112

#line 3112
	*xpp = (void *)xp;
#line 3112
	return status;
#line 3112
#endif
#line 3112
}
#line 3112

int
#line 3113
ncx_putn_short_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3113
{
#line 3113
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3113

#line 3113
 /* basic algorithm is:
#line 3113
  *   - ensure sane alignment of output data
#line 3113
  *   - copy (conversion happens automatically) input data
#line 3113
  *     to output
#line 3113
  *   - update tp to point at next unconverted input, and xpp to point
#line 3113
  *     at next location for converted output
#line 3113
  */
#line 3113
  long i, j, ni;
#line 3113
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3113
  short *xp;
#line 3113
  int nrange = 0;         /* number of range errors */
#line 3113
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3113
  long cxp = (long) *((char**)xpp);
#line 3113

#line 3113
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3113
  /* sjl: manually stripmine so we can limit amount of
#line 3113
   * vector work space reserved to LOOPCNT elements. Also
#line 3113
   * makes vectorisation easy */
#line 3113
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3113
    ni=Min(nelems-j,LOOPCNT);
#line 3113
    if (realign) {
#line 3113
      xp = tmp;
#line 3113
    } else {
#line 3113
      xp = (short *) *xpp;
#line 3113
    }
#line 3113
   /* copy the next block */
#line 3113
#pragma cdir loopcnt=LOOPCNT
#line 3113
#pragma cdir shortloop
#line 3113
    for (i=0; i<ni; i++) {
#line 3113
      /* the normal case: */
#line 3113
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3113
     /* test for range errors (not always needed but do it anyway) */
#line 3113
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3113
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3113
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3113
    }
#line 3113
   /* copy workspace back if necessary */
#line 3113
    if (realign) {
#line 3113
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3113
      xp = (short *) *xpp;
#line 3113
    }
#line 3113
   /* update xpp and tp */
#line 3113
    xp += ni;
#line 3113
    tp += ni;
#line 3113
    *xpp = (void*)xp;
#line 3113
  }
#line 3113
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3113

#line 3113
#else   /* not SX */
#line 3113

#line 3113
	char *xp = (char *) *xpp;
#line 3113
	int status = NC_NOERR;
#line 3113

#line 3113
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3113
	{
#line 3113
		int lstatus = ncx_put_short_float(xp, tp, fillp);
#line 3113
		if (status == NC_NOERR) /* report the first encountered error */
#line 3113
			status = lstatus;
#line 3113
	}
#line 3113

#line 3113
	*xpp = (void *)xp;
#line 3113
	return status;
#line 3113
#endif
#line 3113
}
#line 3113

int
#line 3114
ncx_putn_short_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3114
{
#line 3114
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3114

#line 3114
 /* basic algorithm is:
#line 3114
  *   - ensure sane alignment of output data
#line 3114
  *   - copy (conversion happens automatically) input data
#line 3114
  *     to output
#line 3114
  *   - update tp to point at next unconverted input, and xpp to point
#line 3114
  *     at next location for converted output
#line 3114
  */
#line 3114
  long i, j, ni;
#line 3114
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3114
  short *xp;
#line 3114
  int nrange = 0;         /* number of range errors */
#line 3114
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3114
  long cxp = (long) *((char**)xpp);
#line 3114

#line 3114
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3114
  /* sjl: manually stripmine so we can limit amount of
#line 3114
   * vector work space reserved to LOOPCNT elements. Also
#line 3114
   * makes vectorisation easy */
#line 3114
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3114
    ni=Min(nelems-j,LOOPCNT);
#line 3114
    if (realign) {
#line 3114
      xp = tmp;
#line 3114
    } else {
#line 3114
      xp = (short *) *xpp;
#line 3114
    }
#line 3114
   /* copy the next block */
#line 3114
#pragma cdir loopcnt=LOOPCNT
#line 3114
#pragma cdir shortloop
#line 3114
    for (i=0; i<ni; i++) {
#line 3114
      /* the normal case: */
#line 3114
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3114
     /* test for range errors (not always needed but do it anyway) */
#line 3114
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3114
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3114
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3114
    }
#line 3114
   /* copy workspace back if necessary */
#line 3114
    if (realign) {
#line 3114
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3114
      xp = (short *) *xpp;
#line 3114
    }
#line 3114
   /* update xpp and tp */
#line 3114
    xp += ni;
#line 3114
    tp += ni;
#line 3114
    *xpp = (void*)xp;
#line 3114
  }
#line 3114
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3114

#line 3114
#else   /* not SX */
#line 3114

#line 3114
	char *xp = (char *) *xpp;
#line 3114
	int status = NC_NOERR;
#line 3114

#line 3114
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3114
	{
#line 3114
		int lstatus = ncx_put_short_double(xp, tp, fillp);
#line 3114
		if (status == NC_NOERR) /* report the first encountered error */
#line 3114
			status = lstatus;
#line 3114
	}
#line 3114

#line 3114
	*xpp = (void *)xp;
#line 3114
	return status;
#line 3114
#endif
#line 3114
}
#line 3114

int
#line 3115
ncx_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3115
{
#line 3115
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3115

#line 3115
 /* basic algorithm is:
#line 3115
  *   - ensure sane alignment of output data
#line 3115
  *   - copy (conversion happens automatically) input data
#line 3115
  *     to output
#line 3115
  *   - update tp to point at next unconverted input, and xpp to point
#line 3115
  *     at next location for converted output
#line 3115
  */
#line 3115
  long i, j, ni;
#line 3115
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3115
  short *xp;
#line 3115
  int nrange = 0;         /* number of range errors */
#line 3115
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3115
  long cxp = (long) *((char**)xpp);
#line 3115

#line 3115
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3115
  /* sjl: manually stripmine so we can limit amount of
#line 3115
   * vector work space reserved to LOOPCNT elements. Also
#line 3115
   * makes vectorisation easy */
#line 3115
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3115
    ni=Min(nelems-j,LOOPCNT);
#line 3115
    if (realign) {
#line 3115
      xp = tmp;
#line 3115
    } else {
#line 3115
      xp = (short *) *xpp;
#line 3115
    }
#line 3115
   /* copy the next block */
#line 3115
#pragma cdir loopcnt=LOOPCNT
#line 3115
#pragma cdir shortloop
#line 3115
    for (i=0; i<ni; i++) {
#line 3115
      /* the normal case: */
#line 3115
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3115
     /* test for range errors (not always needed but do it anyway) */
#line 3115
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3115
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3115
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3115
    }
#line 3115
   /* copy workspace back if necessary */
#line 3115
    if (realign) {
#line 3115
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3115
      xp = (short *) *xpp;
#line 3115
    }
#line 3115
   /* update xpp and tp */
#line 3115
    xp += ni;
#line 3115
    tp += ni;
#line 3115
    *xpp = (void*)xp;
#line 3115
  }
#line 3115
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3115

#line 3115
#else   /* not SX */
#line 3115

#line 3115
	char *xp = (char *) *xpp;
#line 3115
	int status = NC_NOERR;
#line 3115

#line 3115
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3115
	{
#line 3115
		int lstatus = ncx_put_short_longlong(xp, tp, fillp);
#line 3115
		if (status == NC_NOERR) /* report the first encountered error */
#line 3115
			status = lstatus;
#line 3115
	}
#line 3115

#line 3115
	*xpp = (void *)xp;
#line 3115
	return status;
#line 3115
#endif
#line 3115
}
#line 3115

int
#line 3116
ncx_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3116
{
#line 3116
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3116

#line 3116
 /* basic algorithm is:
#line 3116
  *   - ensure sane alignment of output data
#line 3116
  *   - copy (conversion happens automatically) input data
#line 3116
  *     to output
#line 3116
  *   - update tp to point at next unconverted input, and xpp to point
#line 3116
  *     at next location for converted output
#line 3116
  */
#line 3116
  long i, j, ni;
#line 3116
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3116
  short *xp;
#line 3116
  int nrange = 0;         /* number of range errors */
#line 3116
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3116
  long cxp = (long) *((char**)xpp);
#line 3116

#line 3116
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3116
  /* sjl: manually stripmine so we can limit amount of
#line 3116
   * vector work space reserved to LOOPCNT elements. Also
#line 3116
   * makes vectorisation easy */
#line 3116
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3116
    ni=Min(nelems-j,LOOPCNT);
#line 3116
    if (realign) {
#line 3116
      xp = tmp;
#line 3116
    } else {
#line 3116
      xp = (short *) *xpp;
#line 3116
    }
#line 3116
   /* copy the next block */
#line 3116
#pragma cdir loopcnt=LOOPCNT
#line 3116
#pragma cdir shortloop
#line 3116
    for (i=0; i<ni; i++) {
#line 3116
      /* the normal case: */
#line 3116
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3116
     /* test for range errors (not always needed but do it anyway) */
#line 3116
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3116
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3116
      nrange += tp[i] > X_SHORT_MAX ;
#line 3116
    }
#line 3116
   /* copy workspace back if necessary */
#line 3116
    if (realign) {
#line 3116
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3116
      xp = (short *) *xpp;
#line 3116
    }
#line 3116
   /* update xpp and tp */
#line 3116
    xp += ni;
#line 3116
    tp += ni;
#line 3116
    *xpp = (void*)xp;
#line 3116
  }
#line 3116
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3116

#line 3116
#else   /* not SX */
#line 3116

#line 3116
	char *xp = (char *) *xpp;
#line 3116
	int status = NC_NOERR;
#line 3116

#line 3116
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3116
	{
#line 3116
		int lstatus = ncx_put_short_uchar(xp, tp, fillp);
#line 3116
		if (status == NC_NOERR) /* report the first encountered error */
#line 3116
			status = lstatus;
#line 3116
	}
#line 3116

#line 3116
	*xpp = (void *)xp;
#line 3116
	return status;
#line 3116
#endif
#line 3116
}
#line 3116

int
#line 3117
ncx_putn_short_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3117
{
#line 3117
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3117

#line 3117
 /* basic algorithm is:
#line 3117
  *   - ensure sane alignment of output data
#line 3117
  *   - copy (conversion happens automatically) input data
#line 3117
  *     to output
#line 3117
  *   - update tp to point at next unconverted input, and xpp to point
#line 3117
  *     at next location for converted output
#line 3117
  */
#line 3117
  long i, j, ni;
#line 3117
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3117
  short *xp;
#line 3117
  int nrange = 0;         /* number of range errors */
#line 3117
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3117
  long cxp = (long) *((char**)xpp);
#line 3117

#line 3117
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3117
  /* sjl: manually stripmine so we can limit amount of
#line 3117
   * vector work space reserved to LOOPCNT elements. Also
#line 3117
   * makes vectorisation easy */
#line 3117
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3117
    ni=Min(nelems-j,LOOPCNT);
#line 3117
    if (realign) {
#line 3117
      xp = tmp;
#line 3117
    } else {
#line 3117
      xp = (short *) *xpp;
#line 3117
    }
#line 3117
   /* copy the next block */
#line 3117
#pragma cdir loopcnt=LOOPCNT
#line 3117
#pragma cdir shortloop
#line 3117
    for (i=0; i<ni; i++) {
#line 3117
      /* the normal case: */
#line 3117
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3117
     /* test for range errors (not always needed but do it anyway) */
#line 3117
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3117
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3117
      nrange += tp[i] > X_SHORT_MAX ;
#line 3117
    }
#line 3117
   /* copy workspace back if necessary */
#line 3117
    if (realign) {
#line 3117
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3117
      xp = (short *) *xpp;
#line 3117
    }
#line 3117
   /* update xpp and tp */
#line 3117
    xp += ni;
#line 3117
    tp += ni;
#line 3117
    *xpp = (void*)xp;
#line 3117
  }
#line 3117
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3117

#line 3117
#else   /* not SX */
#line 3117

#line 3117
	char *xp = (char *) *xpp;
#line 3117
	int status = NC_NOERR;
#line 3117

#line 3117
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3117
	{
#line 3117
		int lstatus = ncx_put_short_uint(xp, tp, fillp);
#line 3117
		if (status == NC_NOERR) /* report the first encountered error */
#line 3117
			status = lstatus;
#line 3117
	}
#line 3117

#line 3117
	*xpp = (void *)xp;
#line 3117
	return status;
#line 3117
#endif
#line 3117
}
#line 3117

int
#line 3118
ncx_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3118
{
#line 3118
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3118

#line 3118
 /* basic algorithm is:
#line 3118
  *   - ensure sane alignment of output data
#line 3118
  *   - copy (conversion happens automatically) input data
#line 3118
  *     to output
#line 3118
  *   - update tp to point at next unconverted input, and xpp to point
#line 3118
  *     at next location for converted output
#line 3118
  */
#line 3118
  long i, j, ni;
#line 3118
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3118
  short *xp;
#line 3118
  int nrange = 0;         /* number of range errors */
#line 3118
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3118
  long cxp = (long) *((char**)xpp);
#line 3118

#line 3118
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3118
  /* sjl: manually stripmine so we can limit amount of
#line 3118
   * vector work space reserved to LOOPCNT elements. Also
#line 3118
   * makes vectorisation easy */
#line 3118
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3118
    ni=Min(nelems-j,LOOPCNT);
#line 3118
    if (realign) {
#line 3118
      xp = tmp;
#line 3118
    } else {
#line 3118
      xp = (short *) *xpp;
#line 3118
    }
#line 3118
   /* copy the next block */
#line 3118
#pragma cdir loopcnt=LOOPCNT
#line 3118
#pragma cdir shortloop
#line 3118
    for (i=0; i<ni; i++) {
#line 3118
      /* the normal case: */
#line 3118
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3118
     /* test for range errors (not always needed but do it anyway) */
#line 3118
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3118
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3118
      nrange += tp[i] > X_SHORT_MAX ;
#line 3118
    }
#line 3118
   /* copy workspace back if necessary */
#line 3118
    if (realign) {
#line 3118
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3118
      xp = (short *) *xpp;
#line 3118
    }
#line 3118
   /* update xpp and tp */
#line 3118
    xp += ni;
#line 3118
    tp += ni;
#line 3118
    *xpp = (void*)xp;
#line 3118
  }
#line 3118
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3118

#line 3118
#else   /* not SX */
#line 3118

#line 3118
	char *xp = (char *) *xpp;
#line 3118
	int status = NC_NOERR;
#line 3118

#line 3118
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3118
	{
#line 3118
		int lstatus = ncx_put_short_ulonglong(xp, tp, fillp);
#line 3118
		if (status == NC_NOERR) /* report the first encountered error */
#line 3118
			status = lstatus;
#line 3118
	}
#line 3118

#line 3118
	*xpp = (void *)xp;
#line 3118
	return status;
#line 3118
#endif
#line 3118
}
#line 3118

int
#line 3119
ncx_putn_short_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3119
{
#line 3119
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3119

#line 3119
 /* basic algorithm is:
#line 3119
  *   - ensure sane alignment of output data
#line 3119
  *   - copy (conversion happens automatically) input data
#line 3119
  *     to output
#line 3119
  *   - update tp to point at next unconverted input, and xpp to point
#line 3119
  *     at next location for converted output
#line 3119
  */
#line 3119
  long i, j, ni;
#line 3119
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3119
  short *xp;
#line 3119
  int nrange = 0;         /* number of range errors */
#line 3119
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3119
  long cxp = (long) *((char**)xpp);
#line 3119

#line 3119
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3119
  /* sjl: manually stripmine so we can limit amount of
#line 3119
   * vector work space reserved to LOOPCNT elements. Also
#line 3119
   * makes vectorisation easy */
#line 3119
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3119
    ni=Min(nelems-j,LOOPCNT);
#line 3119
    if (realign) {
#line 3119
      xp = tmp;
#line 3119
    } else {
#line 3119
      xp = (short *) *xpp;
#line 3119
    }
#line 3119
   /* copy the next block */
#line 3119
#pragma cdir loopcnt=LOOPCNT
#line 3119
#pragma cdir shortloop
#line 3119
    for (i=0; i<ni; i++) {
#line 3119
      /* the normal case: */
#line 3119
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3119
     /* test for range errors (not always needed but do it anyway) */
#line 3119
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3119
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3119
      nrange += tp[i] > X_SHORT_MAX ;
#line 3119
    }
#line 3119
   /* copy workspace back if necessary */
#line 3119
    if (realign) {
#line 3119
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3119
      xp = (short *) *xpp;
#line 3119
    }
#line 3119
   /* update xpp and tp */
#line 3119
    xp += ni;
#line 3119
    tp += ni;
#line 3119
    *xpp = (void*)xp;
#line 3119
  }
#line 3119
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3119

#line 3119
#else   /* not SX */
#line 3119

#line 3119
	char *xp = (char *) *xpp;
#line 3119
	int status = NC_NOERR;
#line 3119

#line 3119
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3119
	{
#line 3119
		int lstatus = ncx_put_short_ushort(xp, tp, fillp);
#line 3119
		if (status == NC_NOERR) /* report the first encountered error */
#line 3119
			status = lstatus;
#line 3119
	}
#line 3119

#line 3119
	*xpp = (void *)xp;
#line 3119
	return status;
#line 3119
#endif
#line 3119
}
#line 3119


int
#line 3121
ncx_pad_putn_short_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3121
{
#line 3121
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3121

#line 3121
	char *xp = (char *) *xpp;
#line 3121
	int status = NC_NOERR;
#line 3121

#line 3121
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3121
	{
#line 3121
		int lstatus = ncx_put_short_schar(xp, tp, fillp);
#line 3121
		if (status == NC_NOERR) /* report the first encountered error */
#line 3121
			status = lstatus;
#line 3121
	}
#line 3121

#line 3121
	if (rndup != 0)
#line 3121
	{
#line 3121
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3121
		xp += X_SIZEOF_SHORT;
#line 3121
	}
#line 3121

#line 3121
	*xpp = (void *)xp;
#line 3121
	return status;
#line 3121
}
#line 3121

int
#line 3122
ncx_pad_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3122
{
#line 3122
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3122

#line 3122
	char *xp = (char *) *xpp;
#line 3122
	int status = NC_NOERR;
#line 3122

#line 3122
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3122
	{
#line 3122
		int lstatus = ncx_put_short_uchar(xp, tp, fillp);
#line 3122
		if (status == NC_NOERR) /* report the first encountered error */
#line 3122
			status = lstatus;
#line 3122
	}
#line 3122

#line 3122
	if (rndup != 0)
#line 3122
	{
#line 3122
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3122
		xp += X_SIZEOF_SHORT;
#line 3122
	}
#line 3122

#line 3122
	*xpp = (void *)xp;
#line 3122
	return status;
#line 3122
}
#line 3122

int
#line 3123
ncx_pad_putn_short_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3123
{
#line 3123
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3123

#line 3123
	char *xp = (char *) *xpp;
#line 3123
	int status = NC_NOERR;
#line 3123

#line 3123
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3123
	{
#line 3123
		int lstatus = ncx_put_short_short(xp, tp, fillp);
#line 3123
		if (status == NC_NOERR) /* report the first encountered error */
#line 3123
			status = lstatus;
#line 3123
	}
#line 3123

#line 3123
	if (rndup != 0)
#line 3123
	{
#line 3123
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3123
		xp += X_SIZEOF_SHORT;
#line 3123
	}
#line 3123

#line 3123
	*xpp = (void *)xp;
#line 3123
	return status;
#line 3123
}
#line 3123

int
#line 3124
ncx_pad_putn_short_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3124
{
#line 3124
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3124

#line 3124
	char *xp = (char *) *xpp;
#line 3124
	int status = NC_NOERR;
#line 3124

#line 3124
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3124
	{
#line 3124
		int lstatus = ncx_put_short_int(xp, tp, fillp);
#line 3124
		if (status == NC_NOERR) /* report the first encountered error */
#line 3124
			status = lstatus;
#line 3124
	}
#line 3124

#line 3124
	if (rndup != 0)
#line 3124
	{
#line 3124
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3124
		xp += X_SIZEOF_SHORT;
#line 3124
	}
#line 3124

#line 3124
	*xpp = (void *)xp;
#line 3124
	return status;
#line 3124
}
#line 3124

int
#line 3125
ncx_pad_putn_short_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3125
{
#line 3125
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3125

#line 3125
	char *xp = (char *) *xpp;
#line 3125
	int status = NC_NOERR;
#line 3125

#line 3125
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3125
	{
#line 3125
		int lstatus = ncx_put_short_long(xp, tp, fillp);
#line 3125
		if (status == NC_NOERR) /* report the first encountered error */
#line 3125
			status = lstatus;
#line 3125
	}
#line 3125

#line 3125
	if (rndup != 0)
#line 3125
	{
#line 3125
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3125
		xp += X_SIZEOF_SHORT;
#line 3125
	}
#line 3125

#line 3125
	*xpp = (void *)xp;
#line 3125
	return status;
#line 3125
}
#line 3125

int
#line 3126
ncx_pad_putn_short_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3126
{
#line 3126
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3126

#line 3126
	char *xp = (char *) *xpp;
#line 3126
	int status = NC_NOERR;
#line 3126

#line 3126
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3126
	{
#line 3126
		int lstatus = ncx_put_short_float(xp, tp, fillp);
#line 3126
		if (status == NC_NOERR) /* report the first encountered error */
#line 3126
			status = lstatus;
#line 3126
	}
#line 3126

#line 3126
	if (rndup != 0)
#line 3126
	{
#line 3126
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3126
		xp += X_SIZEOF_SHORT;
#line 3126
	}
#line 3126

#line 3126
	*xpp = (void *)xp;
#line 3126
	return status;
#line 3126
}
#line 3126

int
#line 3127
ncx_pad_putn_short_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3127
{
#line 3127
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3127

#line 3127
	char *xp = (char *) *xpp;
#line 3127
	int status = NC_NOERR;
#line 3127

#line 3127
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3127
	{
#line 3127
		int lstatus = ncx_put_short_double(xp, tp, fillp);
#line 3127
		if (status == NC_NOERR) /* report the first encountered error */
#line 3127
			status = lstatus;
#line 3127
	}
#line 3127

#line 3127
	if (rndup != 0)
#line 3127
	{
#line 3127
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3127
		xp += X_SIZEOF_SHORT;
#line 3127
	}
#line 3127

#line 3127
	*xpp = (void *)xp;
#line 3127
	return status;
#line 3127
}
#line 3127

int
#line 3128
ncx_pad_putn_short_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3128
{
#line 3128
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3128

#line 3128
	char *xp = (char *) *xpp;
#line 3128
	int status = NC_NOERR;
#line 3128

#line 3128
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3128
	{
#line 3128
		int lstatus = ncx_put_short_uint(xp, tp, fillp);
#line 3128
		if (status == NC_NOERR) /* report the first encountered error */
#line 3128
			status = lstatus;
#line 3128
	}
#line 3128

#line 3128
	if (rndup != 0)
#line 3128
	{
#line 3128
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3128
		xp += X_SIZEOF_SHORT;
#line 3128
	}
#line 3128

#line 3128
	*xpp = (void *)xp;
#line 3128
	return status;
#line 3128
}
#line 3128

int
#line 3129
ncx_pad_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3129
{
#line 3129
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3129

#line 3129
	char *xp = (char *) *xpp;
#line 3129
	int status = NC_NOERR;
#line 3129

#line 3129
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3129
	{
#line 3129
		int lstatus = ncx_put_short_longlong(xp, tp, fillp);
#line 3129
		if (status == NC_NOERR) /* report the first encountered error */
#line 3129
			status = lstatus;
#line 3129
	}
#line 3129

#line 3129
	if (rndup != 0)
#line 3129
	{
#line 3129
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3129
		xp += X_SIZEOF_SHORT;
#line 3129
	}
#line 3129

#line 3129
	*xpp = (void *)xp;
#line 3129
	return status;
#line 3129
}
#line 3129

int
#line 3130
ncx_pad_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3130
{
#line 3130
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3130

#line 3130
	char *xp = (char *) *xpp;
#line 3130
	int status = NC_NOERR;
#line 3130

#line 3130
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3130
	{
#line 3130
		int lstatus = ncx_put_short_ulonglong(xp, tp, fillp);
#line 3130
		if (status == NC_NOERR) /* report the first encountered error */
#line 3130
			status = lstatus;
#line 3130
	}
#line 3130

#line 3130
	if (rndup != 0)
#line 3130
	{
#line 3130
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3130
		xp += X_SIZEOF_SHORT;
#line 3130
	}
#line 3130

#line 3130
	*xpp = (void *)xp;
#line 3130
	return status;
#line 3130
}
#line 3130

int
#line 3131
ncx_pad_putn_short_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3131
{
#line 3131
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3131

#line 3131
	char *xp = (char *) *xpp;
#line 3131
	int status = NC_NOERR;
#line 3131

#line 3131
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3131
	{
#line 3131
		int lstatus = ncx_put_short_ushort(xp, tp, fillp);
#line 3131
		if (status == NC_NOERR) /* report the first encountered error */
#line 3131
			status = lstatus;
#line 3131
	}
#line 3131

#line 3131
	if (rndup != 0)
#line 3131
	{
#line 3131
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3131
		xp += X_SIZEOF_SHORT;
#line 3131
	}
#line 3131

#line 3131
	*xpp = (void *)xp;
#line 3131
	return status;
#line 3131
}
#line 3131



/* ushort --------------------------------------------------------------------*/

#if X_SIZEOF_USHORT == SIZEOF_USHORT
/* optimized version */
int
ncx_getn_ushort_ushort(const void **xpp, size_t nelems, unsigned short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_USHORT);
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_USHORT);
	return NC_NOERR;
}
#else
int
#line 3150
ncx_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3150
{
#line 3150
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3150

#line 3150
 /* basic algorithm is:
#line 3150
  *   - ensure sane alignment of input data
#line 3150
  *   - copy (conversion happens automatically) input data
#line 3150
  *     to output
#line 3150
  *   - update xpp to point at next unconverted input, and tp to point
#line 3150
  *     at next location for converted output
#line 3150
  */
#line 3150
  long i, j, ni;
#line 3150
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3150
  ushort *xp;
#line 3150
  int nrange = 0;         /* number of range errors */
#line 3150
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3150
  long cxp = (long) *((char**)xpp);
#line 3150

#line 3150
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3150
  /* sjl: manually stripmine so we can limit amount of
#line 3150
   * vector work space reserved to LOOPCNT elements. Also
#line 3150
   * makes vectorisation easy */
#line 3150
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3150
    ni=Min(nelems-j,LOOPCNT);
#line 3150
    if (realign) {
#line 3150
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3150
      xp = tmp;
#line 3150
    } else {
#line 3150
      xp = (ushort *) *xpp;
#line 3150
    }
#line 3150
   /* copy the next block */
#line 3150
#pragma cdir loopcnt=LOOPCNT
#line 3150
#pragma cdir shortloop
#line 3150
    for (i=0; i<ni; i++) {
#line 3150
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3150
     /* test for range errors (not always needed but do it anyway) */
#line 3150
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3150
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3150
      nrange += xp[i] > USHORT_MAX ;
#line 3150
    }
#line 3150
   /* update xpp and tp */
#line 3150
    if (realign) xp = (ushort *) *xpp;
#line 3150
    xp += ni;
#line 3150
    tp += ni;
#line 3150
    *xpp = (void*)xp;
#line 3150
  }
#line 3150
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3150

#line 3150
#else   /* not SX */
#line 3150
	const char *xp = (const char *) *xpp;
#line 3150
	int status = NC_NOERR;
#line 3150

#line 3150
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3150
	{
#line 3150
		const int lstatus = ncx_get_ushort_ushort(xp, tp);
#line 3150
		if (status == NC_NOERR) /* report the first encountered error */
#line 3150
			status = lstatus;
#line 3150
	}
#line 3150

#line 3150
	*xpp = (const void *)xp;
#line 3150
	return status;
#line 3150
#endif
#line 3150
}
#line 3150

#endif
int
#line 3152
ncx_getn_ushort_schar(const void **xpp, size_t nelems, schar *tp)
#line 3152
{
#line 3152
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3152

#line 3152
 /* basic algorithm is:
#line 3152
  *   - ensure sane alignment of input data
#line 3152
  *   - copy (conversion happens automatically) input data
#line 3152
  *     to output
#line 3152
  *   - update xpp to point at next unconverted input, and tp to point
#line 3152
  *     at next location for converted output
#line 3152
  */
#line 3152
  long i, j, ni;
#line 3152
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3152
  ushort *xp;
#line 3152
  int nrange = 0;         /* number of range errors */
#line 3152
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3152
  long cxp = (long) *((char**)xpp);
#line 3152

#line 3152
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3152
  /* sjl: manually stripmine so we can limit amount of
#line 3152
   * vector work space reserved to LOOPCNT elements. Also
#line 3152
   * makes vectorisation easy */
#line 3152
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3152
    ni=Min(nelems-j,LOOPCNT);
#line 3152
    if (realign) {
#line 3152
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3152
      xp = tmp;
#line 3152
    } else {
#line 3152
      xp = (ushort *) *xpp;
#line 3152
    }
#line 3152
   /* copy the next block */
#line 3152
#pragma cdir loopcnt=LOOPCNT
#line 3152
#pragma cdir shortloop
#line 3152
    for (i=0; i<ni; i++) {
#line 3152
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3152
     /* test for range errors (not always needed but do it anyway) */
#line 3152
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3152
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3152
      nrange += xp[i] > SCHAR_MAX ;
#line 3152
    }
#line 3152
   /* update xpp and tp */
#line 3152
    if (realign) xp = (ushort *) *xpp;
#line 3152
    xp += ni;
#line 3152
    tp += ni;
#line 3152
    *xpp = (void*)xp;
#line 3152
  }
#line 3152
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3152

#line 3152
#else   /* not SX */
#line 3152
	const char *xp = (const char *) *xpp;
#line 3152
	int status = NC_NOERR;
#line 3152

#line 3152
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3152
	{
#line 3152
		const int lstatus = ncx_get_ushort_schar(xp, tp);
#line 3152
		if (status == NC_NOERR) /* report the first encountered error */
#line 3152
			status = lstatus;
#line 3152
	}
#line 3152

#line 3152
	*xpp = (const void *)xp;
#line 3152
	return status;
#line 3152
#endif
#line 3152
}
#line 3152

int
#line 3153
ncx_getn_ushort_short(const void **xpp, size_t nelems, short *tp)
#line 3153
{
#line 3153
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3153

#line 3153
 /* basic algorithm is:
#line 3153
  *   - ensure sane alignment of input data
#line 3153
  *   - copy (conversion happens automatically) input data
#line 3153
  *     to output
#line 3153
  *   - update xpp to point at next unconverted input, and tp to point
#line 3153
  *     at next location for converted output
#line 3153
  */
#line 3153
  long i, j, ni;
#line 3153
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3153
  ushort *xp;
#line 3153
  int nrange = 0;         /* number of range errors */
#line 3153
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3153
  long cxp = (long) *((char**)xpp);
#line 3153

#line 3153
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3153
  /* sjl: manually stripmine so we can limit amount of
#line 3153
   * vector work space reserved to LOOPCNT elements. Also
#line 3153
   * makes vectorisation easy */
#line 3153
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3153
    ni=Min(nelems-j,LOOPCNT);
#line 3153
    if (realign) {
#line 3153
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3153
      xp = tmp;
#line 3153
    } else {
#line 3153
      xp = (ushort *) *xpp;
#line 3153
    }
#line 3153
   /* copy the next block */
#line 3153
#pragma cdir loopcnt=LOOPCNT
#line 3153
#pragma cdir shortloop
#line 3153
    for (i=0; i<ni; i++) {
#line 3153
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3153
     /* test for range errors (not always needed but do it anyway) */
#line 3153
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3153
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3153
      nrange += xp[i] > SHORT_MAX ;
#line 3153
    }
#line 3153
   /* update xpp and tp */
#line 3153
    if (realign) xp = (ushort *) *xpp;
#line 3153
    xp += ni;
#line 3153
    tp += ni;
#line 3153
    *xpp = (void*)xp;
#line 3153
  }
#line 3153
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3153

#line 3153
#else   /* not SX */
#line 3153
	const char *xp = (const char *) *xpp;
#line 3153
	int status = NC_NOERR;
#line 3153

#line 3153
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3153
	{
#line 3153
		const int lstatus = ncx_get_ushort_short(xp, tp);
#line 3153
		if (status == NC_NOERR) /* report the first encountered error */
#line 3153
			status = lstatus;
#line 3153
	}
#line 3153

#line 3153
	*xpp = (const void *)xp;
#line 3153
	return status;
#line 3153
#endif
#line 3153
}
#line 3153

int
#line 3154
ncx_getn_ushort_int(const void **xpp, size_t nelems, int *tp)
#line 3154
{
#line 3154
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3154

#line 3154
 /* basic algorithm is:
#line 3154
  *   - ensure sane alignment of input data
#line 3154
  *   - copy (conversion happens automatically) input data
#line 3154
  *     to output
#line 3154
  *   - update xpp to point at next unconverted input, and tp to point
#line 3154
  *     at next location for converted output
#line 3154
  */
#line 3154
  long i, j, ni;
#line 3154
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3154
  ushort *xp;
#line 3154
  int nrange = 0;         /* number of range errors */
#line 3154
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3154
  long cxp = (long) *((char**)xpp);
#line 3154

#line 3154
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3154
  /* sjl: manually stripmine so we can limit amount of
#line 3154
   * vector work space reserved to LOOPCNT elements. Also
#line 3154
   * makes vectorisation easy */
#line 3154
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3154
    ni=Min(nelems-j,LOOPCNT);
#line 3154
    if (realign) {
#line 3154
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3154
      xp = tmp;
#line 3154
    } else {
#line 3154
      xp = (ushort *) *xpp;
#line 3154
    }
#line 3154
   /* copy the next block */
#line 3154
#pragma cdir loopcnt=LOOPCNT
#line 3154
#pragma cdir shortloop
#line 3154
    for (i=0; i<ni; i++) {
#line 3154
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3154
     /* test for range errors (not always needed but do it anyway) */
#line 3154
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3154
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3154
      nrange += xp[i] > INT_MAX ;
#line 3154
    }
#line 3154
   /* update xpp and tp */
#line 3154
    if (realign) xp = (ushort *) *xpp;
#line 3154
    xp += ni;
#line 3154
    tp += ni;
#line 3154
    *xpp = (void*)xp;
#line 3154
  }
#line 3154
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3154

#line 3154
#else   /* not SX */
#line 3154
	const char *xp = (const char *) *xpp;
#line 3154
	int status = NC_NOERR;
#line 3154

#line 3154
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3154
	{
#line 3154
		const int lstatus = ncx_get_ushort_int(xp, tp);
#line 3154
		if (status == NC_NOERR) /* report the first encountered error */
#line 3154
			status = lstatus;
#line 3154
	}
#line 3154

#line 3154
	*xpp = (const void *)xp;
#line 3154
	return status;
#line 3154
#endif
#line 3154
}
#line 3154

int
#line 3155
ncx_getn_ushort_long(const void **xpp, size_t nelems, long *tp)
#line 3155
{
#line 3155
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3155

#line 3155
 /* basic algorithm is:
#line 3155
  *   - ensure sane alignment of input data
#line 3155
  *   - copy (conversion happens automatically) input data
#line 3155
  *     to output
#line 3155
  *   - update xpp to point at next unconverted input, and tp to point
#line 3155
  *     at next location for converted output
#line 3155
  */
#line 3155
  long i, j, ni;
#line 3155
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3155
  ushort *xp;
#line 3155
  int nrange = 0;         /* number of range errors */
#line 3155
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3155
  long cxp = (long) *((char**)xpp);
#line 3155

#line 3155
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3155
  /* sjl: manually stripmine so we can limit amount of
#line 3155
   * vector work space reserved to LOOPCNT elements. Also
#line 3155
   * makes vectorisation easy */
#line 3155
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3155
    ni=Min(nelems-j,LOOPCNT);
#line 3155
    if (realign) {
#line 3155
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3155
      xp = tmp;
#line 3155
    } else {
#line 3155
      xp = (ushort *) *xpp;
#line 3155
    }
#line 3155
   /* copy the next block */
#line 3155
#pragma cdir loopcnt=LOOPCNT
#line 3155
#pragma cdir shortloop
#line 3155
    for (i=0; i<ni; i++) {
#line 3155
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3155
     /* test for range errors (not always needed but do it anyway) */
#line 3155
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3155
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3155
      nrange += xp[i] > LONG_MAX ;
#line 3155
    }
#line 3155
   /* update xpp and tp */
#line 3155
    if (realign) xp = (ushort *) *xpp;
#line 3155
    xp += ni;
#line 3155
    tp += ni;
#line 3155
    *xpp = (void*)xp;
#line 3155
  }
#line 3155
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3155

#line 3155
#else   /* not SX */
#line 3155
	const char *xp = (const char *) *xpp;
#line 3155
	int status = NC_NOERR;
#line 3155

#line 3155
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3155
	{
#line 3155
		const int lstatus = ncx_get_ushort_long(xp, tp);
#line 3155
		if (status == NC_NOERR) /* report the first encountered error */
#line 3155
			status = lstatus;
#line 3155
	}
#line 3155

#line 3155
	*xpp = (const void *)xp;
#line 3155
	return status;
#line 3155
#endif
#line 3155
}
#line 3155

int
#line 3156
ncx_getn_ushort_float(const void **xpp, size_t nelems, float *tp)
#line 3156
{
#line 3156
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3156

#line 3156
 /* basic algorithm is:
#line 3156
  *   - ensure sane alignment of input data
#line 3156
  *   - copy (conversion happens automatically) input data
#line 3156
  *     to output
#line 3156
  *   - update xpp to point at next unconverted input, and tp to point
#line 3156
  *     at next location for converted output
#line 3156
  */
#line 3156
  long i, j, ni;
#line 3156
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3156
  ushort *xp;
#line 3156
  int nrange = 0;         /* number of range errors */
#line 3156
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3156
  long cxp = (long) *((char**)xpp);
#line 3156

#line 3156
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3156
  /* sjl: manually stripmine so we can limit amount of
#line 3156
   * vector work space reserved to LOOPCNT elements. Also
#line 3156
   * makes vectorisation easy */
#line 3156
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3156
    ni=Min(nelems-j,LOOPCNT);
#line 3156
    if (realign) {
#line 3156
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3156
      xp = tmp;
#line 3156
    } else {
#line 3156
      xp = (ushort *) *xpp;
#line 3156
    }
#line 3156
   /* copy the next block */
#line 3156
#pragma cdir loopcnt=LOOPCNT
#line 3156
#pragma cdir shortloop
#line 3156
    for (i=0; i<ni; i++) {
#line 3156
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3156
     /* test for range errors (not always needed but do it anyway) */
#line 3156
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3156
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3156
      nrange += xp[i] > FLOAT_MAX ;
#line 3156
    }
#line 3156
   /* update xpp and tp */
#line 3156
    if (realign) xp = (ushort *) *xpp;
#line 3156
    xp += ni;
#line 3156
    tp += ni;
#line 3156
    *xpp = (void*)xp;
#line 3156
  }
#line 3156
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3156

#line 3156
#else   /* not SX */
#line 3156
	const char *xp = (const char *) *xpp;
#line 3156
	int status = NC_NOERR;
#line 3156

#line 3156
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3156
	{
#line 3156
		const int lstatus = ncx_get_ushort_float(xp, tp);
#line 3156
		if (status == NC_NOERR) /* report the first encountered error */
#line 3156
			status = lstatus;
#line 3156
	}
#line 3156

#line 3156
	*xpp = (const void *)xp;
#line 3156
	return status;
#line 3156
#endif
#line 3156
}
#line 3156

int
#line 3157
ncx_getn_ushort_double(const void **xpp, size_t nelems, double *tp)
#line 3157
{
#line 3157
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3157

#line 3157
 /* basic algorithm is:
#line 3157
  *   - ensure sane alignment of input data
#line 3157
  *   - copy (conversion happens automatically) input data
#line 3157
  *     to output
#line 3157
  *   - update xpp to point at next unconverted input, and tp to point
#line 3157
  *     at next location for converted output
#line 3157
  */
#line 3157
  long i, j, ni;
#line 3157
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3157
  ushort *xp;
#line 3157
  int nrange = 0;         /* number of range errors */
#line 3157
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3157
  long cxp = (long) *((char**)xpp);
#line 3157

#line 3157
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3157
  /* sjl: manually stripmine so we can limit amount of
#line 3157
   * vector work space reserved to LOOPCNT elements. Also
#line 3157
   * makes vectorisation easy */
#line 3157
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3157
    ni=Min(nelems-j,LOOPCNT);
#line 3157
    if (realign) {
#line 3157
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3157
      xp = tmp;
#line 3157
    } else {
#line 3157
      xp = (ushort *) *xpp;
#line 3157
    }
#line 3157
   /* copy the next block */
#line 3157
#pragma cdir loopcnt=LOOPCNT
#line 3157
#pragma cdir shortloop
#line 3157
    for (i=0; i<ni; i++) {
#line 3157
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3157
     /* test for range errors (not always needed but do it anyway) */
#line 3157
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3157
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3157
      nrange += xp[i] > DOUBLE_MAX ;
#line 3157
    }
#line 3157
   /* update xpp and tp */
#line 3157
    if (realign) xp = (ushort *) *xpp;
#line 3157
    xp += ni;
#line 3157
    tp += ni;
#line 3157
    *xpp = (void*)xp;
#line 3157
  }
#line 3157
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3157

#line 3157
#else   /* not SX */
#line 3157
	const char *xp = (const char *) *xpp;
#line 3157
	int status = NC_NOERR;
#line 3157

#line 3157
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3157
	{
#line 3157
		const int lstatus = ncx_get_ushort_double(xp, tp);
#line 3157
		if (status == NC_NOERR) /* report the first encountered error */
#line 3157
			status = lstatus;
#line 3157
	}
#line 3157

#line 3157
	*xpp = (const void *)xp;
#line 3157
	return status;
#line 3157
#endif
#line 3157
}
#line 3157

int
#line 3158
ncx_getn_ushort_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3158
{
#line 3158
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3158

#line 3158
 /* basic algorithm is:
#line 3158
  *   - ensure sane alignment of input data
#line 3158
  *   - copy (conversion happens automatically) input data
#line 3158
  *     to output
#line 3158
  *   - update xpp to point at next unconverted input, and tp to point
#line 3158
  *     at next location for converted output
#line 3158
  */
#line 3158
  long i, j, ni;
#line 3158
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3158
  ushort *xp;
#line 3158
  int nrange = 0;         /* number of range errors */
#line 3158
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3158
  long cxp = (long) *((char**)xpp);
#line 3158

#line 3158
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3158
  /* sjl: manually stripmine so we can limit amount of
#line 3158
   * vector work space reserved to LOOPCNT elements. Also
#line 3158
   * makes vectorisation easy */
#line 3158
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3158
    ni=Min(nelems-j,LOOPCNT);
#line 3158
    if (realign) {
#line 3158
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3158
      xp = tmp;
#line 3158
    } else {
#line 3158
      xp = (ushort *) *xpp;
#line 3158
    }
#line 3158
   /* copy the next block */
#line 3158
#pragma cdir loopcnt=LOOPCNT
#line 3158
#pragma cdir shortloop
#line 3158
    for (i=0; i<ni; i++) {
#line 3158
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3158
     /* test for range errors (not always needed but do it anyway) */
#line 3158
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3158
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3158
      nrange += xp[i] > LONGLONG_MAX ;
#line 3158
    }
#line 3158
   /* update xpp and tp */
#line 3158
    if (realign) xp = (ushort *) *xpp;
#line 3158
    xp += ni;
#line 3158
    tp += ni;
#line 3158
    *xpp = (void*)xp;
#line 3158
  }
#line 3158
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3158

#line 3158
#else   /* not SX */
#line 3158
	const char *xp = (const char *) *xpp;
#line 3158
	int status = NC_NOERR;
#line 3158

#line 3158
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3158
	{
#line 3158
		const int lstatus = ncx_get_ushort_longlong(xp, tp);
#line 3158
		if (status == NC_NOERR) /* report the first encountered error */
#line 3158
			status = lstatus;
#line 3158
	}
#line 3158

#line 3158
	*xpp = (const void *)xp;
#line 3158
	return status;
#line 3158
#endif
#line 3158
}
#line 3158

int
#line 3159
ncx_getn_ushort_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3159
{
#line 3159
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3159

#line 3159
 /* basic algorithm is:
#line 3159
  *   - ensure sane alignment of input data
#line 3159
  *   - copy (conversion happens automatically) input data
#line 3159
  *     to output
#line 3159
  *   - update xpp to point at next unconverted input, and tp to point
#line 3159
  *     at next location for converted output
#line 3159
  */
#line 3159
  long i, j, ni;
#line 3159
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3159
  ushort *xp;
#line 3159
  int nrange = 0;         /* number of range errors */
#line 3159
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3159
  long cxp = (long) *((char**)xpp);
#line 3159

#line 3159
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3159
  /* sjl: manually stripmine so we can limit amount of
#line 3159
   * vector work space reserved to LOOPCNT elements. Also
#line 3159
   * makes vectorisation easy */
#line 3159
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3159
    ni=Min(nelems-j,LOOPCNT);
#line 3159
    if (realign) {
#line 3159
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3159
      xp = tmp;
#line 3159
    } else {
#line 3159
      xp = (ushort *) *xpp;
#line 3159
    }
#line 3159
   /* copy the next block */
#line 3159
#pragma cdir loopcnt=LOOPCNT
#line 3159
#pragma cdir shortloop
#line 3159
    for (i=0; i<ni; i++) {
#line 3159
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3159
     /* test for range errors (not always needed but do it anyway) */
#line 3159
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3159
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3159
      nrange += xp[i] > UCHAR_MAX ;
#line 3159
    }
#line 3159
   /* update xpp and tp */
#line 3159
    if (realign) xp = (ushort *) *xpp;
#line 3159
    xp += ni;
#line 3159
    tp += ni;
#line 3159
    *xpp = (void*)xp;
#line 3159
  }
#line 3159
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3159

#line 3159
#else   /* not SX */
#line 3159
	const char *xp = (const char *) *xpp;
#line 3159
	int status = NC_NOERR;
#line 3159

#line 3159
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3159
	{
#line 3159
		const int lstatus = ncx_get_ushort_uchar(xp, tp);
#line 3159
		if (status == NC_NOERR) /* report the first encountered error */
#line 3159
			status = lstatus;
#line 3159
	}
#line 3159

#line 3159
	*xpp = (const void *)xp;
#line 3159
	return status;
#line 3159
#endif
#line 3159
}
#line 3159

int
#line 3160
ncx_getn_ushort_uint(const void **xpp, size_t nelems, uint *tp)
#line 3160
{
#line 3160
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3160

#line 3160
 /* basic algorithm is:
#line 3160
  *   - ensure sane alignment of input data
#line 3160
  *   - copy (conversion happens automatically) input data
#line 3160
  *     to output
#line 3160
  *   - update xpp to point at next unconverted input, and tp to point
#line 3160
  *     at next location for converted output
#line 3160
  */
#line 3160
  long i, j, ni;
#line 3160
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3160
  ushort *xp;
#line 3160
  int nrange = 0;         /* number of range errors */
#line 3160
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3160
  long cxp = (long) *((char**)xpp);
#line 3160

#line 3160
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3160
  /* sjl: manually stripmine so we can limit amount of
#line 3160
   * vector work space reserved to LOOPCNT elements. Also
#line 3160
   * makes vectorisation easy */
#line 3160
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3160
    ni=Min(nelems-j,LOOPCNT);
#line 3160
    if (realign) {
#line 3160
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3160
      xp = tmp;
#line 3160
    } else {
#line 3160
      xp = (ushort *) *xpp;
#line 3160
    }
#line 3160
   /* copy the next block */
#line 3160
#pragma cdir loopcnt=LOOPCNT
#line 3160
#pragma cdir shortloop
#line 3160
    for (i=0; i<ni; i++) {
#line 3160
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3160
     /* test for range errors (not always needed but do it anyway) */
#line 3160
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3160
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3160
      nrange += xp[i] > UINT_MAX ;
#line 3160
    }
#line 3160
   /* update xpp and tp */
#line 3160
    if (realign) xp = (ushort *) *xpp;
#line 3160
    xp += ni;
#line 3160
    tp += ni;
#line 3160
    *xpp = (void*)xp;
#line 3160
  }
#line 3160
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3160

#line 3160
#else   /* not SX */
#line 3160
	const char *xp = (const char *) *xpp;
#line 3160
	int status = NC_NOERR;
#line 3160

#line 3160
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3160
	{
#line 3160
		const int lstatus = ncx_get_ushort_uint(xp, tp);
#line 3160
		if (status == NC_NOERR) /* report the first encountered error */
#line 3160
			status = lstatus;
#line 3160
	}
#line 3160

#line 3160
	*xpp = (const void *)xp;
#line 3160
	return status;
#line 3160
#endif
#line 3160
}
#line 3160

int
#line 3161
ncx_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3161
{
#line 3161
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3161

#line 3161
 /* basic algorithm is:
#line 3161
  *   - ensure sane alignment of input data
#line 3161
  *   - copy (conversion happens automatically) input data
#line 3161
  *     to output
#line 3161
  *   - update xpp to point at next unconverted input, and tp to point
#line 3161
  *     at next location for converted output
#line 3161
  */
#line 3161
  long i, j, ni;
#line 3161
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3161
  ushort *xp;
#line 3161
  int nrange = 0;         /* number of range errors */
#line 3161
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3161
  long cxp = (long) *((char**)xpp);
#line 3161

#line 3161
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3161
  /* sjl: manually stripmine so we can limit amount of
#line 3161
   * vector work space reserved to LOOPCNT elements. Also
#line 3161
   * makes vectorisation easy */
#line 3161
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3161
    ni=Min(nelems-j,LOOPCNT);
#line 3161
    if (realign) {
#line 3161
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3161
      xp = tmp;
#line 3161
    } else {
#line 3161
      xp = (ushort *) *xpp;
#line 3161
    }
#line 3161
   /* copy the next block */
#line 3161
#pragma cdir loopcnt=LOOPCNT
#line 3161
#pragma cdir shortloop
#line 3161
    for (i=0; i<ni; i++) {
#line 3161
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3161
     /* test for range errors (not always needed but do it anyway) */
#line 3161
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3161
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3161
      nrange += xp[i] > ULONGLONG_MAX ;
#line 3161
    }
#line 3161
   /* update xpp and tp */
#line 3161
    if (realign) xp = (ushort *) *xpp;
#line 3161
    xp += ni;
#line 3161
    tp += ni;
#line 3161
    *xpp = (void*)xp;
#line 3161
  }
#line 3161
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3161

#line 3161
#else   /* not SX */
#line 3161
	const char *xp = (const char *) *xpp;
#line 3161
	int status = NC_NOERR;
#line 3161

#line 3161
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3161
	{
#line 3161
		const int lstatus = ncx_get_ushort_ulonglong(xp, tp);
#line 3161
		if (status == NC_NOERR) /* report the first encountered error */
#line 3161
			status = lstatus;
#line 3161
	}
#line 3161

#line 3161
	*xpp = (const void *)xp;
#line 3161
	return status;
#line 3161
#endif
#line 3161
}
#line 3161


int
#line 3163
ncx_pad_getn_ushort_schar(const void **xpp, size_t nelems, schar *tp)
#line 3163
{
#line 3163
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3163

#line 3163
	const char *xp = (const char *) *xpp;
#line 3163
	int status = NC_NOERR;
#line 3163

#line 3163
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3163
	{
#line 3163
		const int lstatus = ncx_get_ushort_schar(xp, tp);
#line 3163
		if (status == NC_NOERR) /* report the first encountered error */
#line 3163
			status = lstatus;
#line 3163
	}
#line 3163

#line 3163
	if (rndup != 0)
#line 3163
		xp += X_SIZEOF_USHORT;
#line 3163

#line 3163
	*xpp = (void *)xp;
#line 3163
	return status;
#line 3163
}
#line 3163

int
#line 3164
ncx_pad_getn_ushort_short(const void **xpp, size_t nelems, short *tp)
#line 3164
{
#line 3164
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3164

#line 3164
	const char *xp = (const char *) *xpp;
#line 3164
	int status = NC_NOERR;
#line 3164

#line 3164
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3164
	{
#line 3164
		const int lstatus = ncx_get_ushort_short(xp, tp);
#line 3164
		if (status == NC_NOERR) /* report the first encountered error */
#line 3164
			status = lstatus;
#line 3164
	}
#line 3164

#line 3164
	if (rndup != 0)
#line 3164
		xp += X_SIZEOF_USHORT;
#line 3164

#line 3164
	*xpp = (void *)xp;
#line 3164
	return status;
#line 3164
}
#line 3164

int
#line 3165
ncx_pad_getn_ushort_int(const void **xpp, size_t nelems, int *tp)
#line 3165
{
#line 3165
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3165

#line 3165
	const char *xp = (const char *) *xpp;
#line 3165
	int status = NC_NOERR;
#line 3165

#line 3165
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3165
	{
#line 3165
		const int lstatus = ncx_get_ushort_int(xp, tp);
#line 3165
		if (status == NC_NOERR) /* report the first encountered error */
#line 3165
			status = lstatus;
#line 3165
	}
#line 3165

#line 3165
	if (rndup != 0)
#line 3165
		xp += X_SIZEOF_USHORT;
#line 3165

#line 3165
	*xpp = (void *)xp;
#line 3165
	return status;
#line 3165
}
#line 3165

int
#line 3166
ncx_pad_getn_ushort_long(const void **xpp, size_t nelems, long *tp)
#line 3166
{
#line 3166
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3166

#line 3166
	const char *xp = (const char *) *xpp;
#line 3166
	int status = NC_NOERR;
#line 3166

#line 3166
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3166
	{
#line 3166
		const int lstatus = ncx_get_ushort_long(xp, tp);
#line 3166
		if (status == NC_NOERR) /* report the first encountered error */
#line 3166
			status = lstatus;
#line 3166
	}
#line 3166

#line 3166
	if (rndup != 0)
#line 3166
		xp += X_SIZEOF_USHORT;
#line 3166

#line 3166
	*xpp = (void *)xp;
#line 3166
	return status;
#line 3166
}
#line 3166

int
#line 3167
ncx_pad_getn_ushort_float(const void **xpp, size_t nelems, float *tp)
#line 3167
{
#line 3167
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3167

#line 3167
	const char *xp = (const char *) *xpp;
#line 3167
	int status = NC_NOERR;
#line 3167

#line 3167
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3167
	{
#line 3167
		const int lstatus = ncx_get_ushort_float(xp, tp);
#line 3167
		if (status == NC_NOERR) /* report the first encountered error */
#line 3167
			status = lstatus;
#line 3167
	}
#line 3167

#line 3167
	if (rndup != 0)
#line 3167
		xp += X_SIZEOF_USHORT;
#line 3167

#line 3167
	*xpp = (void *)xp;
#line 3167
	return status;
#line 3167
}
#line 3167

int
#line 3168
ncx_pad_getn_ushort_double(const void **xpp, size_t nelems, double *tp)
#line 3168
{
#line 3168
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3168

#line 3168
	const char *xp = (const char *) *xpp;
#line 3168
	int status = NC_NOERR;
#line 3168

#line 3168
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3168
	{
#line 3168
		const int lstatus = ncx_get_ushort_double(xp, tp);
#line 3168
		if (status == NC_NOERR) /* report the first encountered error */
#line 3168
			status = lstatus;
#line 3168
	}
#line 3168

#line 3168
	if (rndup != 0)
#line 3168
		xp += X_SIZEOF_USHORT;
#line 3168

#line 3168
	*xpp = (void *)xp;
#line 3168
	return status;
#line 3168
}
#line 3168

int
#line 3169
ncx_pad_getn_ushort_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3169
{
#line 3169
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3169

#line 3169
	const char *xp = (const char *) *xpp;
#line 3169
	int status = NC_NOERR;
#line 3169

#line 3169
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3169
	{
#line 3169
		const int lstatus = ncx_get_ushort_uchar(xp, tp);
#line 3169
		if (status == NC_NOERR) /* report the first encountered error */
#line 3169
			status = lstatus;
#line 3169
	}
#line 3169

#line 3169
	if (rndup != 0)
#line 3169
		xp += X_SIZEOF_USHORT;
#line 3169

#line 3169
	*xpp = (void *)xp;
#line 3169
	return status;
#line 3169
}
#line 3169

int
#line 3170
ncx_pad_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3170
{
#line 3170
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3170

#line 3170
	const char *xp = (const char *) *xpp;
#line 3170
	int status = NC_NOERR;
#line 3170

#line 3170
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3170
	{
#line 3170
		const int lstatus = ncx_get_ushort_ushort(xp, tp);
#line 3170
		if (status == NC_NOERR) /* report the first encountered error */
#line 3170
			status = lstatus;
#line 3170
	}
#line 3170

#line 3170
	if (rndup != 0)
#line 3170
		xp += X_SIZEOF_USHORT;
#line 3170

#line 3170
	*xpp = (void *)xp;
#line 3170
	return status;
#line 3170
}
#line 3170

int
#line 3171
ncx_pad_getn_ushort_uint(const void **xpp, size_t nelems, uint *tp)
#line 3171
{
#line 3171
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3171

#line 3171
	const char *xp = (const char *) *xpp;
#line 3171
	int status = NC_NOERR;
#line 3171

#line 3171
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3171
	{
#line 3171
		const int lstatus = ncx_get_ushort_uint(xp, tp);
#line 3171
		if (status == NC_NOERR) /* report the first encountered error */
#line 3171
			status = lstatus;
#line 3171
	}
#line 3171

#line 3171
	if (rndup != 0)
#line 3171
		xp += X_SIZEOF_USHORT;
#line 3171

#line 3171
	*xpp = (void *)xp;
#line 3171
	return status;
#line 3171
}
#line 3171

int
#line 3172
ncx_pad_getn_ushort_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3172
{
#line 3172
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3172

#line 3172
	const char *xp = (const char *) *xpp;
#line 3172
	int status = NC_NOERR;
#line 3172

#line 3172
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3172
	{
#line 3172
		const int lstatus = ncx_get_ushort_longlong(xp, tp);
#line 3172
		if (status == NC_NOERR) /* report the first encountered error */
#line 3172
			status = lstatus;
#line 3172
	}
#line 3172

#line 3172
	if (rndup != 0)
#line 3172
		xp += X_SIZEOF_USHORT;
#line 3172

#line 3172
	*xpp = (void *)xp;
#line 3172
	return status;
#line 3172
}
#line 3172

int
#line 3173
ncx_pad_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3173
{
#line 3173
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3173

#line 3173
	const char *xp = (const char *) *xpp;
#line 3173
	int status = NC_NOERR;
#line 3173

#line 3173
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3173
	{
#line 3173
		const int lstatus = ncx_get_ushort_ulonglong(xp, tp);
#line 3173
		if (status == NC_NOERR) /* report the first encountered error */
#line 3173
			status = lstatus;
#line 3173
	}
#line 3173

#line 3173
	if (rndup != 0)
#line 3173
		xp += X_SIZEOF_USHORT;
#line 3173

#line 3173
	*xpp = (void *)xp;
#line 3173
	return status;
#line 3173
}
#line 3173


#if X_SIZEOF_USHORT == SIZEOF_USHORT
/* optimized version */
int
ncx_putn_ushort_ushort(void **xpp, size_t nelems, const unsigned short *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_USHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_USHORT);
	return NC_NOERR;
}
#else
int
#line 3189
ncx_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3189
{
#line 3189
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3189

#line 3189
 /* basic algorithm is:
#line 3189
  *   - ensure sane alignment of output data
#line 3189
  *   - copy (conversion happens automatically) input data
#line 3189
  *     to output
#line 3189
  *   - update tp to point at next unconverted input, and xpp to point
#line 3189
  *     at next location for converted output
#line 3189
  */
#line 3189
  long i, j, ni;
#line 3189
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3189
  ushort *xp;
#line 3189
  int nrange = 0;         /* number of range errors */
#line 3189
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3189
  long cxp = (long) *((char**)xpp);
#line 3189

#line 3189
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3189
  /* sjl: manually stripmine so we can limit amount of
#line 3189
   * vector work space reserved to LOOPCNT elements. Also
#line 3189
   * makes vectorisation easy */
#line 3189
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3189
    ni=Min(nelems-j,LOOPCNT);
#line 3189
    if (realign) {
#line 3189
      xp = tmp;
#line 3189
    } else {
#line 3189
      xp = (ushort *) *xpp;
#line 3189
    }
#line 3189
   /* copy the next block */
#line 3189
#pragma cdir loopcnt=LOOPCNT
#line 3189
#pragma cdir shortloop
#line 3189
    for (i=0; i<ni; i++) {
#line 3189
      /* the normal case: */
#line 3189
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3189
     /* test for range errors (not always needed but do it anyway) */
#line 3189
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3189
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3189
      nrange += tp[i] > X_USHORT_MAX ;
#line 3189
    }
#line 3189
   /* copy workspace back if necessary */
#line 3189
    if (realign) {
#line 3189
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3189
      xp = (ushort *) *xpp;
#line 3189
    }
#line 3189
   /* update xpp and tp */
#line 3189
    xp += ni;
#line 3189
    tp += ni;
#line 3189
    *xpp = (void*)xp;
#line 3189
  }
#line 3189
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3189

#line 3189
#else   /* not SX */
#line 3189

#line 3189
	char *xp = (char *) *xpp;
#line 3189
	int status = NC_NOERR;
#line 3189

#line 3189
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3189
	{
#line 3189
		int lstatus = ncx_put_ushort_ushort(xp, tp, fillp);
#line 3189
		if (status == NC_NOERR) /* report the first encountered error */
#line 3189
			status = lstatus;
#line 3189
	}
#line 3189

#line 3189
	*xpp = (void *)xp;
#line 3189
	return status;
#line 3189
#endif
#line 3189
}
#line 3189

#endif
int
#line 3191
ncx_putn_ushort_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3191
{
#line 3191
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3191

#line 3191
 /* basic algorithm is:
#line 3191
  *   - ensure sane alignment of output data
#line 3191
  *   - copy (conversion happens automatically) input data
#line 3191
  *     to output
#line 3191
  *   - update tp to point at next unconverted input, and xpp to point
#line 3191
  *     at next location for converted output
#line 3191
  */
#line 3191
  long i, j, ni;
#line 3191
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3191
  ushort *xp;
#line 3191
  int nrange = 0;         /* number of range errors */
#line 3191
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3191
  long cxp = (long) *((char**)xpp);
#line 3191

#line 3191
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3191
  /* sjl: manually stripmine so we can limit amount of
#line 3191
   * vector work space reserved to LOOPCNT elements. Also
#line 3191
   * makes vectorisation easy */
#line 3191
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3191
    ni=Min(nelems-j,LOOPCNT);
#line 3191
    if (realign) {
#line 3191
      xp = tmp;
#line 3191
    } else {
#line 3191
      xp = (ushort *) *xpp;
#line 3191
    }
#line 3191
   /* copy the next block */
#line 3191
#pragma cdir loopcnt=LOOPCNT
#line 3191
#pragma cdir shortloop
#line 3191
    for (i=0; i<ni; i++) {
#line 3191
      /* the normal case: */
#line 3191
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3191
     /* test for range errors (not always needed but do it anyway) */
#line 3191
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3191
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3191
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3191
    }
#line 3191
   /* copy workspace back if necessary */
#line 3191
    if (realign) {
#line 3191
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3191
      xp = (ushort *) *xpp;
#line 3191
    }
#line 3191
   /* update xpp and tp */
#line 3191
    xp += ni;
#line 3191
    tp += ni;
#line 3191
    *xpp = (void*)xp;
#line 3191
  }
#line 3191
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3191

#line 3191
#else   /* not SX */
#line 3191

#line 3191
	char *xp = (char *) *xpp;
#line 3191
	int status = NC_NOERR;
#line 3191

#line 3191
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3191
	{
#line 3191
		int lstatus = ncx_put_ushort_schar(xp, tp, fillp);
#line 3191
		if (status == NC_NOERR) /* report the first encountered error */
#line 3191
			status = lstatus;
#line 3191
	}
#line 3191

#line 3191
	*xpp = (void *)xp;
#line 3191
	return status;
#line 3191
#endif
#line 3191
}
#line 3191

int
#line 3192
ncx_putn_ushort_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3192
{
#line 3192
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3192

#line 3192
 /* basic algorithm is:
#line 3192
  *   - ensure sane alignment of output data
#line 3192
  *   - copy (conversion happens automatically) input data
#line 3192
  *     to output
#line 3192
  *   - update tp to point at next unconverted input, and xpp to point
#line 3192
  *     at next location for converted output
#line 3192
  */
#line 3192
  long i, j, ni;
#line 3192
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3192
  ushort *xp;
#line 3192
  int nrange = 0;         /* number of range errors */
#line 3192
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3192
  long cxp = (long) *((char**)xpp);
#line 3192

#line 3192
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3192
  /* sjl: manually stripmine so we can limit amount of
#line 3192
   * vector work space reserved to LOOPCNT elements. Also
#line 3192
   * makes vectorisation easy */
#line 3192
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3192
    ni=Min(nelems-j,LOOPCNT);
#line 3192
    if (realign) {
#line 3192
      xp = tmp;
#line 3192
    } else {
#line 3192
      xp = (ushort *) *xpp;
#line 3192
    }
#line 3192
   /* copy the next block */
#line 3192
#pragma cdir loopcnt=LOOPCNT
#line 3192
#pragma cdir shortloop
#line 3192
    for (i=0; i<ni; i++) {
#line 3192
      /* the normal case: */
#line 3192
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3192
     /* test for range errors (not always needed but do it anyway) */
#line 3192
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3192
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3192
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3192
    }
#line 3192
   /* copy workspace back if necessary */
#line 3192
    if (realign) {
#line 3192
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3192
      xp = (ushort *) *xpp;
#line 3192
    }
#line 3192
   /* update xpp and tp */
#line 3192
    xp += ni;
#line 3192
    tp += ni;
#line 3192
    *xpp = (void*)xp;
#line 3192
  }
#line 3192
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3192

#line 3192
#else   /* not SX */
#line 3192

#line 3192
	char *xp = (char *) *xpp;
#line 3192
	int status = NC_NOERR;
#line 3192

#line 3192
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3192
	{
#line 3192
		int lstatus = ncx_put_ushort_short(xp, tp, fillp);
#line 3192
		if (status == NC_NOERR) /* report the first encountered error */
#line 3192
			status = lstatus;
#line 3192
	}
#line 3192

#line 3192
	*xpp = (void *)xp;
#line 3192
	return status;
#line 3192
#endif
#line 3192
}
#line 3192

int
#line 3193
ncx_putn_ushort_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3193
{
#line 3193
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3193

#line 3193
 /* basic algorithm is:
#line 3193
  *   - ensure sane alignment of output data
#line 3193
  *   - copy (conversion happens automatically) input data
#line 3193
  *     to output
#line 3193
  *   - update tp to point at next unconverted input, and xpp to point
#line 3193
  *     at next location for converted output
#line 3193
  */
#line 3193
  long i, j, ni;
#line 3193
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3193
  ushort *xp;
#line 3193
  int nrange = 0;         /* number of range errors */
#line 3193
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3193
  long cxp = (long) *((char**)xpp);
#line 3193

#line 3193
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3193
  /* sjl: manually stripmine so we can limit amount of
#line 3193
   * vector work space reserved to LOOPCNT elements. Also
#line 3193
   * makes vectorisation easy */
#line 3193
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3193
    ni=Min(nelems-j,LOOPCNT);
#line 3193
    if (realign) {
#line 3193
      xp = tmp;
#line 3193
    } else {
#line 3193
      xp = (ushort *) *xpp;
#line 3193
    }
#line 3193
   /* copy the next block */
#line 3193
#pragma cdir loopcnt=LOOPCNT
#line 3193
#pragma cdir shortloop
#line 3193
    for (i=0; i<ni; i++) {
#line 3193
      /* the normal case: */
#line 3193
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3193
     /* test for range errors (not always needed but do it anyway) */
#line 3193
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3193
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3193
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3193
    }
#line 3193
   /* copy workspace back if necessary */
#line 3193
    if (realign) {
#line 3193
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3193
      xp = (ushort *) *xpp;
#line 3193
    }
#line 3193
   /* update xpp and tp */
#line 3193
    xp += ni;
#line 3193
    tp += ni;
#line 3193
    *xpp = (void*)xp;
#line 3193
  }
#line 3193
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3193

#line 3193
#else   /* not SX */
#line 3193

#line 3193
	char *xp = (char *) *xpp;
#line 3193
	int status = NC_NOERR;
#line 3193

#line 3193
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3193
	{
#line 3193
		int lstatus = ncx_put_ushort_int(xp, tp, fillp);
#line 3193
		if (status == NC_NOERR) /* report the first encountered error */
#line 3193
			status = lstatus;
#line 3193
	}
#line 3193

#line 3193
	*xpp = (void *)xp;
#line 3193
	return status;
#line 3193
#endif
#line 3193
}
#line 3193

int
#line 3194
ncx_putn_ushort_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3194
{
#line 3194
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3194

#line 3194
 /* basic algorithm is:
#line 3194
  *   - ensure sane alignment of output data
#line 3194
  *   - copy (conversion happens automatically) input data
#line 3194
  *     to output
#line 3194
  *   - update tp to point at next unconverted input, and xpp to point
#line 3194
  *     at next location for converted output
#line 3194
  */
#line 3194
  long i, j, ni;
#line 3194
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3194
  ushort *xp;
#line 3194
  int nrange = 0;         /* number of range errors */
#line 3194
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3194
  long cxp = (long) *((char**)xpp);
#line 3194

#line 3194
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3194
  /* sjl: manually stripmine so we can limit amount of
#line 3194
   * vector work space reserved to LOOPCNT elements. Also
#line 3194
   * makes vectorisation easy */
#line 3194
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3194
    ni=Min(nelems-j,LOOPCNT);
#line 3194
    if (realign) {
#line 3194
      xp = tmp;
#line 3194
    } else {
#line 3194
      xp = (ushort *) *xpp;
#line 3194
    }
#line 3194
   /* copy the next block */
#line 3194
#pragma cdir loopcnt=LOOPCNT
#line 3194
#pragma cdir shortloop
#line 3194
    for (i=0; i<ni; i++) {
#line 3194
      /* the normal case: */
#line 3194
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3194
     /* test for range errors (not always needed but do it anyway) */
#line 3194
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3194
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3194
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3194
    }
#line 3194
   /* copy workspace back if necessary */
#line 3194
    if (realign) {
#line 3194
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3194
      xp = (ushort *) *xpp;
#line 3194
    }
#line 3194
   /* update xpp and tp */
#line 3194
    xp += ni;
#line 3194
    tp += ni;
#line 3194
    *xpp = (void*)xp;
#line 3194
  }
#line 3194
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3194

#line 3194
#else   /* not SX */
#line 3194

#line 3194
	char *xp = (char *) *xpp;
#line 3194
	int status = NC_NOERR;
#line 3194

#line 3194
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3194
	{
#line 3194
		int lstatus = ncx_put_ushort_long(xp, tp, fillp);
#line 3194
		if (status == NC_NOERR) /* report the first encountered error */
#line 3194
			status = lstatus;
#line 3194
	}
#line 3194

#line 3194
	*xpp = (void *)xp;
#line 3194
	return status;
#line 3194
#endif
#line 3194
}
#line 3194

int
#line 3195
ncx_putn_ushort_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3195
{
#line 3195
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3195

#line 3195
 /* basic algorithm is:
#line 3195
  *   - ensure sane alignment of output data
#line 3195
  *   - copy (conversion happens automatically) input data
#line 3195
  *     to output
#line 3195
  *   - update tp to point at next unconverted input, and xpp to point
#line 3195
  *     at next location for converted output
#line 3195
  */
#line 3195
  long i, j, ni;
#line 3195
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3195
  ushort *xp;
#line 3195
  int nrange = 0;         /* number of range errors */
#line 3195
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3195
  long cxp = (long) *((char**)xpp);
#line 3195

#line 3195
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3195
  /* sjl: manually stripmine so we can limit amount of
#line 3195
   * vector work space reserved to LOOPCNT elements. Also
#line 3195
   * makes vectorisation easy */
#line 3195
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3195
    ni=Min(nelems-j,LOOPCNT);
#line 3195
    if (realign) {
#line 3195
      xp = tmp;
#line 3195
    } else {
#line 3195
      xp = (ushort *) *xpp;
#line 3195
    }
#line 3195
   /* copy the next block */
#line 3195
#pragma cdir loopcnt=LOOPCNT
#line 3195
#pragma cdir shortloop
#line 3195
    for (i=0; i<ni; i++) {
#line 3195
      /* the normal case: */
#line 3195
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3195
     /* test for range errors (not always needed but do it anyway) */
#line 3195
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3195
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3195
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3195
    }
#line 3195
   /* copy workspace back if necessary */
#line 3195
    if (realign) {
#line 3195
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3195
      xp = (ushort *) *xpp;
#line 3195
    }
#line 3195
   /* update xpp and tp */
#line 3195
    xp += ni;
#line 3195
    tp += ni;
#line 3195
    *xpp = (void*)xp;
#line 3195
  }
#line 3195
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3195

#line 3195
#else   /* not SX */
#line 3195

#line 3195
	char *xp = (char *) *xpp;
#line 3195
	int status = NC_NOERR;
#line 3195

#line 3195
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3195
	{
#line 3195
		int lstatus = ncx_put_ushort_float(xp, tp, fillp);
#line 3195
		if (status == NC_NOERR) /* report the first encountered error */
#line 3195
			status = lstatus;
#line 3195
	}
#line 3195

#line 3195
	*xpp = (void *)xp;
#line 3195
	return status;
#line 3195
#endif
#line 3195
}
#line 3195

int
#line 3196
ncx_putn_ushort_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3196
{
#line 3196
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3196

#line 3196
 /* basic algorithm is:
#line 3196
  *   - ensure sane alignment of output data
#line 3196
  *   - copy (conversion happens automatically) input data
#line 3196
  *     to output
#line 3196
  *   - update tp to point at next unconverted input, and xpp to point
#line 3196
  *     at next location for converted output
#line 3196
  */
#line 3196
  long i, j, ni;
#line 3196
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3196
  ushort *xp;
#line 3196
  int nrange = 0;         /* number of range errors */
#line 3196
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3196
  long cxp = (long) *((char**)xpp);
#line 3196

#line 3196
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3196
  /* sjl: manually stripmine so we can limit amount of
#line 3196
   * vector work space reserved to LOOPCNT elements. Also
#line 3196
   * makes vectorisation easy */
#line 3196
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3196
    ni=Min(nelems-j,LOOPCNT);
#line 3196
    if (realign) {
#line 3196
      xp = tmp;
#line 3196
    } else {
#line 3196
      xp = (ushort *) *xpp;
#line 3196
    }
#line 3196
   /* copy the next block */
#line 3196
#pragma cdir loopcnt=LOOPCNT
#line 3196
#pragma cdir shortloop
#line 3196
    for (i=0; i<ni; i++) {
#line 3196
      /* the normal case: */
#line 3196
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3196
     /* test for range errors (not always needed but do it anyway) */
#line 3196
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3196
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3196
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3196
    }
#line 3196
   /* copy workspace back if necessary */
#line 3196
    if (realign) {
#line 3196
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3196
      xp = (ushort *) *xpp;
#line 3196
    }
#line 3196
   /* update xpp and tp */
#line 3196
    xp += ni;
#line 3196
    tp += ni;
#line 3196
    *xpp = (void*)xp;
#line 3196
  }
#line 3196
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3196

#line 3196
#else   /* not SX */
#line 3196

#line 3196
	char *xp = (char *) *xpp;
#line 3196
	int status = NC_NOERR;
#line 3196

#line 3196
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3196
	{
#line 3196
		int lstatus = ncx_put_ushort_double(xp, tp, fillp);
#line 3196
		if (status == NC_NOERR) /* report the first encountered error */
#line 3196
			status = lstatus;
#line 3196
	}
#line 3196

#line 3196
	*xpp = (void *)xp;
#line 3196
	return status;
#line 3196
#endif
#line 3196
}
#line 3196

int
#line 3197
ncx_putn_ushort_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3197
{
#line 3197
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3197

#line 3197
 /* basic algorithm is:
#line 3197
  *   - ensure sane alignment of output data
#line 3197
  *   - copy (conversion happens automatically) input data
#line 3197
  *     to output
#line 3197
  *   - update tp to point at next unconverted input, and xpp to point
#line 3197
  *     at next location for converted output
#line 3197
  */
#line 3197
  long i, j, ni;
#line 3197
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3197
  ushort *xp;
#line 3197
  int nrange = 0;         /* number of range errors */
#line 3197
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3197
  long cxp = (long) *((char**)xpp);
#line 3197

#line 3197
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3197
  /* sjl: manually stripmine so we can limit amount of
#line 3197
   * vector work space reserved to LOOPCNT elements. Also
#line 3197
   * makes vectorisation easy */
#line 3197
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3197
    ni=Min(nelems-j,LOOPCNT);
#line 3197
    if (realign) {
#line 3197
      xp = tmp;
#line 3197
    } else {
#line 3197
      xp = (ushort *) *xpp;
#line 3197
    }
#line 3197
   /* copy the next block */
#line 3197
#pragma cdir loopcnt=LOOPCNT
#line 3197
#pragma cdir shortloop
#line 3197
    for (i=0; i<ni; i++) {
#line 3197
      /* the normal case: */
#line 3197
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3197
     /* test for range errors (not always needed but do it anyway) */
#line 3197
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3197
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3197
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3197
    }
#line 3197
   /* copy workspace back if necessary */
#line 3197
    if (realign) {
#line 3197
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3197
      xp = (ushort *) *xpp;
#line 3197
    }
#line 3197
   /* update xpp and tp */
#line 3197
    xp += ni;
#line 3197
    tp += ni;
#line 3197
    *xpp = (void*)xp;
#line 3197
  }
#line 3197
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3197

#line 3197
#else   /* not SX */
#line 3197

#line 3197
	char *xp = (char *) *xpp;
#line 3197
	int status = NC_NOERR;
#line 3197

#line 3197
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3197
	{
#line 3197
		int lstatus = ncx_put_ushort_longlong(xp, tp, fillp);
#line 3197
		if (status == NC_NOERR) /* report the first encountered error */
#line 3197
			status = lstatus;
#line 3197
	}
#line 3197

#line 3197
	*xpp = (void *)xp;
#line 3197
	return status;
#line 3197
#endif
#line 3197
}
#line 3197

int
#line 3198
ncx_putn_ushort_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3198
{
#line 3198
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3198

#line 3198
 /* basic algorithm is:
#line 3198
  *   - ensure sane alignment of output data
#line 3198
  *   - copy (conversion happens automatically) input data
#line 3198
  *     to output
#line 3198
  *   - update tp to point at next unconverted input, and xpp to point
#line 3198
  *     at next location for converted output
#line 3198
  */
#line 3198
  long i, j, ni;
#line 3198
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3198
  ushort *xp;
#line 3198
  int nrange = 0;         /* number of range errors */
#line 3198
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3198
  long cxp = (long) *((char**)xpp);
#line 3198

#line 3198
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3198
  /* sjl: manually stripmine so we can limit amount of
#line 3198
   * vector work space reserved to LOOPCNT elements. Also
#line 3198
   * makes vectorisation easy */
#line 3198
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3198
    ni=Min(nelems-j,LOOPCNT);
#line 3198
    if (realign) {
#line 3198
      xp = tmp;
#line 3198
    } else {
#line 3198
      xp = (ushort *) *xpp;
#line 3198
    }
#line 3198
   /* copy the next block */
#line 3198
#pragma cdir loopcnt=LOOPCNT
#line 3198
#pragma cdir shortloop
#line 3198
    for (i=0; i<ni; i++) {
#line 3198
      /* the normal case: */
#line 3198
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3198
     /* test for range errors (not always needed but do it anyway) */
#line 3198
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3198
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3198
      nrange += tp[i] > X_USHORT_MAX ;
#line 3198
    }
#line 3198
   /* copy workspace back if necessary */
#line 3198
    if (realign) {
#line 3198
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3198
      xp = (ushort *) *xpp;
#line 3198
    }
#line 3198
   /* update xpp and tp */
#line 3198
    xp += ni;
#line 3198
    tp += ni;
#line 3198
    *xpp = (void*)xp;
#line 3198
  }
#line 3198
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3198

#line 3198
#else   /* not SX */
#line 3198

#line 3198
	char *xp = (char *) *xpp;
#line 3198
	int status = NC_NOERR;
#line 3198

#line 3198
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3198
	{
#line 3198
		int lstatus = ncx_put_ushort_uchar(xp, tp, fillp);
#line 3198
		if (status == NC_NOERR) /* report the first encountered error */
#line 3198
			status = lstatus;
#line 3198
	}
#line 3198

#line 3198
	*xpp = (void *)xp;
#line 3198
	return status;
#line 3198
#endif
#line 3198
}
#line 3198

int
#line 3199
ncx_putn_ushort_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3199
{
#line 3199
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3199

#line 3199
 /* basic algorithm is:
#line 3199
  *   - ensure sane alignment of output data
#line 3199
  *   - copy (conversion happens automatically) input data
#line 3199
  *     to output
#line 3199
  *   - update tp to point at next unconverted input, and xpp to point
#line 3199
  *     at next location for converted output
#line 3199
  */
#line 3199
  long i, j, ni;
#line 3199
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3199
  ushort *xp;
#line 3199
  int nrange = 0;         /* number of range errors */
#line 3199
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3199
  long cxp = (long) *((char**)xpp);
#line 3199

#line 3199
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3199
  /* sjl: manually stripmine so we can limit amount of
#line 3199
   * vector work space reserved to LOOPCNT elements. Also
#line 3199
   * makes vectorisation easy */
#line 3199
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3199
    ni=Min(nelems-j,LOOPCNT);
#line 3199
    if (realign) {
#line 3199
      xp = tmp;
#line 3199
    } else {
#line 3199
      xp = (ushort *) *xpp;
#line 3199
    }
#line 3199
   /* copy the next block */
#line 3199
#pragma cdir loopcnt=LOOPCNT
#line 3199
#pragma cdir shortloop
#line 3199
    for (i=0; i<ni; i++) {
#line 3199
      /* the normal case: */
#line 3199
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3199
     /* test for range errors (not always needed but do it anyway) */
#line 3199
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3199
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3199
      nrange += tp[i] > X_USHORT_MAX ;
#line 3199
    }
#line 3199
   /* copy workspace back if necessary */
#line 3199
    if (realign) {
#line 3199
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3199
      xp = (ushort *) *xpp;
#line 3199
    }
#line 3199
   /* update xpp and tp */
#line 3199
    xp += ni;
#line 3199
    tp += ni;
#line 3199
    *xpp = (void*)xp;
#line 3199
  }
#line 3199
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3199

#line 3199
#else   /* not SX */
#line 3199

#line 3199
	char *xp = (char *) *xpp;
#line 3199
	int status = NC_NOERR;
#line 3199

#line 3199
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3199
	{
#line 3199
		int lstatus = ncx_put_ushort_uint(xp, tp, fillp);
#line 3199
		if (status == NC_NOERR) /* report the first encountered error */
#line 3199
			status = lstatus;
#line 3199
	}
#line 3199

#line 3199
	*xpp = (void *)xp;
#line 3199
	return status;
#line 3199
#endif
#line 3199
}
#line 3199

int
#line 3200
ncx_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3200
{
#line 3200
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3200

#line 3200
 /* basic algorithm is:
#line 3200
  *   - ensure sane alignment of output data
#line 3200
  *   - copy (conversion happens automatically) input data
#line 3200
  *     to output
#line 3200
  *   - update tp to point at next unconverted input, and xpp to point
#line 3200
  *     at next location for converted output
#line 3200
  */
#line 3200
  long i, j, ni;
#line 3200
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3200
  ushort *xp;
#line 3200
  int nrange = 0;         /* number of range errors */
#line 3200
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3200
  long cxp = (long) *((char**)xpp);
#line 3200

#line 3200
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3200
  /* sjl: manually stripmine so we can limit amount of
#line 3200
   * vector work space reserved to LOOPCNT elements. Also
#line 3200
   * makes vectorisation easy */
#line 3200
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3200
    ni=Min(nelems-j,LOOPCNT);
#line 3200
    if (realign) {
#line 3200
      xp = tmp;
#line 3200
    } else {
#line 3200
      xp = (ushort *) *xpp;
#line 3200
    }
#line 3200
   /* copy the next block */
#line 3200
#pragma cdir loopcnt=LOOPCNT
#line 3200
#pragma cdir shortloop
#line 3200
    for (i=0; i<ni; i++) {
#line 3200
      /* the normal case: */
#line 3200
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3200
     /* test for range errors (not always needed but do it anyway) */
#line 3200
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3200
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3200
      nrange += tp[i] > X_USHORT_MAX ;
#line 3200
    }
#line 3200
   /* copy workspace back if necessary */
#line 3200
    if (realign) {
#line 3200
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3200
      xp = (ushort *) *xpp;
#line 3200
    }
#line 3200
   /* update xpp and tp */
#line 3200
    xp += ni;
#line 3200
    tp += ni;
#line 3200
    *xpp = (void*)xp;
#line 3200
  }
#line 3200
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3200

#line 3200
#else   /* not SX */
#line 3200

#line 3200
	char *xp = (char *) *xpp;
#line 3200
	int status = NC_NOERR;
#line 3200

#line 3200
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3200
	{
#line 3200
		int lstatus = ncx_put_ushort_ulonglong(xp, tp, fillp);
#line 3200
		if (status == NC_NOERR) /* report the first encountered error */
#line 3200
			status = lstatus;
#line 3200
	}
#line 3200

#line 3200
	*xpp = (void *)xp;
#line 3200
	return status;
#line 3200
#endif
#line 3200
}
#line 3200


int
#line 3202
ncx_pad_putn_ushort_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3202
{
#line 3202
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3202

#line 3202
	char *xp = (char *) *xpp;
#line 3202
	int status = NC_NOERR;
#line 3202

#line 3202
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3202
	{
#line 3202
		int lstatus = ncx_put_ushort_schar(xp, tp, fillp);
#line 3202
		if (status == NC_NOERR) /* report the first encountered error */
#line 3202
			status = lstatus;
#line 3202
	}
#line 3202

#line 3202
	if (rndup != 0)
#line 3202
	{
#line 3202
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3202
		xp += X_SIZEOF_USHORT;
#line 3202
	}
#line 3202

#line 3202
	*xpp = (void *)xp;
#line 3202
	return status;
#line 3202
}
#line 3202

int
#line 3203
ncx_pad_putn_ushort_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3203
{
#line 3203
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3203

#line 3203
	char *xp = (char *) *xpp;
#line 3203
	int status = NC_NOERR;
#line 3203

#line 3203
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3203
	{
#line 3203
		int lstatus = ncx_put_ushort_uchar(xp, tp, fillp);
#line 3203
		if (status == NC_NOERR) /* report the first encountered error */
#line 3203
			status = lstatus;
#line 3203
	}
#line 3203

#line 3203
	if (rndup != 0)
#line 3203
	{
#line 3203
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3203
		xp += X_SIZEOF_USHORT;
#line 3203
	}
#line 3203

#line 3203
	*xpp = (void *)xp;
#line 3203
	return status;
#line 3203
}
#line 3203

int
#line 3204
ncx_pad_putn_ushort_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3204
{
#line 3204
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3204

#line 3204
	char *xp = (char *) *xpp;
#line 3204
	int status = NC_NOERR;
#line 3204

#line 3204
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3204
	{
#line 3204
		int lstatus = ncx_put_ushort_short(xp, tp, fillp);
#line 3204
		if (status == NC_NOERR) /* report the first encountered error */
#line 3204
			status = lstatus;
#line 3204
	}
#line 3204

#line 3204
	if (rndup != 0)
#line 3204
	{
#line 3204
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3204
		xp += X_SIZEOF_USHORT;
#line 3204
	}
#line 3204

#line 3204
	*xpp = (void *)xp;
#line 3204
	return status;
#line 3204
}
#line 3204

int
#line 3205
ncx_pad_putn_ushort_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3205
{
#line 3205
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3205

#line 3205
	char *xp = (char *) *xpp;
#line 3205
	int status = NC_NOERR;
#line 3205

#line 3205
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3205
	{
#line 3205
		int lstatus = ncx_put_ushort_int(xp, tp, fillp);
#line 3205
		if (status == NC_NOERR) /* report the first encountered error */
#line 3205
			status = lstatus;
#line 3205
	}
#line 3205

#line 3205
	if (rndup != 0)
#line 3205
	{
#line 3205
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3205
		xp += X_SIZEOF_USHORT;
#line 3205
	}
#line 3205

#line 3205
	*xpp = (void *)xp;
#line 3205
	return status;
#line 3205
}
#line 3205

int
#line 3206
ncx_pad_putn_ushort_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3206
{
#line 3206
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3206

#line 3206
	char *xp = (char *) *xpp;
#line 3206
	int status = NC_NOERR;
#line 3206

#line 3206
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3206
	{
#line 3206
		int lstatus = ncx_put_ushort_long(xp, tp, fillp);
#line 3206
		if (status == NC_NOERR) /* report the first encountered error */
#line 3206
			status = lstatus;
#line 3206
	}
#line 3206

#line 3206
	if (rndup != 0)
#line 3206
	{
#line 3206
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3206
		xp += X_SIZEOF_USHORT;
#line 3206
	}
#line 3206

#line 3206
	*xpp = (void *)xp;
#line 3206
	return status;
#line 3206
}
#line 3206

int
#line 3207
ncx_pad_putn_ushort_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3207
{
#line 3207
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3207

#line 3207
	char *xp = (char *) *xpp;
#line 3207
	int status = NC_NOERR;
#line 3207

#line 3207
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3207
	{
#line 3207
		int lstatus = ncx_put_ushort_float(xp, tp, fillp);
#line 3207
		if (status == NC_NOERR) /* report the first encountered error */
#line 3207
			status = lstatus;
#line 3207
	}
#line 3207

#line 3207
	if (rndup != 0)
#line 3207
	{
#line 3207
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3207
		xp += X_SIZEOF_USHORT;
#line 3207
	}
#line 3207

#line 3207
	*xpp = (void *)xp;
#line 3207
	return status;
#line 3207
}
#line 3207

int
#line 3208
ncx_pad_putn_ushort_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3208
{
#line 3208
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3208

#line 3208
	char *xp = (char *) *xpp;
#line 3208
	int status = NC_NOERR;
#line 3208

#line 3208
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3208
	{
#line 3208
		int lstatus = ncx_put_ushort_double(xp, tp, fillp);
#line 3208
		if (status == NC_NOERR) /* report the first encountered error */
#line 3208
			status = lstatus;
#line 3208
	}
#line 3208

#line 3208
	if (rndup != 0)
#line 3208
	{
#line 3208
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3208
		xp += X_SIZEOF_USHORT;
#line 3208
	}
#line 3208

#line 3208
	*xpp = (void *)xp;
#line 3208
	return status;
#line 3208
}
#line 3208

int
#line 3209
ncx_pad_putn_ushort_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3209
{
#line 3209
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3209

#line 3209
	char *xp = (char *) *xpp;
#line 3209
	int status = NC_NOERR;
#line 3209

#line 3209
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3209
	{
#line 3209
		int lstatus = ncx_put_ushort_uint(xp, tp, fillp);
#line 3209
		if (status == NC_NOERR) /* report the first encountered error */
#line 3209
			status = lstatus;
#line 3209
	}
#line 3209

#line 3209
	if (rndup != 0)
#line 3209
	{
#line 3209
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3209
		xp += X_SIZEOF_USHORT;
#line 3209
	}
#line 3209

#line 3209
	*xpp = (void *)xp;
#line 3209
	return status;
#line 3209
}
#line 3209

int
#line 3210
ncx_pad_putn_ushort_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3210
{
#line 3210
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3210

#line 3210
	char *xp = (char *) *xpp;
#line 3210
	int status = NC_NOERR;
#line 3210

#line 3210
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3210
	{
#line 3210
		int lstatus = ncx_put_ushort_longlong(xp, tp, fillp);
#line 3210
		if (status == NC_NOERR) /* report the first encountered error */
#line 3210
			status = lstatus;
#line 3210
	}
#line 3210

#line 3210
	if (rndup != 0)
#line 3210
	{
#line 3210
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3210
		xp += X_SIZEOF_USHORT;
#line 3210
	}
#line 3210

#line 3210
	*xpp = (void *)xp;
#line 3210
	return status;
#line 3210
}
#line 3210

int
#line 3211
ncx_pad_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3211
{
#line 3211
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3211

#line 3211
	char *xp = (char *) *xpp;
#line 3211
	int status = NC_NOERR;
#line 3211

#line 3211
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3211
	{
#line 3211
		int lstatus = ncx_put_ushort_ulonglong(xp, tp, fillp);
#line 3211
		if (status == NC_NOERR) /* report the first encountered error */
#line 3211
			status = lstatus;
#line 3211
	}
#line 3211

#line 3211
	if (rndup != 0)
#line 3211
	{
#line 3211
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3211
		xp += X_SIZEOF_USHORT;
#line 3211
	}
#line 3211

#line 3211
	*xpp = (void *)xp;
#line 3211
	return status;
#line 3211
}
#line 3211

int
#line 3212
ncx_pad_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3212
{
#line 3212
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3212

#line 3212
	char *xp = (char *) *xpp;
#line 3212
	int status = NC_NOERR;
#line 3212

#line 3212
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3212
	{
#line 3212
		int lstatus = ncx_put_ushort_ushort(xp, tp, fillp);
#line 3212
		if (status == NC_NOERR) /* report the first encountered error */
#line 3212
			status = lstatus;
#line 3212
	}
#line 3212

#line 3212
	if (rndup != 0)
#line 3212
	{
#line 3212
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3212
		xp += X_SIZEOF_USHORT;
#line 3212
	}
#line 3212

#line 3212
	*xpp = (void *)xp;
#line 3212
	return status;
#line 3212
}
#line 3212



/* int -----------------------------------------------------------------------*/

#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_INT);
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_INT);
	return NC_NOERR;
}
#else
int
#line 3231
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
#line 3231
{
#line 3231
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3231

#line 3231
 /* basic algorithm is:
#line 3231
  *   - ensure sane alignment of input data
#line 3231
  *   - copy (conversion happens automatically) input data
#line 3231
  *     to output
#line 3231
  *   - update xpp to point at next unconverted input, and tp to point
#line 3231
  *     at next location for converted output
#line 3231
  */
#line 3231
  long i, j, ni;
#line 3231
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3231
  int *xp;
#line 3231
  int nrange = 0;         /* number of range errors */
#line 3231
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3231
  long cxp = (long) *((char**)xpp);
#line 3231

#line 3231
  realign = (cxp & 7) % SIZEOF_INT;
#line 3231
  /* sjl: manually stripmine so we can limit amount of
#line 3231
   * vector work space reserved to LOOPCNT elements. Also
#line 3231
   * makes vectorisation easy */
#line 3231
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3231
    ni=Min(nelems-j,LOOPCNT);
#line 3231
    if (realign) {
#line 3231
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3231
      xp = tmp;
#line 3231
    } else {
#line 3231
      xp = (int *) *xpp;
#line 3231
    }
#line 3231
   /* copy the next block */
#line 3231
#pragma cdir loopcnt=LOOPCNT
#line 3231
#pragma cdir shortloop
#line 3231
    for (i=0; i<ni; i++) {
#line 3231
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3231
     /* test for range errors (not always needed but do it anyway) */
#line 3231
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3231
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3231
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3231
    }
#line 3231
   /* update xpp and tp */
#line 3231
    if (realign) xp = (int *) *xpp;
#line 3231
    xp += ni;
#line 3231
    tp += ni;
#line 3231
    *xpp = (void*)xp;
#line 3231
  }
#line 3231
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3231

#line 3231
#else   /* not SX */
#line 3231
	const char *xp = (const char *) *xpp;
#line 3231
	int status = NC_NOERR;
#line 3231

#line 3231
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3231
	{
#line 3231
		const int lstatus = ncx_get_int_int(xp, tp);
#line 3231
		if (status == NC_NOERR) /* report the first encountered error */
#line 3231
			status = lstatus;
#line 3231
	}
#line 3231

#line 3231
	*xpp = (const void *)xp;
#line 3231
	return status;
#line 3231
#endif
#line 3231
}
#line 3231

#endif
int
#line 3233
ncx_getn_int_schar(const void **xpp, size_t nelems, schar *tp)
#line 3233
{
#line 3233
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3233

#line 3233
 /* basic algorithm is:
#line 3233
  *   - ensure sane alignment of input data
#line 3233
  *   - copy (conversion happens automatically) input data
#line 3233
  *     to output
#line 3233
  *   - update xpp to point at next unconverted input, and tp to point
#line 3233
  *     at next location for converted output
#line 3233
  */
#line 3233
  long i, j, ni;
#line 3233
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3233
  int *xp;
#line 3233
  int nrange = 0;         /* number of range errors */
#line 3233
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3233
  long cxp = (long) *((char**)xpp);
#line 3233

#line 3233
  realign = (cxp & 7) % SIZEOF_INT;
#line 3233
  /* sjl: manually stripmine so we can limit amount of
#line 3233
   * vector work space reserved to LOOPCNT elements. Also
#line 3233
   * makes vectorisation easy */
#line 3233
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3233
    ni=Min(nelems-j,LOOPCNT);
#line 3233
    if (realign) {
#line 3233
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3233
      xp = tmp;
#line 3233
    } else {
#line 3233
      xp = (int *) *xpp;
#line 3233
    }
#line 3233
   /* copy the next block */
#line 3233
#pragma cdir loopcnt=LOOPCNT
#line 3233
#pragma cdir shortloop
#line 3233
    for (i=0; i<ni; i++) {
#line 3233
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3233
     /* test for range errors (not always needed but do it anyway) */
#line 3233
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3233
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3233
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3233
    }
#line 3233
   /* update xpp and tp */
#line 3233
    if (realign) xp = (int *) *xpp;
#line 3233
    xp += ni;
#line 3233
    tp += ni;
#line 3233
    *xpp = (void*)xp;
#line 3233
  }
#line 3233
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3233

#line 3233
#else   /* not SX */
#line 3233
	const char *xp = (const char *) *xpp;
#line 3233
	int status = NC_NOERR;
#line 3233

#line 3233
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3233
	{
#line 3233
		const int lstatus = ncx_get_int_schar(xp, tp);
#line 3233
		if (status == NC_NOERR) /* report the first encountered error */
#line 3233
			status = lstatus;
#line 3233
	}
#line 3233

#line 3233
	*xpp = (const void *)xp;
#line 3233
	return status;
#line 3233
#endif
#line 3233
}
#line 3233

int
#line 3234
ncx_getn_int_short(const void **xpp, size_t nelems, short *tp)
#line 3234
{
#line 3234
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3234

#line 3234
 /* basic algorithm is:
#line 3234
  *   - ensure sane alignment of input data
#line 3234
  *   - copy (conversion happens automatically) input data
#line 3234
  *     to output
#line 3234
  *   - update xpp to point at next unconverted input, and tp to point
#line 3234
  *     at next location for converted output
#line 3234
  */
#line 3234
  long i, j, ni;
#line 3234
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3234
  int *xp;
#line 3234
  int nrange = 0;         /* number of range errors */
#line 3234
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3234
  long cxp = (long) *((char**)xpp);
#line 3234

#line 3234
  realign = (cxp & 7) % SIZEOF_INT;
#line 3234
  /* sjl: manually stripmine so we can limit amount of
#line 3234
   * vector work space reserved to LOOPCNT elements. Also
#line 3234
   * makes vectorisation easy */
#line 3234
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3234
    ni=Min(nelems-j,LOOPCNT);
#line 3234
    if (realign) {
#line 3234
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3234
      xp = tmp;
#line 3234
    } else {
#line 3234
      xp = (int *) *xpp;
#line 3234
    }
#line 3234
   /* copy the next block */
#line 3234
#pragma cdir loopcnt=LOOPCNT
#line 3234
#pragma cdir shortloop
#line 3234
    for (i=0; i<ni; i++) {
#line 3234
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3234
     /* test for range errors (not always needed but do it anyway) */
#line 3234
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3234
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3234
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3234
    }
#line 3234
   /* update xpp and tp */
#line 3234
    if (realign) xp = (int *) *xpp;
#line 3234
    xp += ni;
#line 3234
    tp += ni;
#line 3234
    *xpp = (void*)xp;
#line 3234
  }
#line 3234
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3234

#line 3234
#else   /* not SX */
#line 3234
	const char *xp = (const char *) *xpp;
#line 3234
	int status = NC_NOERR;
#line 3234

#line 3234
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3234
	{
#line 3234
		const int lstatus = ncx_get_int_short(xp, tp);
#line 3234
		if (status == NC_NOERR) /* report the first encountered error */
#line 3234
			status = lstatus;
#line 3234
	}
#line 3234

#line 3234
	*xpp = (const void *)xp;
#line 3234
	return status;
#line 3234
#endif
#line 3234
}
#line 3234

int
#line 3235
ncx_getn_int_long(const void **xpp, size_t nelems, long *tp)
#line 3235
{
#line 3235
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3235

#line 3235
 /* basic algorithm is:
#line 3235
  *   - ensure sane alignment of input data
#line 3235
  *   - copy (conversion happens automatically) input data
#line 3235
  *     to output
#line 3235
  *   - update xpp to point at next unconverted input, and tp to point
#line 3235
  *     at next location for converted output
#line 3235
  */
#line 3235
  long i, j, ni;
#line 3235
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3235
  int *xp;
#line 3235
  int nrange = 0;         /* number of range errors */
#line 3235
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3235
  long cxp = (long) *((char**)xpp);
#line 3235

#line 3235
  realign = (cxp & 7) % SIZEOF_INT;
#line 3235
  /* sjl: manually stripmine so we can limit amount of
#line 3235
   * vector work space reserved to LOOPCNT elements. Also
#line 3235
   * makes vectorisation easy */
#line 3235
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3235
    ni=Min(nelems-j,LOOPCNT);
#line 3235
    if (realign) {
#line 3235
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3235
      xp = tmp;
#line 3235
    } else {
#line 3235
      xp = (int *) *xpp;
#line 3235
    }
#line 3235
   /* copy the next block */
#line 3235
#pragma cdir loopcnt=LOOPCNT
#line 3235
#pragma cdir shortloop
#line 3235
    for (i=0; i<ni; i++) {
#line 3235
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3235
     /* test for range errors (not always needed but do it anyway) */
#line 3235
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3235
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3235
      nrange += xp[i] > LONG_MAX || xp[i] < LONG_MIN;
#line 3235
    }
#line 3235
   /* update xpp and tp */
#line 3235
    if (realign) xp = (int *) *xpp;
#line 3235
    xp += ni;
#line 3235
    tp += ni;
#line 3235
    *xpp = (void*)xp;
#line 3235
  }
#line 3235
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3235

#line 3235
#else   /* not SX */
#line 3235
	const char *xp = (const char *) *xpp;
#line 3235
	int status = NC_NOERR;
#line 3235

#line 3235
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3235
	{
#line 3235
		const int lstatus = ncx_get_int_long(xp, tp);
#line 3235
		if (status == NC_NOERR) /* report the first encountered error */
#line 3235
			status = lstatus;
#line 3235
	}
#line 3235

#line 3235
	*xpp = (const void *)xp;
#line 3235
	return status;
#line 3235
#endif
#line 3235
}
#line 3235

int
#line 3236
ncx_getn_int_float(const void **xpp, size_t nelems, float *tp)
#line 3236
{
#line 3236
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3236

#line 3236
 /* basic algorithm is:
#line 3236
  *   - ensure sane alignment of input data
#line 3236
  *   - copy (conversion happens automatically) input data
#line 3236
  *     to output
#line 3236
  *   - update xpp to point at next unconverted input, and tp to point
#line 3236
  *     at next location for converted output
#line 3236
  */
#line 3236
  long i, j, ni;
#line 3236
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3236
  int *xp;
#line 3236
  int nrange = 0;         /* number of range errors */
#line 3236
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3236
  long cxp = (long) *((char**)xpp);
#line 3236

#line 3236
  realign = (cxp & 7) % SIZEOF_INT;
#line 3236
  /* sjl: manually stripmine so we can limit amount of
#line 3236
   * vector work space reserved to LOOPCNT elements. Also
#line 3236
   * makes vectorisation easy */
#line 3236
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3236
    ni=Min(nelems-j,LOOPCNT);
#line 3236
    if (realign) {
#line 3236
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3236
      xp = tmp;
#line 3236
    } else {
#line 3236
      xp = (int *) *xpp;
#line 3236
    }
#line 3236
   /* copy the next block */
#line 3236
#pragma cdir loopcnt=LOOPCNT
#line 3236
#pragma cdir shortloop
#line 3236
    for (i=0; i<ni; i++) {
#line 3236
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3236
     /* test for range errors (not always needed but do it anyway) */
#line 3236
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3236
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3236
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3236
    }
#line 3236
   /* update xpp and tp */
#line 3236
    if (realign) xp = (int *) *xpp;
#line 3236
    xp += ni;
#line 3236
    tp += ni;
#line 3236
    *xpp = (void*)xp;
#line 3236
  }
#line 3236
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3236

#line 3236
#else   /* not SX */
#line 3236
	const char *xp = (const char *) *xpp;
#line 3236
	int status = NC_NOERR;
#line 3236

#line 3236
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3236
	{
#line 3236
		const int lstatus = ncx_get_int_float(xp, tp);
#line 3236
		if (status == NC_NOERR) /* report the first encountered error */
#line 3236
			status = lstatus;
#line 3236
	}
#line 3236

#line 3236
	*xpp = (const void *)xp;
#line 3236
	return status;
#line 3236
#endif
#line 3236
}
#line 3236

int
#line 3237
ncx_getn_int_double(const void **xpp, size_t nelems, double *tp)
#line 3237
{
#line 3237
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3237

#line 3237
 /* basic algorithm is:
#line 3237
  *   - ensure sane alignment of input data
#line 3237
  *   - copy (conversion happens automatically) input data
#line 3237
  *     to output
#line 3237
  *   - update xpp to point at next unconverted input, and tp to point
#line 3237
  *     at next location for converted output
#line 3237
  */
#line 3237
  long i, j, ni;
#line 3237
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3237
  int *xp;
#line 3237
  int nrange = 0;         /* number of range errors */
#line 3237
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3237
  long cxp = (long) *((char**)xpp);
#line 3237

#line 3237
  realign = (cxp & 7) % SIZEOF_INT;
#line 3237
  /* sjl: manually stripmine so we can limit amount of
#line 3237
   * vector work space reserved to LOOPCNT elements. Also
#line 3237
   * makes vectorisation easy */
#line 3237
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3237
    ni=Min(nelems-j,LOOPCNT);
#line 3237
    if (realign) {
#line 3237
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3237
      xp = tmp;
#line 3237
    } else {
#line 3237
      xp = (int *) *xpp;
#line 3237
    }
#line 3237
   /* copy the next block */
#line 3237
#pragma cdir loopcnt=LOOPCNT
#line 3237
#pragma cdir shortloop
#line 3237
    for (i=0; i<ni; i++) {
#line 3237
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3237
     /* test for range errors (not always needed but do it anyway) */
#line 3237
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3237
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3237
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3237
    }
#line 3237
   /* update xpp and tp */
#line 3237
    if (realign) xp = (int *) *xpp;
#line 3237
    xp += ni;
#line 3237
    tp += ni;
#line 3237
    *xpp = (void*)xp;
#line 3237
  }
#line 3237
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3237

#line 3237
#else   /* not SX */
#line 3237
	const char *xp = (const char *) *xpp;
#line 3237
	int status = NC_NOERR;
#line 3237

#line 3237
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3237
	{
#line 3237
		const int lstatus = ncx_get_int_double(xp, tp);
#line 3237
		if (status == NC_NOERR) /* report the first encountered error */
#line 3237
			status = lstatus;
#line 3237
	}
#line 3237

#line 3237
	*xpp = (const void *)xp;
#line 3237
	return status;
#line 3237
#endif
#line 3237
}
#line 3237

int
#line 3238
ncx_getn_int_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3238
{
#line 3238
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3238

#line 3238
 /* basic algorithm is:
#line 3238
  *   - ensure sane alignment of input data
#line 3238
  *   - copy (conversion happens automatically) input data
#line 3238
  *     to output
#line 3238
  *   - update xpp to point at next unconverted input, and tp to point
#line 3238
  *     at next location for converted output
#line 3238
  */
#line 3238
  long i, j, ni;
#line 3238
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3238
  int *xp;
#line 3238
  int nrange = 0;         /* number of range errors */
#line 3238
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3238
  long cxp = (long) *((char**)xpp);
#line 3238

#line 3238
  realign = (cxp & 7) % SIZEOF_INT;
#line 3238
  /* sjl: manually stripmine so we can limit amount of
#line 3238
   * vector work space reserved to LOOPCNT elements. Also
#line 3238
   * makes vectorisation easy */
#line 3238
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3238
    ni=Min(nelems-j,LOOPCNT);
#line 3238
    if (realign) {
#line 3238
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3238
      xp = tmp;
#line 3238
    } else {
#line 3238
      xp = (int *) *xpp;
#line 3238
    }
#line 3238
   /* copy the next block */
#line 3238
#pragma cdir loopcnt=LOOPCNT
#line 3238
#pragma cdir shortloop
#line 3238
    for (i=0; i<ni; i++) {
#line 3238
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3238
     /* test for range errors (not always needed but do it anyway) */
#line 3238
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3238
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3238
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3238
    }
#line 3238
   /* update xpp and tp */
#line 3238
    if (realign) xp = (int *) *xpp;
#line 3238
    xp += ni;
#line 3238
    tp += ni;
#line 3238
    *xpp = (void*)xp;
#line 3238
  }
#line 3238
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3238

#line 3238
#else   /* not SX */
#line 3238
	const char *xp = (const char *) *xpp;
#line 3238
	int status = NC_NOERR;
#line 3238

#line 3238
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3238
	{
#line 3238
		const int lstatus = ncx_get_int_longlong(xp, tp);
#line 3238
		if (status == NC_NOERR) /* report the first encountered error */
#line 3238
			status = lstatus;
#line 3238
	}
#line 3238

#line 3238
	*xpp = (const void *)xp;
#line 3238
	return status;
#line 3238
#endif
#line 3238
}
#line 3238

int
#line 3239
ncx_getn_int_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3239
{
#line 3239
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3239

#line 3239
 /* basic algorithm is:
#line 3239
  *   - ensure sane alignment of input data
#line 3239
  *   - copy (conversion happens automatically) input data
#line 3239
  *     to output
#line 3239
  *   - update xpp to point at next unconverted input, and tp to point
#line 3239
  *     at next location for converted output
#line 3239
  */
#line 3239
  long i, j, ni;
#line 3239
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3239
  int *xp;
#line 3239
  int nrange = 0;         /* number of range errors */
#line 3239
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3239
  long cxp = (long) *((char**)xpp);
#line 3239

#line 3239
  realign = (cxp & 7) % SIZEOF_INT;
#line 3239
  /* sjl: manually stripmine so we can limit amount of
#line 3239
   * vector work space reserved to LOOPCNT elements. Also
#line 3239
   * makes vectorisation easy */
#line 3239
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3239
    ni=Min(nelems-j,LOOPCNT);
#line 3239
    if (realign) {
#line 3239
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3239
      xp = tmp;
#line 3239
    } else {
#line 3239
      xp = (int *) *xpp;
#line 3239
    }
#line 3239
   /* copy the next block */
#line 3239
#pragma cdir loopcnt=LOOPCNT
#line 3239
#pragma cdir shortloop
#line 3239
    for (i=0; i<ni; i++) {
#line 3239
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3239
     /* test for range errors (not always needed but do it anyway) */
#line 3239
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3239
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3239
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3239
    }
#line 3239
   /* update xpp and tp */
#line 3239
    if (realign) xp = (int *) *xpp;
#line 3239
    xp += ni;
#line 3239
    tp += ni;
#line 3239
    *xpp = (void*)xp;
#line 3239
  }
#line 3239
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3239

#line 3239
#else   /* not SX */
#line 3239
	const char *xp = (const char *) *xpp;
#line 3239
	int status = NC_NOERR;
#line 3239

#line 3239
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3239
	{
#line 3239
		const int lstatus = ncx_get_int_uchar(xp, tp);
#line 3239
		if (status == NC_NOERR) /* report the first encountered error */
#line 3239
			status = lstatus;
#line 3239
	}
#line 3239

#line 3239
	*xpp = (const void *)xp;
#line 3239
	return status;
#line 3239
#endif
#line 3239
}
#line 3239

int
#line 3240
ncx_getn_int_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3240
{
#line 3240
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3240

#line 3240
 /* basic algorithm is:
#line 3240
  *   - ensure sane alignment of input data
#line 3240
  *   - copy (conversion happens automatically) input data
#line 3240
  *     to output
#line 3240
  *   - update xpp to point at next unconverted input, and tp to point
#line 3240
  *     at next location for converted output
#line 3240
  */
#line 3240
  long i, j, ni;
#line 3240
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3240
  int *xp;
#line 3240
  int nrange = 0;         /* number of range errors */
#line 3240
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3240
  long cxp = (long) *((char**)xpp);
#line 3240

#line 3240
  realign = (cxp & 7) % SIZEOF_INT;
#line 3240
  /* sjl: manually stripmine so we can limit amount of
#line 3240
   * vector work space reserved to LOOPCNT elements. Also
#line 3240
   * makes vectorisation easy */
#line 3240
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3240
    ni=Min(nelems-j,LOOPCNT);
#line 3240
    if (realign) {
#line 3240
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3240
      xp = tmp;
#line 3240
    } else {
#line 3240
      xp = (int *) *xpp;
#line 3240
    }
#line 3240
   /* copy the next block */
#line 3240
#pragma cdir loopcnt=LOOPCNT
#line 3240
#pragma cdir shortloop
#line 3240
    for (i=0; i<ni; i++) {
#line 3240
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3240
     /* test for range errors (not always needed but do it anyway) */
#line 3240
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3240
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3240
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3240
    }
#line 3240
   /* update xpp and tp */
#line 3240
    if (realign) xp = (int *) *xpp;
#line 3240
    xp += ni;
#line 3240
    tp += ni;
#line 3240
    *xpp = (void*)xp;
#line 3240
  }
#line 3240
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3240

#line 3240
#else   /* not SX */
#line 3240
	const char *xp = (const char *) *xpp;
#line 3240
	int status = NC_NOERR;
#line 3240

#line 3240
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3240
	{
#line 3240
		const int lstatus = ncx_get_int_ushort(xp, tp);
#line 3240
		if (status == NC_NOERR) /* report the first encountered error */
#line 3240
			status = lstatus;
#line 3240
	}
#line 3240

#line 3240
	*xpp = (const void *)xp;
#line 3240
	return status;
#line 3240
#endif
#line 3240
}
#line 3240

int
#line 3241
ncx_getn_int_uint(const void **xpp, size_t nelems, uint *tp)
#line 3241
{
#line 3241
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3241

#line 3241
 /* basic algorithm is:
#line 3241
  *   - ensure sane alignment of input data
#line 3241
  *   - copy (conversion happens automatically) input data
#line 3241
  *     to output
#line 3241
  *   - update xpp to point at next unconverted input, and tp to point
#line 3241
  *     at next location for converted output
#line 3241
  */
#line 3241
  long i, j, ni;
#line 3241
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3241
  int *xp;
#line 3241
  int nrange = 0;         /* number of range errors */
#line 3241
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3241
  long cxp = (long) *((char**)xpp);
#line 3241

#line 3241
  realign = (cxp & 7) % SIZEOF_INT;
#line 3241
  /* sjl: manually stripmine so we can limit amount of
#line 3241
   * vector work space reserved to LOOPCNT elements. Also
#line 3241
   * makes vectorisation easy */
#line 3241
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3241
    ni=Min(nelems-j,LOOPCNT);
#line 3241
    if (realign) {
#line 3241
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3241
      xp = tmp;
#line 3241
    } else {
#line 3241
      xp = (int *) *xpp;
#line 3241
    }
#line 3241
   /* copy the next block */
#line 3241
#pragma cdir loopcnt=LOOPCNT
#line 3241
#pragma cdir shortloop
#line 3241
    for (i=0; i<ni; i++) {
#line 3241
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3241
     /* test for range errors (not always needed but do it anyway) */
#line 3241
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3241
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3241
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3241
    }
#line 3241
   /* update xpp and tp */
#line 3241
    if (realign) xp = (int *) *xpp;
#line 3241
    xp += ni;
#line 3241
    tp += ni;
#line 3241
    *xpp = (void*)xp;
#line 3241
  }
#line 3241
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3241

#line 3241
#else   /* not SX */
#line 3241
	const char *xp = (const char *) *xpp;
#line 3241
	int status = NC_NOERR;
#line 3241

#line 3241
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3241
	{
#line 3241
		const int lstatus = ncx_get_int_uint(xp, tp);
#line 3241
		if (status == NC_NOERR) /* report the first encountered error */
#line 3241
			status = lstatus;
#line 3241
	}
#line 3241

#line 3241
	*xpp = (const void *)xp;
#line 3241
	return status;
#line 3241
#endif
#line 3241
}
#line 3241

int
#line 3242
ncx_getn_int_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3242
{
#line 3242
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3242

#line 3242
 /* basic algorithm is:
#line 3242
  *   - ensure sane alignment of input data
#line 3242
  *   - copy (conversion happens automatically) input data
#line 3242
  *     to output
#line 3242
  *   - update xpp to point at next unconverted input, and tp to point
#line 3242
  *     at next location for converted output
#line 3242
  */
#line 3242
  long i, j, ni;
#line 3242
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3242
  int *xp;
#line 3242
  int nrange = 0;         /* number of range errors */
#line 3242
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3242
  long cxp = (long) *((char**)xpp);
#line 3242

#line 3242
  realign = (cxp & 7) % SIZEOF_INT;
#line 3242
  /* sjl: manually stripmine so we can limit amount of
#line 3242
   * vector work space reserved to LOOPCNT elements. Also
#line 3242
   * makes vectorisation easy */
#line 3242
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3242
    ni=Min(nelems-j,LOOPCNT);
#line 3242
    if (realign) {
#line 3242
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3242
      xp = tmp;
#line 3242
    } else {
#line 3242
      xp = (int *) *xpp;
#line 3242
    }
#line 3242
   /* copy the next block */
#line 3242
#pragma cdir loopcnt=LOOPCNT
#line 3242
#pragma cdir shortloop
#line 3242
    for (i=0; i<ni; i++) {
#line 3242
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3242
     /* test for range errors (not always needed but do it anyway) */
#line 3242
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3242
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3242
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3242
    }
#line 3242
   /* update xpp and tp */
#line 3242
    if (realign) xp = (int *) *xpp;
#line 3242
    xp += ni;
#line 3242
    tp += ni;
#line 3242
    *xpp = (void*)xp;
#line 3242
  }
#line 3242
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3242

#line 3242
#else   /* not SX */
#line 3242
	const char *xp = (const char *) *xpp;
#line 3242
	int status = NC_NOERR;
#line 3242

#line 3242
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3242
	{
#line 3242
		const int lstatus = ncx_get_int_ulonglong(xp, tp);
#line 3242
		if (status == NC_NOERR) /* report the first encountered error */
#line 3242
			status = lstatus;
#line 3242
	}
#line 3242

#line 3242
	*xpp = (const void *)xp;
#line 3242
	return status;
#line 3242
#endif
#line 3242
}
#line 3242


#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_INT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT);
	return NC_NOERR;
}
#else
int
#line 3258
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3258
{
#line 3258
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3258

#line 3258
 /* basic algorithm is:
#line 3258
  *   - ensure sane alignment of output data
#line 3258
  *   - copy (conversion happens automatically) input data
#line 3258
  *     to output
#line 3258
  *   - update tp to point at next unconverted input, and xpp to point
#line 3258
  *     at next location for converted output
#line 3258
  */
#line 3258
  long i, j, ni;
#line 3258
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3258
  int *xp;
#line 3258
  int nrange = 0;         /* number of range errors */
#line 3258
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3258
  long cxp = (long) *((char**)xpp);
#line 3258

#line 3258
  realign = (cxp & 7) % SIZEOF_INT;
#line 3258
  /* sjl: manually stripmine so we can limit amount of
#line 3258
   * vector work space reserved to LOOPCNT elements. Also
#line 3258
   * makes vectorisation easy */
#line 3258
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3258
    ni=Min(nelems-j,LOOPCNT);
#line 3258
    if (realign) {
#line 3258
      xp = tmp;
#line 3258
    } else {
#line 3258
      xp = (int *) *xpp;
#line 3258
    }
#line 3258
   /* copy the next block */
#line 3258
#pragma cdir loopcnt=LOOPCNT
#line 3258
#pragma cdir shortloop
#line 3258
    for (i=0; i<ni; i++) {
#line 3258
      /* the normal case: */
#line 3258
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3258
     /* test for range errors (not always needed but do it anyway) */
#line 3258
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3258
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3258
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3258
    }
#line 3258
   /* copy workspace back if necessary */
#line 3258
    if (realign) {
#line 3258
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3258
      xp = (int *) *xpp;
#line 3258
    }
#line 3258
   /* update xpp and tp */
#line 3258
    xp += ni;
#line 3258
    tp += ni;
#line 3258
    *xpp = (void*)xp;
#line 3258
  }
#line 3258
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3258

#line 3258
#else   /* not SX */
#line 3258

#line 3258
	char *xp = (char *) *xpp;
#line 3258
	int status = NC_NOERR;
#line 3258

#line 3258
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3258
	{
#line 3258
		int lstatus = ncx_put_int_int(xp, tp, fillp);
#line 3258
		if (status == NC_NOERR) /* report the first encountered error */
#line 3258
			status = lstatus;
#line 3258
	}
#line 3258

#line 3258
	*xpp = (void *)xp;
#line 3258
	return status;
#line 3258
#endif
#line 3258
}
#line 3258

#endif
int
#line 3260
ncx_putn_int_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3260
{
#line 3260
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3260

#line 3260
 /* basic algorithm is:
#line 3260
  *   - ensure sane alignment of output data
#line 3260
  *   - copy (conversion happens automatically) input data
#line 3260
  *     to output
#line 3260
  *   - update tp to point at next unconverted input, and xpp to point
#line 3260
  *     at next location for converted output
#line 3260
  */
#line 3260
  long i, j, ni;
#line 3260
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3260
  int *xp;
#line 3260
  int nrange = 0;         /* number of range errors */
#line 3260
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3260
  long cxp = (long) *((char**)xpp);
#line 3260

#line 3260
  realign = (cxp & 7) % SIZEOF_INT;
#line 3260
  /* sjl: manually stripmine so we can limit amount of
#line 3260
   * vector work space reserved to LOOPCNT elements. Also
#line 3260
   * makes vectorisation easy */
#line 3260
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3260
    ni=Min(nelems-j,LOOPCNT);
#line 3260
    if (realign) {
#line 3260
      xp = tmp;
#line 3260
    } else {
#line 3260
      xp = (int *) *xpp;
#line 3260
    }
#line 3260
   /* copy the next block */
#line 3260
#pragma cdir loopcnt=LOOPCNT
#line 3260
#pragma cdir shortloop
#line 3260
    for (i=0; i<ni; i++) {
#line 3260
      /* the normal case: */
#line 3260
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3260
     /* test for range errors (not always needed but do it anyway) */
#line 3260
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3260
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3260
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3260
    }
#line 3260
   /* copy workspace back if necessary */
#line 3260
    if (realign) {
#line 3260
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3260
      xp = (int *) *xpp;
#line 3260
    }
#line 3260
   /* update xpp and tp */
#line 3260
    xp += ni;
#line 3260
    tp += ni;
#line 3260
    *xpp = (void*)xp;
#line 3260
  }
#line 3260
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3260

#line 3260
#else   /* not SX */
#line 3260

#line 3260
	char *xp = (char *) *xpp;
#line 3260
	int status = NC_NOERR;
#line 3260

#line 3260
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3260
	{
#line 3260
		int lstatus = ncx_put_int_schar(xp, tp, fillp);
#line 3260
		if (status == NC_NOERR) /* report the first encountered error */
#line 3260
			status = lstatus;
#line 3260
	}
#line 3260

#line 3260
	*xpp = (void *)xp;
#line 3260
	return status;
#line 3260
#endif
#line 3260
}
#line 3260

int
#line 3261
ncx_putn_int_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3261
{
#line 3261
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3261

#line 3261
 /* basic algorithm is:
#line 3261
  *   - ensure sane alignment of output data
#line 3261
  *   - copy (conversion happens automatically) input data
#line 3261
  *     to output
#line 3261
  *   - update tp to point at next unconverted input, and xpp to point
#line 3261
  *     at next location for converted output
#line 3261
  */
#line 3261
  long i, j, ni;
#line 3261
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3261
  int *xp;
#line 3261
  int nrange = 0;         /* number of range errors */
#line 3261
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3261
  long cxp = (long) *((char**)xpp);
#line 3261

#line 3261
  realign = (cxp & 7) % SIZEOF_INT;
#line 3261
  /* sjl: manually stripmine so we can limit amount of
#line 3261
   * vector work space reserved to LOOPCNT elements. Also
#line 3261
   * makes vectorisation easy */
#line 3261
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3261
    ni=Min(nelems-j,LOOPCNT);
#line 3261
    if (realign) {
#line 3261
      xp = tmp;
#line 3261
    } else {
#line 3261
      xp = (int *) *xpp;
#line 3261
    }
#line 3261
   /* copy the next block */
#line 3261
#pragma cdir loopcnt=LOOPCNT
#line 3261
#pragma cdir shortloop
#line 3261
    for (i=0; i<ni; i++) {
#line 3261
      /* the normal case: */
#line 3261
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3261
     /* test for range errors (not always needed but do it anyway) */
#line 3261
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3261
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3261
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3261
    }
#line 3261
   /* copy workspace back if necessary */
#line 3261
    if (realign) {
#line 3261
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3261
      xp = (int *) *xpp;
#line 3261
    }
#line 3261
   /* update xpp and tp */
#line 3261
    xp += ni;
#line 3261
    tp += ni;
#line 3261
    *xpp = (void*)xp;
#line 3261
  }
#line 3261
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3261

#line 3261
#else   /* not SX */
#line 3261

#line 3261
	char *xp = (char *) *xpp;
#line 3261
	int status = NC_NOERR;
#line 3261

#line 3261
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3261
	{
#line 3261
		int lstatus = ncx_put_int_short(xp, tp, fillp);
#line 3261
		if (status == NC_NOERR) /* report the first encountered error */
#line 3261
			status = lstatus;
#line 3261
	}
#line 3261

#line 3261
	*xpp = (void *)xp;
#line 3261
	return status;
#line 3261
#endif
#line 3261
}
#line 3261

int
#line 3262
ncx_putn_int_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3262
{
#line 3262
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3262

#line 3262
 /* basic algorithm is:
#line 3262
  *   - ensure sane alignment of output data
#line 3262
  *   - copy (conversion happens automatically) input data
#line 3262
  *     to output
#line 3262
  *   - update tp to point at next unconverted input, and xpp to point
#line 3262
  *     at next location for converted output
#line 3262
  */
#line 3262
  long i, j, ni;
#line 3262
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3262
  int *xp;
#line 3262
  int nrange = 0;         /* number of range errors */
#line 3262
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3262
  long cxp = (long) *((char**)xpp);
#line 3262

#line 3262
  realign = (cxp & 7) % SIZEOF_INT;
#line 3262
  /* sjl: manually stripmine so we can limit amount of
#line 3262
   * vector work space reserved to LOOPCNT elements. Also
#line 3262
   * makes vectorisation easy */
#line 3262
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3262
    ni=Min(nelems-j,LOOPCNT);
#line 3262
    if (realign) {
#line 3262
      xp = tmp;
#line 3262
    } else {
#line 3262
      xp = (int *) *xpp;
#line 3262
    }
#line 3262
   /* copy the next block */
#line 3262
#pragma cdir loopcnt=LOOPCNT
#line 3262
#pragma cdir shortloop
#line 3262
    for (i=0; i<ni; i++) {
#line 3262
      /* the normal case: */
#line 3262
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3262
     /* test for range errors (not always needed but do it anyway) */
#line 3262
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3262
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3262
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3262
    }
#line 3262
   /* copy workspace back if necessary */
#line 3262
    if (realign) {
#line 3262
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3262
      xp = (int *) *xpp;
#line 3262
    }
#line 3262
   /* update xpp and tp */
#line 3262
    xp += ni;
#line 3262
    tp += ni;
#line 3262
    *xpp = (void*)xp;
#line 3262
  }
#line 3262
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3262

#line 3262
#else   /* not SX */
#line 3262

#line 3262
	char *xp = (char *) *xpp;
#line 3262
	int status = NC_NOERR;
#line 3262

#line 3262
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3262
	{
#line 3262
		int lstatus = ncx_put_int_long(xp, tp, fillp);
#line 3262
		if (status == NC_NOERR) /* report the first encountered error */
#line 3262
			status = lstatus;
#line 3262
	}
#line 3262

#line 3262
	*xpp = (void *)xp;
#line 3262
	return status;
#line 3262
#endif
#line 3262
}
#line 3262

int
#line 3263
ncx_putn_int_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3263
{
#line 3263
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3263

#line 3263
 /* basic algorithm is:
#line 3263
  *   - ensure sane alignment of output data
#line 3263
  *   - copy (conversion happens automatically) input data
#line 3263
  *     to output
#line 3263
  *   - update tp to point at next unconverted input, and xpp to point
#line 3263
  *     at next location for converted output
#line 3263
  */
#line 3263
  long i, j, ni;
#line 3263
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3263
  int *xp;
#line 3263
  double d;               /* special case for ncx_putn_int_float */
#line 3263
  int nrange = 0;         /* number of range errors */
#line 3263
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3263
  long cxp = (long) *((char**)xpp);
#line 3263

#line 3263
  realign = (cxp & 7) % SIZEOF_INT;
#line 3263
  /* sjl: manually stripmine so we can limit amount of
#line 3263
   * vector work space reserved to LOOPCNT elements. Also
#line 3263
   * makes vectorisation easy */
#line 3263
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3263
    ni=Min(nelems-j,LOOPCNT);
#line 3263
    if (realign) {
#line 3263
      xp = tmp;
#line 3263
    } else {
#line 3263
      xp = (int *) *xpp;
#line 3263
    }
#line 3263
   /* copy the next block */
#line 3263
#pragma cdir loopcnt=LOOPCNT
#line 3263
#pragma cdir shortloop
#line 3263
    for (i=0; i<ni; i++) {
#line 3263
      /* for some reason int to float, for putn, requires a special case */
#line 3263
      d = tp[i];
#line 3263
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) d));
#line 3263
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3263
    }
#line 3263
   /* copy workspace back if necessary */
#line 3263
    if (realign) {
#line 3263
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3263
      xp = (int *) *xpp;
#line 3263
    }
#line 3263
   /* update xpp and tp */
#line 3263
    xp += ni;
#line 3263
    tp += ni;
#line 3263
    *xpp = (void*)xp;
#line 3263
  }
#line 3263
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3263

#line 3263
#else   /* not SX */
#line 3263

#line 3263
	char *xp = (char *) *xpp;
#line 3263
	int status = NC_NOERR;
#line 3263

#line 3263
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3263
	{
#line 3263
		int lstatus = ncx_put_int_float(xp, tp, fillp);
#line 3263
		if (status == NC_NOERR) /* report the first encountered error */
#line 3263
			status = lstatus;
#line 3263
	}
#line 3263

#line 3263
	*xpp = (void *)xp;
#line 3263
	return status;
#line 3263
#endif
#line 3263
}
#line 3263

int
#line 3264
ncx_putn_int_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3264
{
#line 3264
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3264

#line 3264
 /* basic algorithm is:
#line 3264
  *   - ensure sane alignment of output data
#line 3264
  *   - copy (conversion happens automatically) input data
#line 3264
  *     to output
#line 3264
  *   - update tp to point at next unconverted input, and xpp to point
#line 3264
  *     at next location for converted output
#line 3264
  */
#line 3264
  long i, j, ni;
#line 3264
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3264
  int *xp;
#line 3264
  int nrange = 0;         /* number of range errors */
#line 3264
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3264
  long cxp = (long) *((char**)xpp);
#line 3264

#line 3264
  realign = (cxp & 7) % SIZEOF_INT;
#line 3264
  /* sjl: manually stripmine so we can limit amount of
#line 3264
   * vector work space reserved to LOOPCNT elements. Also
#line 3264
   * makes vectorisation easy */
#line 3264
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3264
    ni=Min(nelems-j,LOOPCNT);
#line 3264
    if (realign) {
#line 3264
      xp = tmp;
#line 3264
    } else {
#line 3264
      xp = (int *) *xpp;
#line 3264
    }
#line 3264
   /* copy the next block */
#line 3264
#pragma cdir loopcnt=LOOPCNT
#line 3264
#pragma cdir shortloop
#line 3264
    for (i=0; i<ni; i++) {
#line 3264
      /* the normal case: */
#line 3264
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3264
     /* test for range errors (not always needed but do it anyway) */
#line 3264
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3264
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3264
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3264
    }
#line 3264
   /* copy workspace back if necessary */
#line 3264
    if (realign) {
#line 3264
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3264
      xp = (int *) *xpp;
#line 3264
    }
#line 3264
   /* update xpp and tp */
#line 3264
    xp += ni;
#line 3264
    tp += ni;
#line 3264
    *xpp = (void*)xp;
#line 3264
  }
#line 3264
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3264

#line 3264
#else   /* not SX */
#line 3264

#line 3264
	char *xp = (char *) *xpp;
#line 3264
	int status = NC_NOERR;
#line 3264

#line 3264
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3264
	{
#line 3264
		int lstatus = ncx_put_int_double(xp, tp, fillp);
#line 3264
		if (status == NC_NOERR) /* report the first encountered error */
#line 3264
			status = lstatus;
#line 3264
	}
#line 3264

#line 3264
	*xpp = (void *)xp;
#line 3264
	return status;
#line 3264
#endif
#line 3264
}
#line 3264

int
#line 3265
ncx_putn_int_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3265
{
#line 3265
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3265

#line 3265
 /* basic algorithm is:
#line 3265
  *   - ensure sane alignment of output data
#line 3265
  *   - copy (conversion happens automatically) input data
#line 3265
  *     to output
#line 3265
  *   - update tp to point at next unconverted input, and xpp to point
#line 3265
  *     at next location for converted output
#line 3265
  */
#line 3265
  long i, j, ni;
#line 3265
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3265
  int *xp;
#line 3265
  int nrange = 0;         /* number of range errors */
#line 3265
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3265
  long cxp = (long) *((char**)xpp);
#line 3265

#line 3265
  realign = (cxp & 7) % SIZEOF_INT;
#line 3265
  /* sjl: manually stripmine so we can limit amount of
#line 3265
   * vector work space reserved to LOOPCNT elements. Also
#line 3265
   * makes vectorisation easy */
#line 3265
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3265
    ni=Min(nelems-j,LOOPCNT);
#line 3265
    if (realign) {
#line 3265
      xp = tmp;
#line 3265
    } else {
#line 3265
      xp = (int *) *xpp;
#line 3265
    }
#line 3265
   /* copy the next block */
#line 3265
#pragma cdir loopcnt=LOOPCNT
#line 3265
#pragma cdir shortloop
#line 3265
    for (i=0; i<ni; i++) {
#line 3265
      /* the normal case: */
#line 3265
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3265
     /* test for range errors (not always needed but do it anyway) */
#line 3265
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3265
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3265
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3265
    }
#line 3265
   /* copy workspace back if necessary */
#line 3265
    if (realign) {
#line 3265
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3265
      xp = (int *) *xpp;
#line 3265
    }
#line 3265
   /* update xpp and tp */
#line 3265
    xp += ni;
#line 3265
    tp += ni;
#line 3265
    *xpp = (void*)xp;
#line 3265
  }
#line 3265
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3265

#line 3265
#else   /* not SX */
#line 3265

#line 3265
	char *xp = (char *) *xpp;
#line 3265
	int status = NC_NOERR;
#line 3265

#line 3265
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3265
	{
#line 3265
		int lstatus = ncx_put_int_longlong(xp, tp, fillp);
#line 3265
		if (status == NC_NOERR) /* report the first encountered error */
#line 3265
			status = lstatus;
#line 3265
	}
#line 3265

#line 3265
	*xpp = (void *)xp;
#line 3265
	return status;
#line 3265
#endif
#line 3265
}
#line 3265

int
#line 3266
ncx_putn_int_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3266
{
#line 3266
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3266

#line 3266
 /* basic algorithm is:
#line 3266
  *   - ensure sane alignment of output data
#line 3266
  *   - copy (conversion happens automatically) input data
#line 3266
  *     to output
#line 3266
  *   - update tp to point at next unconverted input, and xpp to point
#line 3266
  *     at next location for converted output
#line 3266
  */
#line 3266
  long i, j, ni;
#line 3266
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3266
  int *xp;
#line 3266
  int nrange = 0;         /* number of range errors */
#line 3266
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3266
  long cxp = (long) *((char**)xpp);
#line 3266

#line 3266
  realign = (cxp & 7) % SIZEOF_INT;
#line 3266
  /* sjl: manually stripmine so we can limit amount of
#line 3266
   * vector work space reserved to LOOPCNT elements. Also
#line 3266
   * makes vectorisation easy */
#line 3266
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3266
    ni=Min(nelems-j,LOOPCNT);
#line 3266
    if (realign) {
#line 3266
      xp = tmp;
#line 3266
    } else {
#line 3266
      xp = (int *) *xpp;
#line 3266
    }
#line 3266
   /* copy the next block */
#line 3266
#pragma cdir loopcnt=LOOPCNT
#line 3266
#pragma cdir shortloop
#line 3266
    for (i=0; i<ni; i++) {
#line 3266
      /* the normal case: */
#line 3266
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3266
     /* test for range errors (not always needed but do it anyway) */
#line 3266
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3266
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3266
      nrange += tp[i] > X_INT_MAX ;
#line 3266
    }
#line 3266
   /* copy workspace back if necessary */
#line 3266
    if (realign) {
#line 3266
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3266
      xp = (int *) *xpp;
#line 3266
    }
#line 3266
   /* update xpp and tp */
#line 3266
    xp += ni;
#line 3266
    tp += ni;
#line 3266
    *xpp = (void*)xp;
#line 3266
  }
#line 3266
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3266

#line 3266
#else   /* not SX */
#line 3266

#line 3266
	char *xp = (char *) *xpp;
#line 3266
	int status = NC_NOERR;
#line 3266

#line 3266
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3266
	{
#line 3266
		int lstatus = ncx_put_int_uchar(xp, tp, fillp);
#line 3266
		if (status == NC_NOERR) /* report the first encountered error */
#line 3266
			status = lstatus;
#line 3266
	}
#line 3266

#line 3266
	*xpp = (void *)xp;
#line 3266
	return status;
#line 3266
#endif
#line 3266
}
#line 3266

int
#line 3267
ncx_putn_int_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3267
{
#line 3267
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3267

#line 3267
 /* basic algorithm is:
#line 3267
  *   - ensure sane alignment of output data
#line 3267
  *   - copy (conversion happens automatically) input data
#line 3267
  *     to output
#line 3267
  *   - update tp to point at next unconverted input, and xpp to point
#line 3267
  *     at next location for converted output
#line 3267
  */
#line 3267
  long i, j, ni;
#line 3267
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3267
  int *xp;
#line 3267
  int nrange = 0;         /* number of range errors */
#line 3267
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3267
  long cxp = (long) *((char**)xpp);
#line 3267

#line 3267
  realign = (cxp & 7) % SIZEOF_INT;
#line 3267
  /* sjl: manually stripmine so we can limit amount of
#line 3267
   * vector work space reserved to LOOPCNT elements. Also
#line 3267
   * makes vectorisation easy */
#line 3267
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3267
    ni=Min(nelems-j,LOOPCNT);
#line 3267
    if (realign) {
#line 3267
      xp = tmp;
#line 3267
    } else {
#line 3267
      xp = (int *) *xpp;
#line 3267
    }
#line 3267
   /* copy the next block */
#line 3267
#pragma cdir loopcnt=LOOPCNT
#line 3267
#pragma cdir shortloop
#line 3267
    for (i=0; i<ni; i++) {
#line 3267
      /* the normal case: */
#line 3267
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3267
     /* test for range errors (not always needed but do it anyway) */
#line 3267
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3267
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3267
      nrange += tp[i] > X_INT_MAX ;
#line 3267
    }
#line 3267
   /* copy workspace back if necessary */
#line 3267
    if (realign) {
#line 3267
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3267
      xp = (int *) *xpp;
#line 3267
    }
#line 3267
   /* update xpp and tp */
#line 3267
    xp += ni;
#line 3267
    tp += ni;
#line 3267
    *xpp = (void*)xp;
#line 3267
  }
#line 3267
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3267

#line 3267
#else   /* not SX */
#line 3267

#line 3267
	char *xp = (char *) *xpp;
#line 3267
	int status = NC_NOERR;
#line 3267

#line 3267
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3267
	{
#line 3267
		int lstatus = ncx_put_int_ushort(xp, tp, fillp);
#line 3267
		if (status == NC_NOERR) /* report the first encountered error */
#line 3267
			status = lstatus;
#line 3267
	}
#line 3267

#line 3267
	*xpp = (void *)xp;
#line 3267
	return status;
#line 3267
#endif
#line 3267
}
#line 3267

int
#line 3268
ncx_putn_int_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3268
{
#line 3268
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3268

#line 3268
 /* basic algorithm is:
#line 3268
  *   - ensure sane alignment of output data
#line 3268
  *   - copy (conversion happens automatically) input data
#line 3268
  *     to output
#line 3268
  *   - update tp to point at next unconverted input, and xpp to point
#line 3268
  *     at next location for converted output
#line 3268
  */
#line 3268
  long i, j, ni;
#line 3268
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3268
  int *xp;
#line 3268
  int nrange = 0;         /* number of range errors */
#line 3268
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3268
  long cxp = (long) *((char**)xpp);
#line 3268

#line 3268
  realign = (cxp & 7) % SIZEOF_INT;
#line 3268
  /* sjl: manually stripmine so we can limit amount of
#line 3268
   * vector work space reserved to LOOPCNT elements. Also
#line 3268
   * makes vectorisation easy */
#line 3268
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3268
    ni=Min(nelems-j,LOOPCNT);
#line 3268
    if (realign) {
#line 3268
      xp = tmp;
#line 3268
    } else {
#line 3268
      xp = (int *) *xpp;
#line 3268
    }
#line 3268
   /* copy the next block */
#line 3268
#pragma cdir loopcnt=LOOPCNT
#line 3268
#pragma cdir shortloop
#line 3268
    for (i=0; i<ni; i++) {
#line 3268
      /* the normal case: */
#line 3268
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3268
     /* test for range errors (not always needed but do it anyway) */
#line 3268
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3268
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3268
      nrange += tp[i] > X_INT_MAX ;
#line 3268
    }
#line 3268
   /* copy workspace back if necessary */
#line 3268
    if (realign) {
#line 3268
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3268
      xp = (int *) *xpp;
#line 3268
    }
#line 3268
   /* update xpp and tp */
#line 3268
    xp += ni;
#line 3268
    tp += ni;
#line 3268
    *xpp = (void*)xp;
#line 3268
  }
#line 3268
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3268

#line 3268
#else   /* not SX */
#line 3268

#line 3268
	char *xp = (char *) *xpp;
#line 3268
	int status = NC_NOERR;
#line 3268

#line 3268
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3268
	{
#line 3268
		int lstatus = ncx_put_int_uint(xp, tp, fillp);
#line 3268
		if (status == NC_NOERR) /* report the first encountered error */
#line 3268
			status = lstatus;
#line 3268
	}
#line 3268

#line 3268
	*xpp = (void *)xp;
#line 3268
	return status;
#line 3268
#endif
#line 3268
}
#line 3268

int
#line 3269
ncx_putn_int_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3269
{
#line 3269
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3269

#line 3269
 /* basic algorithm is:
#line 3269
  *   - ensure sane alignment of output data
#line 3269
  *   - copy (conversion happens automatically) input data
#line 3269
  *     to output
#line 3269
  *   - update tp to point at next unconverted input, and xpp to point
#line 3269
  *     at next location for converted output
#line 3269
  */
#line 3269
  long i, j, ni;
#line 3269
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3269
  int *xp;
#line 3269
  int nrange = 0;         /* number of range errors */
#line 3269
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3269
  long cxp = (long) *((char**)xpp);
#line 3269

#line 3269
  realign = (cxp & 7) % SIZEOF_INT;
#line 3269
  /* sjl: manually stripmine so we can limit amount of
#line 3269
   * vector work space reserved to LOOPCNT elements. Also
#line 3269
   * makes vectorisation easy */
#line 3269
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3269
    ni=Min(nelems-j,LOOPCNT);
#line 3269
    if (realign) {
#line 3269
      xp = tmp;
#line 3269
    } else {
#line 3269
      xp = (int *) *xpp;
#line 3269
    }
#line 3269
   /* copy the next block */
#line 3269
#pragma cdir loopcnt=LOOPCNT
#line 3269
#pragma cdir shortloop
#line 3269
    for (i=0; i<ni; i++) {
#line 3269
      /* the normal case: */
#line 3269
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3269
     /* test for range errors (not always needed but do it anyway) */
#line 3269
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3269
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3269
      nrange += tp[i] > X_INT_MAX ;
#line 3269
    }
#line 3269
   /* copy workspace back if necessary */
#line 3269
    if (realign) {
#line 3269
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3269
      xp = (int *) *xpp;
#line 3269
    }
#line 3269
   /* update xpp and tp */
#line 3269
    xp += ni;
#line 3269
    tp += ni;
#line 3269
    *xpp = (void*)xp;
#line 3269
  }
#line 3269
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3269

#line 3269
#else   /* not SX */
#line 3269

#line 3269
	char *xp = (char *) *xpp;
#line 3269
	int status = NC_NOERR;
#line 3269

#line 3269
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3269
	{
#line 3269
		int lstatus = ncx_put_int_ulonglong(xp, tp, fillp);
#line 3269
		if (status == NC_NOERR) /* report the first encountered error */
#line 3269
			status = lstatus;
#line 3269
	}
#line 3269

#line 3269
	*xpp = (void *)xp;
#line 3269
	return status;
#line 3269
#endif
#line 3269
}
#line 3269


/* uint ----------------------------------------------------------------------*/

#if X_SIZEOF_UINT == SIZEOF_UINT
/* optimized version */
int
ncx_getn_uint_uint(const void **xpp, size_t nelems, unsigned int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_UINT);
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_UINT);
	return NC_NOERR;
}
#else
int
#line 3287
ncx_getn_uint_uint(const void **xpp, size_t nelems, uint *tp)
#line 3287
{
#line 3287
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3287

#line 3287
 /* basic algorithm is:
#line 3287
  *   - ensure sane alignment of input data
#line 3287
  *   - copy (conversion happens automatically) input data
#line 3287
  *     to output
#line 3287
  *   - update xpp to point at next unconverted input, and tp to point
#line 3287
  *     at next location for converted output
#line 3287
  */
#line 3287
  long i, j, ni;
#line 3287
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3287
  uint *xp;
#line 3287
  int nrange = 0;         /* number of range errors */
#line 3287
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3287
  long cxp = (long) *((char**)xpp);
#line 3287

#line 3287
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3287
  /* sjl: manually stripmine so we can limit amount of
#line 3287
   * vector work space reserved to LOOPCNT elements. Also
#line 3287
   * makes vectorisation easy */
#line 3287
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3287
    ni=Min(nelems-j,LOOPCNT);
#line 3287
    if (realign) {
#line 3287
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3287
      xp = tmp;
#line 3287
    } else {
#line 3287
      xp = (uint *) *xpp;
#line 3287
    }
#line 3287
   /* copy the next block */
#line 3287
#pragma cdir loopcnt=LOOPCNT
#line 3287
#pragma cdir shortloop
#line 3287
    for (i=0; i<ni; i++) {
#line 3287
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3287
     /* test for range errors (not always needed but do it anyway) */
#line 3287
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3287
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3287
      nrange += xp[i] > UINT_MAX ;
#line 3287
    }
#line 3287
   /* update xpp and tp */
#line 3287
    if (realign) xp = (uint *) *xpp;
#line 3287
    xp += ni;
#line 3287
    tp += ni;
#line 3287
    *xpp = (void*)xp;
#line 3287
  }
#line 3287
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3287

#line 3287
#else   /* not SX */
#line 3287
	const char *xp = (const char *) *xpp;
#line 3287
	int status = NC_NOERR;
#line 3287

#line 3287
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3287
	{
#line 3287
		const int lstatus = ncx_get_uint_uint(xp, tp);
#line 3287
		if (status == NC_NOERR) /* report the first encountered error */
#line 3287
			status = lstatus;
#line 3287
	}
#line 3287

#line 3287
	*xpp = (const void *)xp;
#line 3287
	return status;
#line 3287
#endif
#line 3287
}
#line 3287

#endif
int
#line 3289
ncx_getn_uint_schar(const void **xpp, size_t nelems, schar *tp)
#line 3289
{
#line 3289
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3289

#line 3289
 /* basic algorithm is:
#line 3289
  *   - ensure sane alignment of input data
#line 3289
  *   - copy (conversion happens automatically) input data
#line 3289
  *     to output
#line 3289
  *   - update xpp to point at next unconverted input, and tp to point
#line 3289
  *     at next location for converted output
#line 3289
  */
#line 3289
  long i, j, ni;
#line 3289
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3289
  uint *xp;
#line 3289
  int nrange = 0;         /* number of range errors */
#line 3289
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3289
  long cxp = (long) *((char**)xpp);
#line 3289

#line 3289
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3289
  /* sjl: manually stripmine so we can limit amount of
#line 3289
   * vector work space reserved to LOOPCNT elements. Also
#line 3289
   * makes vectorisation easy */
#line 3289
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3289
    ni=Min(nelems-j,LOOPCNT);
#line 3289
    if (realign) {
#line 3289
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3289
      xp = tmp;
#line 3289
    } else {
#line 3289
      xp = (uint *) *xpp;
#line 3289
    }
#line 3289
   /* copy the next block */
#line 3289
#pragma cdir loopcnt=LOOPCNT
#line 3289
#pragma cdir shortloop
#line 3289
    for (i=0; i<ni; i++) {
#line 3289
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3289
     /* test for range errors (not always needed but do it anyway) */
#line 3289
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3289
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3289
      nrange += xp[i] > SCHAR_MAX ;
#line 3289
    }
#line 3289
   /* update xpp and tp */
#line 3289
    if (realign) xp = (uint *) *xpp;
#line 3289
    xp += ni;
#line 3289
    tp += ni;
#line 3289
    *xpp = (void*)xp;
#line 3289
  }
#line 3289
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3289

#line 3289
#else   /* not SX */
#line 3289
	const char *xp = (const char *) *xpp;
#line 3289
	int status = NC_NOERR;
#line 3289

#line 3289
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3289
	{
#line 3289
		const int lstatus = ncx_get_uint_schar(xp, tp);
#line 3289
		if (status == NC_NOERR) /* report the first encountered error */
#line 3289
			status = lstatus;
#line 3289
	}
#line 3289

#line 3289
	*xpp = (const void *)xp;
#line 3289
	return status;
#line 3289
#endif
#line 3289
}
#line 3289

int
#line 3290
ncx_getn_uint_short(const void **xpp, size_t nelems, short *tp)
#line 3290
{
#line 3290
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3290

#line 3290
 /* basic algorithm is:
#line 3290
  *   - ensure sane alignment of input data
#line 3290
  *   - copy (conversion happens automatically) input data
#line 3290
  *     to output
#line 3290
  *   - update xpp to point at next unconverted input, and tp to point
#line 3290
  *     at next location for converted output
#line 3290
  */
#line 3290
  long i, j, ni;
#line 3290
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3290
  uint *xp;
#line 3290
  int nrange = 0;         /* number of range errors */
#line 3290
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3290
  long cxp = (long) *((char**)xpp);
#line 3290

#line 3290
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3290
  /* sjl: manually stripmine so we can limit amount of
#line 3290
   * vector work space reserved to LOOPCNT elements. Also
#line 3290
   * makes vectorisation easy */
#line 3290
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3290
    ni=Min(nelems-j,LOOPCNT);
#line 3290
    if (realign) {
#line 3290
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3290
      xp = tmp;
#line 3290
    } else {
#line 3290
      xp = (uint *) *xpp;
#line 3290
    }
#line 3290
   /* copy the next block */
#line 3290
#pragma cdir loopcnt=LOOPCNT
#line 3290
#pragma cdir shortloop
#line 3290
    for (i=0; i<ni; i++) {
#line 3290
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3290
     /* test for range errors (not always needed but do it anyway) */
#line 3290
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3290
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3290
      nrange += xp[i] > SHORT_MAX ;
#line 3290
    }
#line 3290
   /* update xpp and tp */
#line 3290
    if (realign) xp = (uint *) *xpp;
#line 3290
    xp += ni;
#line 3290
    tp += ni;
#line 3290
    *xpp = (void*)xp;
#line 3290
  }
#line 3290
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3290

#line 3290
#else   /* not SX */
#line 3290
	const char *xp = (const char *) *xpp;
#line 3290
	int status = NC_NOERR;
#line 3290

#line 3290
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3290
	{
#line 3290
		const int lstatus = ncx_get_uint_short(xp, tp);
#line 3290
		if (status == NC_NOERR) /* report the first encountered error */
#line 3290
			status = lstatus;
#line 3290
	}
#line 3290

#line 3290
	*xpp = (const void *)xp;
#line 3290
	return status;
#line 3290
#endif
#line 3290
}
#line 3290

int
#line 3291
ncx_getn_uint_int(const void **xpp, size_t nelems, int *tp)
#line 3291
{
#line 3291
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3291

#line 3291
 /* basic algorithm is:
#line 3291
  *   - ensure sane alignment of input data
#line 3291
  *   - copy (conversion happens automatically) input data
#line 3291
  *     to output
#line 3291
  *   - update xpp to point at next unconverted input, and tp to point
#line 3291
  *     at next location for converted output
#line 3291
  */
#line 3291
  long i, j, ni;
#line 3291
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3291
  uint *xp;
#line 3291
  int nrange = 0;         /* number of range errors */
#line 3291
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3291
  long cxp = (long) *((char**)xpp);
#line 3291

#line 3291
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3291
  /* sjl: manually stripmine so we can limit amount of
#line 3291
   * vector work space reserved to LOOPCNT elements. Also
#line 3291
   * makes vectorisation easy */
#line 3291
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3291
    ni=Min(nelems-j,LOOPCNT);
#line 3291
    if (realign) {
#line 3291
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3291
      xp = tmp;
#line 3291
    } else {
#line 3291
      xp = (uint *) *xpp;
#line 3291
    }
#line 3291
   /* copy the next block */
#line 3291
#pragma cdir loopcnt=LOOPCNT
#line 3291
#pragma cdir shortloop
#line 3291
    for (i=0; i<ni; i++) {
#line 3291
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3291
     /* test for range errors (not always needed but do it anyway) */
#line 3291
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3291
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3291
      nrange += xp[i] > INT_MAX ;
#line 3291
    }
#line 3291
   /* update xpp and tp */
#line 3291
    if (realign) xp = (uint *) *xpp;
#line 3291
    xp += ni;
#line 3291
    tp += ni;
#line 3291
    *xpp = (void*)xp;
#line 3291
  }
#line 3291
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3291

#line 3291
#else   /* not SX */
#line 3291
	const char *xp = (const char *) *xpp;
#line 3291
	int status = NC_NOERR;
#line 3291

#line 3291
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3291
	{
#line 3291
		const int lstatus = ncx_get_uint_int(xp, tp);
#line 3291
		if (status == NC_NOERR) /* report the first encountered error */
#line 3291
			status = lstatus;
#line 3291
	}
#line 3291

#line 3291
	*xpp = (const void *)xp;
#line 3291
	return status;
#line 3291
#endif
#line 3291
}
#line 3291

int
#line 3292
ncx_getn_uint_long(const void **xpp, size_t nelems, long *tp)
#line 3292
{
#line 3292
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3292

#line 3292
 /* basic algorithm is:
#line 3292
  *   - ensure sane alignment of input data
#line 3292
  *   - copy (conversion happens automatically) input data
#line 3292
  *     to output
#line 3292
  *   - update xpp to point at next unconverted input, and tp to point
#line 3292
  *     at next location for converted output
#line 3292
  */
#line 3292
  long i, j, ni;
#line 3292
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3292
  uint *xp;
#line 3292
  int nrange = 0;         /* number of range errors */
#line 3292
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3292
  long cxp = (long) *((char**)xpp);
#line 3292

#line 3292
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3292
  /* sjl: manually stripmine so we can limit amount of
#line 3292
   * vector work space reserved to LOOPCNT elements. Also
#line 3292
   * makes vectorisation easy */
#line 3292
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3292
    ni=Min(nelems-j,LOOPCNT);
#line 3292
    if (realign) {
#line 3292
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3292
      xp = tmp;
#line 3292
    } else {
#line 3292
      xp = (uint *) *xpp;
#line 3292
    }
#line 3292
   /* copy the next block */
#line 3292
#pragma cdir loopcnt=LOOPCNT
#line 3292
#pragma cdir shortloop
#line 3292
    for (i=0; i<ni; i++) {
#line 3292
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3292
     /* test for range errors (not always needed but do it anyway) */
#line 3292
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3292
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3292
      nrange += xp[i] > LONG_MAX ;
#line 3292
    }
#line 3292
   /* update xpp and tp */
#line 3292
    if (realign) xp = (uint *) *xpp;
#line 3292
    xp += ni;
#line 3292
    tp += ni;
#line 3292
    *xpp = (void*)xp;
#line 3292
  }
#line 3292
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3292

#line 3292
#else   /* not SX */
#line 3292
	const char *xp = (const char *) *xpp;
#line 3292
	int status = NC_NOERR;
#line 3292

#line 3292
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3292
	{
#line 3292
		const int lstatus = ncx_get_uint_long(xp, tp);
#line 3292
		if (status == NC_NOERR) /* report the first encountered error */
#line 3292
			status = lstatus;
#line 3292
	}
#line 3292

#line 3292
	*xpp = (const void *)xp;
#line 3292
	return status;
#line 3292
#endif
#line 3292
}
#line 3292

int
#line 3293
ncx_getn_uint_float(const void **xpp, size_t nelems, float *tp)
#line 3293
{
#line 3293
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3293

#line 3293
 /* basic algorithm is:
#line 3293
  *   - ensure sane alignment of input data
#line 3293
  *   - copy (conversion happens automatically) input data
#line 3293
  *     to output
#line 3293
  *   - update xpp to point at next unconverted input, and tp to point
#line 3293
  *     at next location for converted output
#line 3293
  */
#line 3293
  long i, j, ni;
#line 3293
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3293
  uint *xp;
#line 3293
  int nrange = 0;         /* number of range errors */
#line 3293
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3293
  long cxp = (long) *((char**)xpp);
#line 3293

#line 3293
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3293
  /* sjl: manually stripmine so we can limit amount of
#line 3293
   * vector work space reserved to LOOPCNT elements. Also
#line 3293
   * makes vectorisation easy */
#line 3293
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3293
    ni=Min(nelems-j,LOOPCNT);
#line 3293
    if (realign) {
#line 3293
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3293
      xp = tmp;
#line 3293
    } else {
#line 3293
      xp = (uint *) *xpp;
#line 3293
    }
#line 3293
   /* copy the next block */
#line 3293
#pragma cdir loopcnt=LOOPCNT
#line 3293
#pragma cdir shortloop
#line 3293
    for (i=0; i<ni; i++) {
#line 3293
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3293
     /* test for range errors (not always needed but do it anyway) */
#line 3293
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3293
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3293
      nrange += xp[i] > FLOAT_MAX ;
#line 3293
    }
#line 3293
   /* update xpp and tp */
#line 3293
    if (realign) xp = (uint *) *xpp;
#line 3293
    xp += ni;
#line 3293
    tp += ni;
#line 3293
    *xpp = (void*)xp;
#line 3293
  }
#line 3293
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3293

#line 3293
#else   /* not SX */
#line 3293
	const char *xp = (const char *) *xpp;
#line 3293
	int status = NC_NOERR;
#line 3293

#line 3293
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3293
	{
#line 3293
		const int lstatus = ncx_get_uint_float(xp, tp);
#line 3293
		if (status == NC_NOERR) /* report the first encountered error */
#line 3293
			status = lstatus;
#line 3293
	}
#line 3293

#line 3293
	*xpp = (const void *)xp;
#line 3293
	return status;
#line 3293
#endif
#line 3293
}
#line 3293

int
#line 3294
ncx_getn_uint_double(const void **xpp, size_t nelems, double *tp)
#line 3294
{
#line 3294
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3294

#line 3294
 /* basic algorithm is:
#line 3294
  *   - ensure sane alignment of input data
#line 3294
  *   - copy (conversion happens automatically) input data
#line 3294
  *     to output
#line 3294
  *   - update xpp to point at next unconverted input, and tp to point
#line 3294
  *     at next location for converted output
#line 3294
  */
#line 3294
  long i, j, ni;
#line 3294
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3294
  uint *xp;
#line 3294
  int nrange = 0;         /* number of range errors */
#line 3294
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3294
  long cxp = (long) *((char**)xpp);
#line 3294

#line 3294
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3294
  /* sjl: manually stripmine so we can limit amount of
#line 3294
   * vector work space reserved to LOOPCNT elements. Also
#line 3294
   * makes vectorisation easy */
#line 3294
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3294
    ni=Min(nelems-j,LOOPCNT);
#line 3294
    if (realign) {
#line 3294
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3294
      xp = tmp;
#line 3294
    } else {
#line 3294
      xp = (uint *) *xpp;
#line 3294
    }
#line 3294
   /* copy the next block */
#line 3294
#pragma cdir loopcnt=LOOPCNT
#line 3294
#pragma cdir shortloop
#line 3294
    for (i=0; i<ni; i++) {
#line 3294
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3294
     /* test for range errors (not always needed but do it anyway) */
#line 3294
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3294
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3294
      nrange += xp[i] > DOUBLE_MAX ;
#line 3294
    }
#line 3294
   /* update xpp and tp */
#line 3294
    if (realign) xp = (uint *) *xpp;
#line 3294
    xp += ni;
#line 3294
    tp += ni;
#line 3294
    *xpp = (void*)xp;
#line 3294
  }
#line 3294
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3294

#line 3294
#else   /* not SX */
#line 3294
	const char *xp = (const char *) *xpp;
#line 3294
	int status = NC_NOERR;
#line 3294

#line 3294
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3294
	{
#line 3294
		const int lstatus = ncx_get_uint_double(xp, tp);
#line 3294
		if (status == NC_NOERR) /* report the first encountered error */
#line 3294
			status = lstatus;
#line 3294
	}
#line 3294

#line 3294
	*xpp = (const void *)xp;
#line 3294
	return status;
#line 3294
#endif
#line 3294
}
#line 3294

int
#line 3295
ncx_getn_uint_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3295
{
#line 3295
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3295

#line 3295
 /* basic algorithm is:
#line 3295
  *   - ensure sane alignment of input data
#line 3295
  *   - copy (conversion happens automatically) input data
#line 3295
  *     to output
#line 3295
  *   - update xpp to point at next unconverted input, and tp to point
#line 3295
  *     at next location for converted output
#line 3295
  */
#line 3295
  long i, j, ni;
#line 3295
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3295
  uint *xp;
#line 3295
  int nrange = 0;         /* number of range errors */
#line 3295
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3295
  long cxp = (long) *((char**)xpp);
#line 3295

#line 3295
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3295
  /* sjl: manually stripmine so we can limit amount of
#line 3295
   * vector work space reserved to LOOPCNT elements. Also
#line 3295
   * makes vectorisation easy */
#line 3295
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3295
    ni=Min(nelems-j,LOOPCNT);
#line 3295
    if (realign) {
#line 3295
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3295
      xp = tmp;
#line 3295
    } else {
#line 3295
      xp = (uint *) *xpp;
#line 3295
    }
#line 3295
   /* copy the next block */
#line 3295
#pragma cdir loopcnt=LOOPCNT
#line 3295
#pragma cdir shortloop
#line 3295
    for (i=0; i<ni; i++) {
#line 3295
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3295
     /* test for range errors (not always needed but do it anyway) */
#line 3295
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3295
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3295
      nrange += xp[i] > LONGLONG_MAX ;
#line 3295
    }
#line 3295
   /* update xpp and tp */
#line 3295
    if (realign) xp = (uint *) *xpp;
#line 3295
    xp += ni;
#line 3295
    tp += ni;
#line 3295
    *xpp = (void*)xp;
#line 3295
  }
#line 3295
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3295

#line 3295
#else   /* not SX */
#line 3295
	const char *xp = (const char *) *xpp;
#line 3295
	int status = NC_NOERR;
#line 3295

#line 3295
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3295
	{
#line 3295
		const int lstatus = ncx_get_uint_longlong(xp, tp);
#line 3295
		if (status == NC_NOERR) /* report the first encountered error */
#line 3295
			status = lstatus;
#line 3295
	}
#line 3295

#line 3295
	*xpp = (const void *)xp;
#line 3295
	return status;
#line 3295
#endif
#line 3295
}
#line 3295

int
#line 3296
ncx_getn_uint_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3296
{
#line 3296
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3296

#line 3296
 /* basic algorithm is:
#line 3296
  *   - ensure sane alignment of input data
#line 3296
  *   - copy (conversion happens automatically) input data
#line 3296
  *     to output
#line 3296
  *   - update xpp to point at next unconverted input, and tp to point
#line 3296
  *     at next location for converted output
#line 3296
  */
#line 3296
  long i, j, ni;
#line 3296
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3296
  uint *xp;
#line 3296
  int nrange = 0;         /* number of range errors */
#line 3296
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3296
  long cxp = (long) *((char**)xpp);
#line 3296

#line 3296
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3296
  /* sjl: manually stripmine so we can limit amount of
#line 3296
   * vector work space reserved to LOOPCNT elements. Also
#line 3296
   * makes vectorisation easy */
#line 3296
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3296
    ni=Min(nelems-j,LOOPCNT);
#line 3296
    if (realign) {
#line 3296
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3296
      xp = tmp;
#line 3296
    } else {
#line 3296
      xp = (uint *) *xpp;
#line 3296
    }
#line 3296
   /* copy the next block */
#line 3296
#pragma cdir loopcnt=LOOPCNT
#line 3296
#pragma cdir shortloop
#line 3296
    for (i=0; i<ni; i++) {
#line 3296
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3296
     /* test for range errors (not always needed but do it anyway) */
#line 3296
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3296
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3296
      nrange += xp[i] > UCHAR_MAX ;
#line 3296
    }
#line 3296
   /* update xpp and tp */
#line 3296
    if (realign) xp = (uint *) *xpp;
#line 3296
    xp += ni;
#line 3296
    tp += ni;
#line 3296
    *xpp = (void*)xp;
#line 3296
  }
#line 3296
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3296

#line 3296
#else   /* not SX */
#line 3296
	const char *xp = (const char *) *xpp;
#line 3296
	int status = NC_NOERR;
#line 3296

#line 3296
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3296
	{
#line 3296
		const int lstatus = ncx_get_uint_uchar(xp, tp);
#line 3296
		if (status == NC_NOERR) /* report the first encountered error */
#line 3296
			status = lstatus;
#line 3296
	}
#line 3296

#line 3296
	*xpp = (const void *)xp;
#line 3296
	return status;
#line 3296
#endif
#line 3296
}
#line 3296

int
#line 3297
ncx_getn_uint_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3297
{
#line 3297
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3297

#line 3297
 /* basic algorithm is:
#line 3297
  *   - ensure sane alignment of input data
#line 3297
  *   - copy (conversion happens automatically) input data
#line 3297
  *     to output
#line 3297
  *   - update xpp to point at next unconverted input, and tp to point
#line 3297
  *     at next location for converted output
#line 3297
  */
#line 3297
  long i, j, ni;
#line 3297
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3297
  uint *xp;
#line 3297
  int nrange = 0;         /* number of range errors */
#line 3297
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3297
  long cxp = (long) *((char**)xpp);
#line 3297

#line 3297
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3297
  /* sjl: manually stripmine so we can limit amount of
#line 3297
   * vector work space reserved to LOOPCNT elements. Also
#line 3297
   * makes vectorisation easy */
#line 3297
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3297
    ni=Min(nelems-j,LOOPCNT);
#line 3297
    if (realign) {
#line 3297
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3297
      xp = tmp;
#line 3297
    } else {
#line 3297
      xp = (uint *) *xpp;
#line 3297
    }
#line 3297
   /* copy the next block */
#line 3297
#pragma cdir loopcnt=LOOPCNT
#line 3297
#pragma cdir shortloop
#line 3297
    for (i=0; i<ni; i++) {
#line 3297
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3297
     /* test for range errors (not always needed but do it anyway) */
#line 3297
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3297
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3297
      nrange += xp[i] > USHORT_MAX ;
#line 3297
    }
#line 3297
   /* update xpp and tp */
#line 3297
    if (realign) xp = (uint *) *xpp;
#line 3297
    xp += ni;
#line 3297
    tp += ni;
#line 3297
    *xpp = (void*)xp;
#line 3297
  }
#line 3297
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3297

#line 3297
#else   /* not SX */
#line 3297
	const char *xp = (const char *) *xpp;
#line 3297
	int status = NC_NOERR;
#line 3297

#line 3297
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3297
	{
#line 3297
		const int lstatus = ncx_get_uint_ushort(xp, tp);
#line 3297
		if (status == NC_NOERR) /* report the first encountered error */
#line 3297
			status = lstatus;
#line 3297
	}
#line 3297

#line 3297
	*xpp = (const void *)xp;
#line 3297
	return status;
#line 3297
#endif
#line 3297
}
#line 3297

int
#line 3298
ncx_getn_uint_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3298
{
#line 3298
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3298

#line 3298
 /* basic algorithm is:
#line 3298
  *   - ensure sane alignment of input data
#line 3298
  *   - copy (conversion happens automatically) input data
#line 3298
  *     to output
#line 3298
  *   - update xpp to point at next unconverted input, and tp to point
#line 3298
  *     at next location for converted output
#line 3298
  */
#line 3298
  long i, j, ni;
#line 3298
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3298
  uint *xp;
#line 3298
  int nrange = 0;         /* number of range errors */
#line 3298
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3298
  long cxp = (long) *((char**)xpp);
#line 3298

#line 3298
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3298
  /* sjl: manually stripmine so we can limit amount of
#line 3298
   * vector work space reserved to LOOPCNT elements. Also
#line 3298
   * makes vectorisation easy */
#line 3298
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3298
    ni=Min(nelems-j,LOOPCNT);
#line 3298
    if (realign) {
#line 3298
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3298
      xp = tmp;
#line 3298
    } else {
#line 3298
      xp = (uint *) *xpp;
#line 3298
    }
#line 3298
   /* copy the next block */
#line 3298
#pragma cdir loopcnt=LOOPCNT
#line 3298
#pragma cdir shortloop
#line 3298
    for (i=0; i<ni; i++) {
#line 3298
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3298
     /* test for range errors (not always needed but do it anyway) */
#line 3298
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3298
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3298
      nrange += xp[i] > ULONGLONG_MAX ;
#line 3298
    }
#line 3298
   /* update xpp and tp */
#line 3298
    if (realign) xp = (uint *) *xpp;
#line 3298
    xp += ni;
#line 3298
    tp += ni;
#line 3298
    *xpp = (void*)xp;
#line 3298
  }
#line 3298
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3298

#line 3298
#else   /* not SX */
#line 3298
	const char *xp = (const char *) *xpp;
#line 3298
	int status = NC_NOERR;
#line 3298

#line 3298
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3298
	{
#line 3298
		const int lstatus = ncx_get_uint_ulonglong(xp, tp);
#line 3298
		if (status == NC_NOERR) /* report the first encountered error */
#line 3298
			status = lstatus;
#line 3298
	}
#line 3298

#line 3298
	*xpp = (const void *)xp;
#line 3298
	return status;
#line 3298
#endif
#line 3298
}
#line 3298


#if X_SIZEOF_UINT == SIZEOF_UINT
/* optimized version */
int
ncx_putn_uint_uint(void **xpp, size_t nelems, const unsigned int *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_UINT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_UINT);
	return NC_NOERR;
}
#else
int
#line 3314
ncx_putn_uint_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3314
{
#line 3314
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3314

#line 3314
 /* basic algorithm is:
#line 3314
  *   - ensure sane alignment of output data
#line 3314
  *   - copy (conversion happens automatically) input data
#line 3314
  *     to output
#line 3314
  *   - update tp to point at next unconverted input, and xpp to point
#line 3314
  *     at next location for converted output
#line 3314
  */
#line 3314
  long i, j, ni;
#line 3314
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3314
  uint *xp;
#line 3314
  int nrange = 0;         /* number of range errors */
#line 3314
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3314
  long cxp = (long) *((char**)xpp);
#line 3314

#line 3314
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3314
  /* sjl: manually stripmine so we can limit amount of
#line 3314
   * vector work space reserved to LOOPCNT elements. Also
#line 3314
   * makes vectorisation easy */
#line 3314
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3314
    ni=Min(nelems-j,LOOPCNT);
#line 3314
    if (realign) {
#line 3314
      xp = tmp;
#line 3314
    } else {
#line 3314
      xp = (uint *) *xpp;
#line 3314
    }
#line 3314
   /* copy the next block */
#line 3314
#pragma cdir loopcnt=LOOPCNT
#line 3314
#pragma cdir shortloop
#line 3314
    for (i=0; i<ni; i++) {
#line 3314
      /* the normal case: */
#line 3314
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3314
     /* test for range errors (not always needed but do it anyway) */
#line 3314
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3314
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3314
      nrange += tp[i] > X_UINT_MAX ;
#line 3314
    }
#line 3314
   /* copy workspace back if necessary */
#line 3314
    if (realign) {
#line 3314
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3314
      xp = (uint *) *xpp;
#line 3314
    }
#line 3314
   /* update xpp and tp */
#line 3314
    xp += ni;
#line 3314
    tp += ni;
#line 3314
    *xpp = (void*)xp;
#line 3314
  }
#line 3314
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3314

#line 3314
#else   /* not SX */
#line 3314

#line 3314
	char *xp = (char *) *xpp;
#line 3314
	int status = NC_NOERR;
#line 3314

#line 3314
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3314
	{
#line 3314
		int lstatus = ncx_put_uint_uint(xp, tp, fillp);
#line 3314
		if (status == NC_NOERR) /* report the first encountered error */
#line 3314
			status = lstatus;
#line 3314
	}
#line 3314

#line 3314
	*xpp = (void *)xp;
#line 3314
	return status;
#line 3314
#endif
#line 3314
}
#line 3314

#endif
int
#line 3316
ncx_putn_uint_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3316
{
#line 3316
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3316

#line 3316
 /* basic algorithm is:
#line 3316
  *   - ensure sane alignment of output data
#line 3316
  *   - copy (conversion happens automatically) input data
#line 3316
  *     to output
#line 3316
  *   - update tp to point at next unconverted input, and xpp to point
#line 3316
  *     at next location for converted output
#line 3316
  */
#line 3316
  long i, j, ni;
#line 3316
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3316
  uint *xp;
#line 3316
  int nrange = 0;         /* number of range errors */
#line 3316
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3316
  long cxp = (long) *((char**)xpp);
#line 3316

#line 3316
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3316
  /* sjl: manually stripmine so we can limit amount of
#line 3316
   * vector work space reserved to LOOPCNT elements. Also
#line 3316
   * makes vectorisation easy */
#line 3316
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3316
    ni=Min(nelems-j,LOOPCNT);
#line 3316
    if (realign) {
#line 3316
      xp = tmp;
#line 3316
    } else {
#line 3316
      xp = (uint *) *xpp;
#line 3316
    }
#line 3316
   /* copy the next block */
#line 3316
#pragma cdir loopcnt=LOOPCNT
#line 3316
#pragma cdir shortloop
#line 3316
    for (i=0; i<ni; i++) {
#line 3316
      /* the normal case: */
#line 3316
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3316
     /* test for range errors (not always needed but do it anyway) */
#line 3316
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3316
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3316
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3316
    }
#line 3316
   /* copy workspace back if necessary */
#line 3316
    if (realign) {
#line 3316
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3316
      xp = (uint *) *xpp;
#line 3316
    }
#line 3316
   /* update xpp and tp */
#line 3316
    xp += ni;
#line 3316
    tp += ni;
#line 3316
    *xpp = (void*)xp;
#line 3316
  }
#line 3316
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3316

#line 3316
#else   /* not SX */
#line 3316

#line 3316
	char *xp = (char *) *xpp;
#line 3316
	int status = NC_NOERR;
#line 3316

#line 3316
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3316
	{
#line 3316
		int lstatus = ncx_put_uint_schar(xp, tp, fillp);
#line 3316
		if (status == NC_NOERR) /* report the first encountered error */
#line 3316
			status = lstatus;
#line 3316
	}
#line 3316

#line 3316
	*xpp = (void *)xp;
#line 3316
	return status;
#line 3316
#endif
#line 3316
}
#line 3316

int
#line 3317
ncx_putn_uint_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3317
{
#line 3317
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3317

#line 3317
 /* basic algorithm is:
#line 3317
  *   - ensure sane alignment of output data
#line 3317
  *   - copy (conversion happens automatically) input data
#line 3317
  *     to output
#line 3317
  *   - update tp to point at next unconverted input, and xpp to point
#line 3317
  *     at next location for converted output
#line 3317
  */
#line 3317
  long i, j, ni;
#line 3317
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3317
  uint *xp;
#line 3317
  int nrange = 0;         /* number of range errors */
#line 3317
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3317
  long cxp = (long) *((char**)xpp);
#line 3317

#line 3317
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3317
  /* sjl: manually stripmine so we can limit amount of
#line 3317
   * vector work space reserved to LOOPCNT elements. Also
#line 3317
   * makes vectorisation easy */
#line 3317
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3317
    ni=Min(nelems-j,LOOPCNT);
#line 3317
    if (realign) {
#line 3317
      xp = tmp;
#line 3317
    } else {
#line 3317
      xp = (uint *) *xpp;
#line 3317
    }
#line 3317
   /* copy the next block */
#line 3317
#pragma cdir loopcnt=LOOPCNT
#line 3317
#pragma cdir shortloop
#line 3317
    for (i=0; i<ni; i++) {
#line 3317
      /* the normal case: */
#line 3317
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3317
     /* test for range errors (not always needed but do it anyway) */
#line 3317
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3317
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3317
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3317
    }
#line 3317
   /* copy workspace back if necessary */
#line 3317
    if (realign) {
#line 3317
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3317
      xp = (uint *) *xpp;
#line 3317
    }
#line 3317
   /* update xpp and tp */
#line 3317
    xp += ni;
#line 3317
    tp += ni;
#line 3317
    *xpp = (void*)xp;
#line 3317
  }
#line 3317
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3317

#line 3317
#else   /* not SX */
#line 3317

#line 3317
	char *xp = (char *) *xpp;
#line 3317
	int status = NC_NOERR;
#line 3317

#line 3317
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3317
	{
#line 3317
		int lstatus = ncx_put_uint_short(xp, tp, fillp);
#line 3317
		if (status == NC_NOERR) /* report the first encountered error */
#line 3317
			status = lstatus;
#line 3317
	}
#line 3317

#line 3317
	*xpp = (void *)xp;
#line 3317
	return status;
#line 3317
#endif
#line 3317
}
#line 3317

int
#line 3318
ncx_putn_uint_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3318
{
#line 3318
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3318

#line 3318
 /* basic algorithm is:
#line 3318
  *   - ensure sane alignment of output data
#line 3318
  *   - copy (conversion happens automatically) input data
#line 3318
  *     to output
#line 3318
  *   - update tp to point at next unconverted input, and xpp to point
#line 3318
  *     at next location for converted output
#line 3318
  */
#line 3318
  long i, j, ni;
#line 3318
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3318
  uint *xp;
#line 3318
  int nrange = 0;         /* number of range errors */
#line 3318
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3318
  long cxp = (long) *((char**)xpp);
#line 3318

#line 3318
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3318
  /* sjl: manually stripmine so we can limit amount of
#line 3318
   * vector work space reserved to LOOPCNT elements. Also
#line 3318
   * makes vectorisation easy */
#line 3318
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3318
    ni=Min(nelems-j,LOOPCNT);
#line 3318
    if (realign) {
#line 3318
      xp = tmp;
#line 3318
    } else {
#line 3318
      xp = (uint *) *xpp;
#line 3318
    }
#line 3318
   /* copy the next block */
#line 3318
#pragma cdir loopcnt=LOOPCNT
#line 3318
#pragma cdir shortloop
#line 3318
    for (i=0; i<ni; i++) {
#line 3318
      /* the normal case: */
#line 3318
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3318
     /* test for range errors (not always needed but do it anyway) */
#line 3318
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3318
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3318
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3318
    }
#line 3318
   /* copy workspace back if necessary */
#line 3318
    if (realign) {
#line 3318
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3318
      xp = (uint *) *xpp;
#line 3318
    }
#line 3318
   /* update xpp and tp */
#line 3318
    xp += ni;
#line 3318
    tp += ni;
#line 3318
    *xpp = (void*)xp;
#line 3318
  }
#line 3318
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3318

#line 3318
#else   /* not SX */
#line 3318

#line 3318
	char *xp = (char *) *xpp;
#line 3318
	int status = NC_NOERR;
#line 3318

#line 3318
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3318
	{
#line 3318
		int lstatus = ncx_put_uint_int(xp, tp, fillp);
#line 3318
		if (status == NC_NOERR) /* report the first encountered error */
#line 3318
			status = lstatus;
#line 3318
	}
#line 3318

#line 3318
	*xpp = (void *)xp;
#line 3318
	return status;
#line 3318
#endif
#line 3318
}
#line 3318

int
#line 3319
ncx_putn_uint_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3319
{
#line 3319
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3319

#line 3319
 /* basic algorithm is:
#line 3319
  *   - ensure sane alignment of output data
#line 3319
  *   - copy (conversion happens automatically) input data
#line 3319
  *     to output
#line 3319
  *   - update tp to point at next unconverted input, and xpp to point
#line 3319
  *     at next location for converted output
#line 3319
  */
#line 3319
  long i, j, ni;
#line 3319
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3319
  uint *xp;
#line 3319
  int nrange = 0;         /* number of range errors */
#line 3319
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3319
  long cxp = (long) *((char**)xpp);
#line 3319

#line 3319
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3319
  /* sjl: manually stripmine so we can limit amount of
#line 3319
   * vector work space reserved to LOOPCNT elements. Also
#line 3319
   * makes vectorisation easy */
#line 3319
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3319
    ni=Min(nelems-j,LOOPCNT);
#line 3319
    if (realign) {
#line 3319
      xp = tmp;
#line 3319
    } else {
#line 3319
      xp = (uint *) *xpp;
#line 3319
    }
#line 3319
   /* copy the next block */
#line 3319
#pragma cdir loopcnt=LOOPCNT
#line 3319
#pragma cdir shortloop
#line 3319
    for (i=0; i<ni; i++) {
#line 3319
      /* the normal case: */
#line 3319
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3319
     /* test for range errors (not always needed but do it anyway) */
#line 3319
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3319
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3319
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3319
    }
#line 3319
   /* copy workspace back if necessary */
#line 3319
    if (realign) {
#line 3319
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3319
      xp = (uint *) *xpp;
#line 3319
    }
#line 3319
   /* update xpp and tp */
#line 3319
    xp += ni;
#line 3319
    tp += ni;
#line 3319
    *xpp = (void*)xp;
#line 3319
  }
#line 3319
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3319

#line 3319
#else   /* not SX */
#line 3319

#line 3319
	char *xp = (char *) *xpp;
#line 3319
	int status = NC_NOERR;
#line 3319

#line 3319
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3319
	{
#line 3319
		int lstatus = ncx_put_uint_long(xp, tp, fillp);
#line 3319
		if (status == NC_NOERR) /* report the first encountered error */
#line 3319
			status = lstatus;
#line 3319
	}
#line 3319

#line 3319
	*xpp = (void *)xp;
#line 3319
	return status;
#line 3319
#endif
#line 3319
}
#line 3319

int
#line 3320
ncx_putn_uint_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3320
{
#line 3320
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3320

#line 3320
 /* basic algorithm is:
#line 3320
  *   - ensure sane alignment of output data
#line 3320
  *   - copy (conversion happens automatically) input data
#line 3320
  *     to output
#line 3320
  *   - update tp to point at next unconverted input, and xpp to point
#line 3320
  *     at next location for converted output
#line 3320
  */
#line 3320
  long i, j, ni;
#line 3320
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3320
  uint *xp;
#line 3320
  int nrange = 0;         /* number of range errors */
#line 3320
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3320
  long cxp = (long) *((char**)xpp);
#line 3320

#line 3320
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3320
  /* sjl: manually stripmine so we can limit amount of
#line 3320
   * vector work space reserved to LOOPCNT elements. Also
#line 3320
   * makes vectorisation easy */
#line 3320
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3320
    ni=Min(nelems-j,LOOPCNT);
#line 3320
    if (realign) {
#line 3320
      xp = tmp;
#line 3320
    } else {
#line 3320
      xp = (uint *) *xpp;
#line 3320
    }
#line 3320
   /* copy the next block */
#line 3320
#pragma cdir loopcnt=LOOPCNT
#line 3320
#pragma cdir shortloop
#line 3320
    for (i=0; i<ni; i++) {
#line 3320
      /* the normal case: */
#line 3320
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3320
     /* test for range errors (not always needed but do it anyway) */
#line 3320
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3320
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3320
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3320
    }
#line 3320
   /* copy workspace back if necessary */
#line 3320
    if (realign) {
#line 3320
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3320
      xp = (uint *) *xpp;
#line 3320
    }
#line 3320
   /* update xpp and tp */
#line 3320
    xp += ni;
#line 3320
    tp += ni;
#line 3320
    *xpp = (void*)xp;
#line 3320
  }
#line 3320
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3320

#line 3320
#else   /* not SX */
#line 3320

#line 3320
	char *xp = (char *) *xpp;
#line 3320
	int status = NC_NOERR;
#line 3320

#line 3320
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3320
	{
#line 3320
		int lstatus = ncx_put_uint_float(xp, tp, fillp);
#line 3320
		if (status == NC_NOERR) /* report the first encountered error */
#line 3320
			status = lstatus;
#line 3320
	}
#line 3320

#line 3320
	*xpp = (void *)xp;
#line 3320
	return status;
#line 3320
#endif
#line 3320
}
#line 3320

int
#line 3321
ncx_putn_uint_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3321
{
#line 3321
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3321

#line 3321
 /* basic algorithm is:
#line 3321
  *   - ensure sane alignment of output data
#line 3321
  *   - copy (conversion happens automatically) input data
#line 3321
  *     to output
#line 3321
  *   - update tp to point at next unconverted input, and xpp to point
#line 3321
  *     at next location for converted output
#line 3321
  */
#line 3321
  long i, j, ni;
#line 3321
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3321
  uint *xp;
#line 3321
  int nrange = 0;         /* number of range errors */
#line 3321
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3321
  long cxp = (long) *((char**)xpp);
#line 3321

#line 3321
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3321
  /* sjl: manually stripmine so we can limit amount of
#line 3321
   * vector work space reserved to LOOPCNT elements. Also
#line 3321
   * makes vectorisation easy */
#line 3321
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3321
    ni=Min(nelems-j,LOOPCNT);
#line 3321
    if (realign) {
#line 3321
      xp = tmp;
#line 3321
    } else {
#line 3321
      xp = (uint *) *xpp;
#line 3321
    }
#line 3321
   /* copy the next block */
#line 3321
#pragma cdir loopcnt=LOOPCNT
#line 3321
#pragma cdir shortloop
#line 3321
    for (i=0; i<ni; i++) {
#line 3321
      /* the normal case: */
#line 3321
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3321
     /* test for range errors (not always needed but do it anyway) */
#line 3321
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3321
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3321
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3321
    }
#line 3321
   /* copy workspace back if necessary */
#line 3321
    if (realign) {
#line 3321
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3321
      xp = (uint *) *xpp;
#line 3321
    }
#line 3321
   /* update xpp and tp */
#line 3321
    xp += ni;
#line 3321
    tp += ni;
#line 3321
    *xpp = (void*)xp;
#line 3321
  }
#line 3321
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3321

#line 3321
#else   /* not SX */
#line 3321

#line 3321
	char *xp = (char *) *xpp;
#line 3321
	int status = NC_NOERR;
#line 3321

#line 3321
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3321
	{
#line 3321
		int lstatus = ncx_put_uint_double(xp, tp, fillp);
#line 3321
		if (status == NC_NOERR) /* report the first encountered error */
#line 3321
			status = lstatus;
#line 3321
	}
#line 3321

#line 3321
	*xpp = (void *)xp;
#line 3321
	return status;
#line 3321
#endif
#line 3321
}
#line 3321

int
#line 3322
ncx_putn_uint_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3322
{
#line 3322
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3322

#line 3322
 /* basic algorithm is:
#line 3322
  *   - ensure sane alignment of output data
#line 3322
  *   - copy (conversion happens automatically) input data
#line 3322
  *     to output
#line 3322
  *   - update tp to point at next unconverted input, and xpp to point
#line 3322
  *     at next location for converted output
#line 3322
  */
#line 3322
  long i, j, ni;
#line 3322
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3322
  uint *xp;
#line 3322
  int nrange = 0;         /* number of range errors */
#line 3322
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3322
  long cxp = (long) *((char**)xpp);
#line 3322

#line 3322
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3322
  /* sjl: manually stripmine so we can limit amount of
#line 3322
   * vector work space reserved to LOOPCNT elements. Also
#line 3322
   * makes vectorisation easy */
#line 3322
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3322
    ni=Min(nelems-j,LOOPCNT);
#line 3322
    if (realign) {
#line 3322
      xp = tmp;
#line 3322
    } else {
#line 3322
      xp = (uint *) *xpp;
#line 3322
    }
#line 3322
   /* copy the next block */
#line 3322
#pragma cdir loopcnt=LOOPCNT
#line 3322
#pragma cdir shortloop
#line 3322
    for (i=0; i<ni; i++) {
#line 3322
      /* the normal case: */
#line 3322
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3322
     /* test for range errors (not always needed but do it anyway) */
#line 3322
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3322
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3322
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3322
    }
#line 3322
   /* copy workspace back if necessary */
#line 3322
    if (realign) {
#line 3322
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3322
      xp = (uint *) *xpp;
#line 3322
    }
#line 3322
   /* update xpp and tp */
#line 3322
    xp += ni;
#line 3322
    tp += ni;
#line 3322
    *xpp = (void*)xp;
#line 3322
  }
#line 3322
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3322

#line 3322
#else   /* not SX */
#line 3322

#line 3322
	char *xp = (char *) *xpp;
#line 3322
	int status = NC_NOERR;
#line 3322

#line 3322
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3322
	{
#line 3322
		int lstatus = ncx_put_uint_longlong(xp, tp, fillp);
#line 3322
		if (status == NC_NOERR) /* report the first encountered error */
#line 3322
			status = lstatus;
#line 3322
	}
#line 3322

#line 3322
	*xpp = (void *)xp;
#line 3322
	return status;
#line 3322
#endif
#line 3322
}
#line 3322

int
#line 3323
ncx_putn_uint_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3323
{
#line 3323
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3323

#line 3323
 /* basic algorithm is:
#line 3323
  *   - ensure sane alignment of output data
#line 3323
  *   - copy (conversion happens automatically) input data
#line 3323
  *     to output
#line 3323
  *   - update tp to point at next unconverted input, and xpp to point
#line 3323
  *     at next location for converted output
#line 3323
  */
#line 3323
  long i, j, ni;
#line 3323
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3323
  uint *xp;
#line 3323
  int nrange = 0;         /* number of range errors */
#line 3323
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3323
  long cxp = (long) *((char**)xpp);
#line 3323

#line 3323
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3323
  /* sjl: manually stripmine so we can limit amount of
#line 3323
   * vector work space reserved to LOOPCNT elements. Also
#line 3323
   * makes vectorisation easy */
#line 3323
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3323
    ni=Min(nelems-j,LOOPCNT);
#line 3323
    if (realign) {
#line 3323
      xp = tmp;
#line 3323
    } else {
#line 3323
      xp = (uint *) *xpp;
#line 3323
    }
#line 3323
   /* copy the next block */
#line 3323
#pragma cdir loopcnt=LOOPCNT
#line 3323
#pragma cdir shortloop
#line 3323
    for (i=0; i<ni; i++) {
#line 3323
      /* the normal case: */
#line 3323
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3323
     /* test for range errors (not always needed but do it anyway) */
#line 3323
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3323
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3323
      nrange += tp[i] > X_UINT_MAX ;
#line 3323
    }
#line 3323
   /* copy workspace back if necessary */
#line 3323
    if (realign) {
#line 3323
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3323
      xp = (uint *) *xpp;
#line 3323
    }
#line 3323
   /* update xpp and tp */
#line 3323
    xp += ni;
#line 3323
    tp += ni;
#line 3323
    *xpp = (void*)xp;
#line 3323
  }
#line 3323
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3323

#line 3323
#else   /* not SX */
#line 3323

#line 3323
	char *xp = (char *) *xpp;
#line 3323
	int status = NC_NOERR;
#line 3323

#line 3323
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3323
	{
#line 3323
		int lstatus = ncx_put_uint_uchar(xp, tp, fillp);
#line 3323
		if (status == NC_NOERR) /* report the first encountered error */
#line 3323
			status = lstatus;
#line 3323
	}
#line 3323

#line 3323
	*xpp = (void *)xp;
#line 3323
	return status;
#line 3323
#endif
#line 3323
}
#line 3323

int
#line 3324
ncx_putn_uint_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3324
{
#line 3324
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3324

#line 3324
 /* basic algorithm is:
#line 3324
  *   - ensure sane alignment of output data
#line 3324
  *   - copy (conversion happens automatically) input data
#line 3324
  *     to output
#line 3324
  *   - update tp to point at next unconverted input, and xpp to point
#line 3324
  *     at next location for converted output
#line 3324
  */
#line 3324
  long i, j, ni;
#line 3324
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3324
  uint *xp;
#line 3324
  int nrange = 0;         /* number of range errors */
#line 3324
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3324
  long cxp = (long) *((char**)xpp);
#line 3324

#line 3324
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3324
  /* sjl: manually stripmine so we can limit amount of
#line 3324
   * vector work space reserved to LOOPCNT elements. Also
#line 3324
   * makes vectorisation easy */
#line 3324
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3324
    ni=Min(nelems-j,LOOPCNT);
#line 3324
    if (realign) {
#line 3324
      xp = tmp;
#line 3324
    } else {
#line 3324
      xp = (uint *) *xpp;
#line 3324
    }
#line 3324
   /* copy the next block */
#line 3324
#pragma cdir loopcnt=LOOPCNT
#line 3324
#pragma cdir shortloop
#line 3324
    for (i=0; i<ni; i++) {
#line 3324
      /* the normal case: */
#line 3324
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3324
     /* test for range errors (not always needed but do it anyway) */
#line 3324
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3324
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3324
      nrange += tp[i] > X_UINT_MAX ;
#line 3324
    }
#line 3324
   /* copy workspace back if necessary */
#line 3324
    if (realign) {
#line 3324
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3324
      xp = (uint *) *xpp;
#line 3324
    }
#line 3324
   /* update xpp and tp */
#line 3324
    xp += ni;
#line 3324
    tp += ni;
#line 3324
    *xpp = (void*)xp;
#line 3324
  }
#line 3324
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3324

#line 3324
#else   /* not SX */
#line 3324

#line 3324
	char *xp = (char *) *xpp;
#line 3324
	int status = NC_NOERR;
#line 3324

#line 3324
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3324
	{
#line 3324
		int lstatus = ncx_put_uint_ushort(xp, tp, fillp);
#line 3324
		if (status == NC_NOERR) /* report the first encountered error */
#line 3324
			status = lstatus;
#line 3324
	}
#line 3324

#line 3324
	*xpp = (void *)xp;
#line 3324
	return status;
#line 3324
#endif
#line 3324
}
#line 3324

int
#line 3325
ncx_putn_uint_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3325
{
#line 3325
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3325

#line 3325
 /* basic algorithm is:
#line 3325
  *   - ensure sane alignment of output data
#line 3325
  *   - copy (conversion happens automatically) input data
#line 3325
  *     to output
#line 3325
  *   - update tp to point at next unconverted input, and xpp to point
#line 3325
  *     at next location for converted output
#line 3325
  */
#line 3325
  long i, j, ni;
#line 3325
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3325
  uint *xp;
#line 3325
  int nrange = 0;         /* number of range errors */
#line 3325
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3325
  long cxp = (long) *((char**)xpp);
#line 3325

#line 3325
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3325
  /* sjl: manually stripmine so we can limit amount of
#line 3325
   * vector work space reserved to LOOPCNT elements. Also
#line 3325
   * makes vectorisation easy */
#line 3325
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3325
    ni=Min(nelems-j,LOOPCNT);
#line 3325
    if (realign) {
#line 3325
      xp = tmp;
#line 3325
    } else {
#line 3325
      xp = (uint *) *xpp;
#line 3325
    }
#line 3325
   /* copy the next block */
#line 3325
#pragma cdir loopcnt=LOOPCNT
#line 3325
#pragma cdir shortloop
#line 3325
    for (i=0; i<ni; i++) {
#line 3325
      /* the normal case: */
#line 3325
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3325
     /* test for range errors (not always needed but do it anyway) */
#line 3325
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3325
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3325
      nrange += tp[i] > X_UINT_MAX ;
#line 3325
    }
#line 3325
   /* copy workspace back if necessary */
#line 3325
    if (realign) {
#line 3325
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3325
      xp = (uint *) *xpp;
#line 3325
    }
#line 3325
   /* update xpp and tp */
#line 3325
    xp += ni;
#line 3325
    tp += ni;
#line 3325
    *xpp = (void*)xp;
#line 3325
  }
#line 3325
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3325

#line 3325
#else   /* not SX */
#line 3325

#line 3325
	char *xp = (char *) *xpp;
#line 3325
	int status = NC_NOERR;
#line 3325

#line 3325
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3325
	{
#line 3325
		int lstatus = ncx_put_uint_ulonglong(xp, tp, fillp);
#line 3325
		if (status == NC_NOERR) /* report the first encountered error */
#line 3325
			status = lstatus;
#line 3325
	}
#line 3325

#line 3325
	*xpp = (void *)xp;
#line 3325
	return status;
#line 3325
#endif
#line 3325
}
#line 3325



/* float ---------------------------------------------------------------------*/

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_FLOAT);
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return NC_NOERR;
}
#elif defined(vax) && vax != 0
int
ncx_getn_float_float(const void **xpp, size_t nfloats, float *ip)
{
	float *const end = ip + nfloats;

	while (ip < end)
	{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 3351
		const struct ieee_single *const isp =
#line 3351
			 (const struct ieee_single *) (*xpp);
#line 3351
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 3351

#line 3351
		switch(exp) {
#line 3351
		case 0 :
#line 3351
			/* ieee subnormal */
#line 3351
			if (isp->mant_hi == min.ieee.mant_hi
#line 3351
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 3351
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 3351
			{
#line 3351
				*vsp = min.s;
#line 3351
			}
#line 3351
			else
#line 3351
			{
#line 3351
				unsigned mantissa = (isp->mant_hi << 16)
#line 3351
					 | isp->mant_lo_hi << 8
#line 3351
					 | isp->mant_lo_lo;
#line 3351
				unsigned tmp = mantissa >> 20;
#line 3351
				if (tmp >= 4) {
#line 3351
					vsp->exp = 2;
#line 3351
				} else if (tmp >= 2) {
#line 3351
					vsp->exp = 1;
#line 3351
				} else {
#line 3351
					*vsp = min.s;
#line 3351
					break;
#line 3351
				} /* else */
#line 3351
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 3351
				tmp <<= 3 - vsp->exp;
#line 3351
				vsp->mantissa2 = tmp;
#line 3351
				vsp->mantissa1 = (tmp >> 16);
#line 3351
			}
#line 3351
			break;
#line 3351
		case 0xfe :
#line 3351
		case 0xff :
#line 3351
			*vsp = max.s;
#line 3351
			break;
#line 3351
		default :
#line 3351
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 3351
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 3351
			vsp->mantissa1 = isp->mant_hi;
#line 3351
		}
#line 3351

#line 3351
		vsp->sign = isp->sign;
#line 3351


		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return NC_NOERR;
}
#else
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
	const char *xp = *xpp;
	int status = NC_NOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
	{
		const int lstatus = ncx_get_float_float(xp, tp, fillp);
		if (status == NC_NOERR) /* report the first encountered error */
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}

#endif
int
#line 3377
ncx_getn_float_schar(const void **xpp, size_t nelems, schar *tp)
#line 3377
{
#line 3377
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3377

#line 3377
 /* basic algorithm is:
#line 3377
  *   - ensure sane alignment of input data
#line 3377
  *   - copy (conversion happens automatically) input data
#line 3377
  *     to output
#line 3377
  *   - update xpp to point at next unconverted input, and tp to point
#line 3377
  *     at next location for converted output
#line 3377
  */
#line 3377
  long i, j, ni;
#line 3377
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3377
  float *xp;
#line 3377
  int nrange = 0;         /* number of range errors */
#line 3377
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3377
  long cxp = (long) *((char**)xpp);
#line 3377

#line 3377
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3377
  /* sjl: manually stripmine so we can limit amount of
#line 3377
   * vector work space reserved to LOOPCNT elements. Also
#line 3377
   * makes vectorisation easy */
#line 3377
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3377
    ni=Min(nelems-j,LOOPCNT);
#line 3377
    if (realign) {
#line 3377
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3377
      xp = tmp;
#line 3377
    } else {
#line 3377
      xp = (float *) *xpp;
#line 3377
    }
#line 3377
   /* copy the next block */
#line 3377
#pragma cdir loopcnt=LOOPCNT
#line 3377
#pragma cdir shortloop
#line 3377
    for (i=0; i<ni; i++) {
#line 3377
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3377
     /* test for range errors (not always needed but do it anyway) */
#line 3377
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3377
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3377
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3377
    }
#line 3377
   /* update xpp and tp */
#line 3377
    if (realign) xp = (float *) *xpp;
#line 3377
    xp += ni;
#line 3377
    tp += ni;
#line 3377
    *xpp = (void*)xp;
#line 3377
  }
#line 3377
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3377

#line 3377
#else   /* not SX */
#line 3377
	const char *xp = (const char *) *xpp;
#line 3377
	int status = NC_NOERR;
#line 3377

#line 3377
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3377
	{
#line 3377
		const int lstatus = ncx_get_float_schar(xp, tp);
#line 3377
		if (status == NC_NOERR) /* report the first encountered error */
#line 3377
			status = lstatus;
#line 3377
	}
#line 3377

#line 3377
	*xpp = (const void *)xp;
#line 3377
	return status;
#line 3377
#endif
#line 3377
}
#line 3377

int
#line 3378
ncx_getn_float_short(const void **xpp, size_t nelems, short *tp)
#line 3378
{
#line 3378
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3378

#line 3378
 /* basic algorithm is:
#line 3378
  *   - ensure sane alignment of input data
#line 3378
  *   - copy (conversion happens automatically) input data
#line 3378
  *     to output
#line 3378
  *   - update xpp to point at next unconverted input, and tp to point
#line 3378
  *     at next location for converted output
#line 3378
  */
#line 3378
  long i, j, ni;
#line 3378
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3378
  float *xp;
#line 3378
  int nrange = 0;         /* number of range errors */
#line 3378
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3378
  long cxp = (long) *((char**)xpp);
#line 3378

#line 3378
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3378
  /* sjl: manually stripmine so we can limit amount of
#line 3378
   * vector work space reserved to LOOPCNT elements. Also
#line 3378
   * makes vectorisation easy */
#line 3378
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3378
    ni=Min(nelems-j,LOOPCNT);
#line 3378
    if (realign) {
#line 3378
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3378
      xp = tmp;
#line 3378
    } else {
#line 3378
      xp = (float *) *xpp;
#line 3378
    }
#line 3378
   /* copy the next block */
#line 3378
#pragma cdir loopcnt=LOOPCNT
#line 3378
#pragma cdir shortloop
#line 3378
    for (i=0; i<ni; i++) {
#line 3378
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3378
     /* test for range errors (not always needed but do it anyway) */
#line 3378
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3378
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3378
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3378
    }
#line 3378
   /* update xpp and tp */
#line 3378
    if (realign) xp = (float *) *xpp;
#line 3378
    xp += ni;
#line 3378
    tp += ni;
#line 3378
    *xpp = (void*)xp;
#line 3378
  }
#line 3378
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3378

#line 3378
#else   /* not SX */
#line 3378
	const char *xp = (const char *) *xpp;
#line 3378
	int status = NC_NOERR;
#line 3378

#line 3378
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3378
	{
#line 3378
		const int lstatus = ncx_get_float_short(xp, tp);
#line 3378
		if (status == NC_NOERR) /* report the first encountered error */
#line 3378
			status = lstatus;
#line 3378
	}
#line 3378

#line 3378
	*xpp = (const void *)xp;
#line 3378
	return status;
#line 3378
#endif
#line 3378
}
#line 3378

int
#line 3379
ncx_getn_float_int(const void **xpp, size_t nelems, int *tp)
#line 3379
{
#line 3379
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3379

#line 3379
 /* basic algorithm is:
#line 3379
  *   - ensure sane alignment of input data
#line 3379
  *   - copy (conversion happens automatically) input data
#line 3379
  *     to output
#line 3379
  *   - update xpp to point at next unconverted input, and tp to point
#line 3379
  *     at next location for converted output
#line 3379
  */
#line 3379
  long i, j, ni;
#line 3379
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3379
  float *xp;
#line 3379
  int nrange = 0;         /* number of range errors */
#line 3379
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3379
  long cxp = (long) *((char**)xpp);
#line 3379

#line 3379
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3379
  /* sjl: manually stripmine so we can limit amount of
#line 3379
   * vector work space reserved to LOOPCNT elements. Also
#line 3379
   * makes vectorisation easy */
#line 3379
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3379
    ni=Min(nelems-j,LOOPCNT);
#line 3379
    if (realign) {
#line 3379
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3379
      xp = tmp;
#line 3379
    } else {
#line 3379
      xp = (float *) *xpp;
#line 3379
    }
#line 3379
   /* copy the next block */
#line 3379
#pragma cdir loopcnt=LOOPCNT
#line 3379
#pragma cdir shortloop
#line 3379
    for (i=0; i<ni; i++) {
#line 3379
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3379
     /* test for range errors (not always needed but do it anyway) */
#line 3379
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3379
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3379
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3379
    }
#line 3379
   /* update xpp and tp */
#line 3379
    if (realign) xp = (float *) *xpp;
#line 3379
    xp += ni;
#line 3379
    tp += ni;
#line 3379
    *xpp = (void*)xp;
#line 3379
  }
#line 3379
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3379

#line 3379
#else   /* not SX */
#line 3379
	const char *xp = (const char *) *xpp;
#line 3379
	int status = NC_NOERR;
#line 3379

#line 3379
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3379
	{
#line 3379
		const int lstatus = ncx_get_float_int(xp, tp);
#line 3379
		if (status == NC_NOERR) /* report the first encountered error */
#line 3379
			status = lstatus;
#line 3379
	}
#line 3379

#line 3379
	*xpp = (const void *)xp;
#line 3379
	return status;
#line 3379
#endif
#line 3379
}
#line 3379

int
#line 3380
ncx_getn_float_long(const void **xpp, size_t nelems, long *tp)
#line 3380
{
#line 3380
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3380

#line 3380
 /* basic algorithm is:
#line 3380
  *   - ensure sane alignment of input data
#line 3380
  *   - copy (conversion happens automatically) input data
#line 3380
  *     to output
#line 3380
  *   - update xpp to point at next unconverted input, and tp to point
#line 3380
  *     at next location for converted output
#line 3380
  */
#line 3380
  long i, j, ni;
#line 3380
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3380
  float *xp;
#line 3380
  int nrange = 0;         /* number of range errors */
#line 3380
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3380
  long cxp = (long) *((char**)xpp);
#line 3380

#line 3380
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3380
  /* sjl: manually stripmine so we can limit amount of
#line 3380
   * vector work space reserved to LOOPCNT elements. Also
#line 3380
   * makes vectorisation easy */
#line 3380
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3380
    ni=Min(nelems-j,LOOPCNT);
#line 3380
    if (realign) {
#line 3380
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3380
      xp = tmp;
#line 3380
    } else {
#line 3380
      xp = (float *) *xpp;
#line 3380
    }
#line 3380
   /* copy the next block */
#line 3380
#pragma cdir loopcnt=LOOPCNT
#line 3380
#pragma cdir shortloop
#line 3380
    for (i=0; i<ni; i++) {
#line 3380
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3380
     /* test for range errors (not always needed but do it anyway) */
#line 3380
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3380
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3380
      nrange += xp[i] > LONG_MAX || xp[i] < LONG_MIN;
#line 3380
    }
#line 3380
   /* update xpp and tp */
#line 3380
    if (realign) xp = (float *) *xpp;
#line 3380
    xp += ni;
#line 3380
    tp += ni;
#line 3380
    *xpp = (void*)xp;
#line 3380
  }
#line 3380
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3380

#line 3380
#else   /* not SX */
#line 3380
	const char *xp = (const char *) *xpp;
#line 3380
	int status = NC_NOERR;
#line 3380

#line 3380
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3380
	{
#line 3380
		const int lstatus = ncx_get_float_long(xp, tp);
#line 3380
		if (status == NC_NOERR) /* report the first encountered error */
#line 3380
			status = lstatus;
#line 3380
	}
#line 3380

#line 3380
	*xpp = (const void *)xp;
#line 3380
	return status;
#line 3380
#endif
#line 3380
}
#line 3380

int
#line 3381
ncx_getn_float_double(const void **xpp, size_t nelems, double *tp)
#line 3381
{
#line 3381
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3381

#line 3381
 /* basic algorithm is:
#line 3381
  *   - ensure sane alignment of input data
#line 3381
  *   - copy (conversion happens automatically) input data
#line 3381
  *     to output
#line 3381
  *   - update xpp to point at next unconverted input, and tp to point
#line 3381
  *     at next location for converted output
#line 3381
  */
#line 3381
  long i, j, ni;
#line 3381
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3381
  float *xp;
#line 3381
  int nrange = 0;         /* number of range errors */
#line 3381
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3381
  long cxp = (long) *((char**)xpp);
#line 3381

#line 3381
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3381
  /* sjl: manually stripmine so we can limit amount of
#line 3381
   * vector work space reserved to LOOPCNT elements. Also
#line 3381
   * makes vectorisation easy */
#line 3381
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3381
    ni=Min(nelems-j,LOOPCNT);
#line 3381
    if (realign) {
#line 3381
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3381
      xp = tmp;
#line 3381
    } else {
#line 3381
      xp = (float *) *xpp;
#line 3381
    }
#line 3381
   /* copy the next block */
#line 3381
#pragma cdir loopcnt=LOOPCNT
#line 3381
#pragma cdir shortloop
#line 3381
    for (i=0; i<ni; i++) {
#line 3381
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3381
     /* test for range errors (not always needed but do it anyway) */
#line 3381
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3381
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3381
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3381
    }
#line 3381
   /* update xpp and tp */
#line 3381
    if (realign) xp = (float *) *xpp;
#line 3381
    xp += ni;
#line 3381
    tp += ni;
#line 3381
    *xpp = (void*)xp;
#line 3381
  }
#line 3381
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3381

#line 3381
#else   /* not SX */
#line 3381
	const char *xp = (const char *) *xpp;
#line 3381
	int status = NC_NOERR;
#line 3381

#line 3381
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3381
	{
#line 3381
		const int lstatus = ncx_get_float_double(xp, tp);
#line 3381
		if (status == NC_NOERR) /* report the first encountered error */
#line 3381
			status = lstatus;
#line 3381
	}
#line 3381

#line 3381
	*xpp = (const void *)xp;
#line 3381
	return status;
#line 3381
#endif
#line 3381
}
#line 3381

int
#line 3382
ncx_getn_float_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3382
{
#line 3382
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3382

#line 3382
 /* basic algorithm is:
#line 3382
  *   - ensure sane alignment of input data
#line 3382
  *   - copy (conversion happens automatically) input data
#line 3382
  *     to output
#line 3382
  *   - update xpp to point at next unconverted input, and tp to point
#line 3382
  *     at next location for converted output
#line 3382
  */
#line 3382
  long i, j, ni;
#line 3382
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3382
  float *xp;
#line 3382
  int nrange = 0;         /* number of range errors */
#line 3382
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3382
  long cxp = (long) *((char**)xpp);
#line 3382

#line 3382
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3382
  /* sjl: manually stripmine so we can limit amount of
#line 3382
   * vector work space reserved to LOOPCNT elements. Also
#line 3382
   * makes vectorisation easy */
#line 3382
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3382
    ni=Min(nelems-j,LOOPCNT);
#line 3382
    if (realign) {
#line 3382
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3382
      xp = tmp;
#line 3382
    } else {
#line 3382
      xp = (float *) *xpp;
#line 3382
    }
#line 3382
   /* copy the next block */
#line 3382
#pragma cdir loopcnt=LOOPCNT
#line 3382
#pragma cdir shortloop
#line 3382
    for (i=0; i<ni; i++) {
#line 3382
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3382
     /* test for range errors (not always needed but do it anyway) */
#line 3382
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3382
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3382
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3382
    }
#line 3382
   /* update xpp and tp */
#line 3382
    if (realign) xp = (float *) *xpp;
#line 3382
    xp += ni;
#line 3382
    tp += ni;
#line 3382
    *xpp = (void*)xp;
#line 3382
  }
#line 3382
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3382

#line 3382
#else   /* not SX */
#line 3382
	const char *xp = (const char *) *xpp;
#line 3382
	int status = NC_NOERR;
#line 3382

#line 3382
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3382
	{
#line 3382
		const int lstatus = ncx_get_float_longlong(xp, tp);
#line 3382
		if (status == NC_NOERR) /* report the first encountered error */
#line 3382
			status = lstatus;
#line 3382
	}
#line 3382

#line 3382
	*xpp = (const void *)xp;
#line 3382
	return status;
#line 3382
#endif
#line 3382
}
#line 3382

int
#line 3383
ncx_getn_float_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3383
{
#line 3383
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3383

#line 3383
 /* basic algorithm is:
#line 3383
  *   - ensure sane alignment of input data
#line 3383
  *   - copy (conversion happens automatically) input data
#line 3383
  *     to output
#line 3383
  *   - update xpp to point at next unconverted input, and tp to point
#line 3383
  *     at next location for converted output
#line 3383
  */
#line 3383
  long i, j, ni;
#line 3383
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3383
  float *xp;
#line 3383
  int nrange = 0;         /* number of range errors */
#line 3383
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3383
  long cxp = (long) *((char**)xpp);
#line 3383

#line 3383
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3383
  /* sjl: manually stripmine so we can limit amount of
#line 3383
   * vector work space reserved to LOOPCNT elements. Also
#line 3383
   * makes vectorisation easy */
#line 3383
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3383
    ni=Min(nelems-j,LOOPCNT);
#line 3383
    if (realign) {
#line 3383
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3383
      xp = tmp;
#line 3383
    } else {
#line 3383
      xp = (float *) *xpp;
#line 3383
    }
#line 3383
   /* copy the next block */
#line 3383
#pragma cdir loopcnt=LOOPCNT
#line 3383
#pragma cdir shortloop
#line 3383
    for (i=0; i<ni; i++) {
#line 3383
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3383
     /* test for range errors (not always needed but do it anyway) */
#line 3383
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3383
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3383
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3383
    }
#line 3383
   /* update xpp and tp */
#line 3383
    if (realign) xp = (float *) *xpp;
#line 3383
    xp += ni;
#line 3383
    tp += ni;
#line 3383
    *xpp = (void*)xp;
#line 3383
  }
#line 3383
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3383

#line 3383
#else   /* not SX */
#line 3383
	const char *xp = (const char *) *xpp;
#line 3383
	int status = NC_NOERR;
#line 3383

#line 3383
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3383
	{
#line 3383
		const int lstatus = ncx_get_float_ushort(xp, tp);
#line 3383
		if (status == NC_NOERR) /* report the first encountered error */
#line 3383
			status = lstatus;
#line 3383
	}
#line 3383

#line 3383
	*xpp = (const void *)xp;
#line 3383
	return status;
#line 3383
#endif
#line 3383
}
#line 3383

int
#line 3384
ncx_getn_float_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3384
{
#line 3384
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3384

#line 3384
 /* basic algorithm is:
#line 3384
  *   - ensure sane alignment of input data
#line 3384
  *   - copy (conversion happens automatically) input data
#line 3384
  *     to output
#line 3384
  *   - update xpp to point at next unconverted input, and tp to point
#line 3384
  *     at next location for converted output
#line 3384
  */
#line 3384
  long i, j, ni;
#line 3384
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3384
  float *xp;
#line 3384
  int nrange = 0;         /* number of range errors */
#line 3384
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3384
  long cxp = (long) *((char**)xpp);
#line 3384

#line 3384
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3384
  /* sjl: manually stripmine so we can limit amount of
#line 3384
   * vector work space reserved to LOOPCNT elements. Also
#line 3384
   * makes vectorisation easy */
#line 3384
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3384
    ni=Min(nelems-j,LOOPCNT);
#line 3384
    if (realign) {
#line 3384
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3384
      xp = tmp;
#line 3384
    } else {
#line 3384
      xp = (float *) *xpp;
#line 3384
    }
#line 3384
   /* copy the next block */
#line 3384
#pragma cdir loopcnt=LOOPCNT
#line 3384
#pragma cdir shortloop
#line 3384
    for (i=0; i<ni; i++) {
#line 3384
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3384
     /* test for range errors (not always needed but do it anyway) */
#line 3384
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3384
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3384
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3384
    }
#line 3384
   /* update xpp and tp */
#line 3384
    if (realign) xp = (float *) *xpp;
#line 3384
    xp += ni;
#line 3384
    tp += ni;
#line 3384
    *xpp = (void*)xp;
#line 3384
  }
#line 3384
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3384

#line 3384
#else   /* not SX */
#line 3384
	const char *xp = (const char *) *xpp;
#line 3384
	int status = NC_NOERR;
#line 3384

#line 3384
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3384
	{
#line 3384
		const int lstatus = ncx_get_float_uchar(xp, tp);
#line 3384
		if (status == NC_NOERR) /* report the first encountered error */
#line 3384
			status = lstatus;
#line 3384
	}
#line 3384

#line 3384
	*xpp = (const void *)xp;
#line 3384
	return status;
#line 3384
#endif
#line 3384
}
#line 3384

int
#line 3385
ncx_getn_float_uint(const void **xpp, size_t nelems, uint *tp)
#line 3385
{
#line 3385
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3385

#line 3385
 /* basic algorithm is:
#line 3385
  *   - ensure sane alignment of input data
#line 3385
  *   - copy (conversion happens automatically) input data
#line 3385
  *     to output
#line 3385
  *   - update xpp to point at next unconverted input, and tp to point
#line 3385
  *     at next location for converted output
#line 3385
  */
#line 3385
  long i, j, ni;
#line 3385
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3385
  float *xp;
#line 3385
  int nrange = 0;         /* number of range errors */
#line 3385
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3385
  long cxp = (long) *((char**)xpp);
#line 3385

#line 3385
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3385
  /* sjl: manually stripmine so we can limit amount of
#line 3385
   * vector work space reserved to LOOPCNT elements. Also
#line 3385
   * makes vectorisation easy */
#line 3385
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3385
    ni=Min(nelems-j,LOOPCNT);
#line 3385
    if (realign) {
#line 3385
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3385
      xp = tmp;
#line 3385
    } else {
#line 3385
      xp = (float *) *xpp;
#line 3385
    }
#line 3385
   /* copy the next block */
#line 3385
#pragma cdir loopcnt=LOOPCNT
#line 3385
#pragma cdir shortloop
#line 3385
    for (i=0; i<ni; i++) {
#line 3385
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3385
     /* test for range errors (not always needed but do it anyway) */
#line 3385
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3385
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3385
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3385
    }
#line 3385
   /* update xpp and tp */
#line 3385
    if (realign) xp = (float *) *xpp;
#line 3385
    xp += ni;
#line 3385
    tp += ni;
#line 3385
    *xpp = (void*)xp;
#line 3385
  }
#line 3385
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3385

#line 3385
#else   /* not SX */
#line 3385
	const char *xp = (const char *) *xpp;
#line 3385
	int status = NC_NOERR;
#line 3385

#line 3385
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3385
	{
#line 3385
		const int lstatus = ncx_get_float_uint(xp, tp);
#line 3385
		if (status == NC_NOERR) /* report the first encountered error */
#line 3385
			status = lstatus;
#line 3385
	}
#line 3385

#line 3385
	*xpp = (const void *)xp;
#line 3385
	return status;
#line 3385
#endif
#line 3385
}
#line 3385

int
#line 3386
ncx_getn_float_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3386
{
#line 3386
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3386

#line 3386
 /* basic algorithm is:
#line 3386
  *   - ensure sane alignment of input data
#line 3386
  *   - copy (conversion happens automatically) input data
#line 3386
  *     to output
#line 3386
  *   - update xpp to point at next unconverted input, and tp to point
#line 3386
  *     at next location for converted output
#line 3386
  */
#line 3386
  long i, j, ni;
#line 3386
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3386
  float *xp;
#line 3386
  int nrange = 0;         /* number of range errors */
#line 3386
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3386
  long cxp = (long) *((char**)xpp);
#line 3386

#line 3386
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3386
  /* sjl: manually stripmine so we can limit amount of
#line 3386
   * vector work space reserved to LOOPCNT elements. Also
#line 3386
   * makes vectorisation easy */
#line 3386
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3386
    ni=Min(nelems-j,LOOPCNT);
#line 3386
    if (realign) {
#line 3386
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3386
      xp = tmp;
#line 3386
    } else {
#line 3386
      xp = (float *) *xpp;
#line 3386
    }
#line 3386
   /* copy the next block */
#line 3386
#pragma cdir loopcnt=LOOPCNT
#line 3386
#pragma cdir shortloop
#line 3386
    for (i=0; i<ni; i++) {
#line 3386
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3386
     /* test for range errors (not always needed but do it anyway) */
#line 3386
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3386
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3386
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3386
    }
#line 3386
   /* update xpp and tp */
#line 3386
    if (realign) xp = (float *) *xpp;
#line 3386
    xp += ni;
#line 3386
    tp += ni;
#line 3386
    *xpp = (void*)xp;
#line 3386
  }
#line 3386
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3386

#line 3386
#else   /* not SX */
#line 3386
	const char *xp = (const char *) *xpp;
#line 3386
	int status = NC_NOERR;
#line 3386

#line 3386
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3386
	{
#line 3386
		const int lstatus = ncx_get_float_ulonglong(xp, tp);
#line 3386
		if (status == NC_NOERR) /* report the first encountered error */
#line 3386
			status = lstatus;
#line 3386
	}
#line 3386

#line 3386
	*xpp = (const void *)xp;
#line 3386
	return status;
#line 3386
#endif
#line 3386
}
#line 3386


int
ncx_putn_float_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_FLOAT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return NC_NOERR;
}
#elif defined(vax) && vax != 0
{
	const float *const end = tp + nelems;

	while (tp < end) {
				const struct vax_single *const vsp =
#line 3406
			 (const struct vax_single *)ip;
#line 3406
		struct ieee_single *const isp = (struct ieee_single *) (*xpp);
#line 3406

#line 3406
		switch(vsp->exp){
#line 3406
		case 0 :
#line 3406
			/* all vax float with zero exponent map to zero */
#line 3406
			*isp = min.ieee;
#line 3406
			break;
#line 3406
		case 2 :
#line 3406
		case 1 :
#line 3406
		{
#line 3406
			/* These will map to subnormals */
#line 3406
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 3406
					 | vsp->mantissa2;
#line 3406
			mantissa >>= 3 - vsp->exp;
#line 3406
			mantissa += (1 << (20 + vsp->exp));
#line 3406
			isp->mant_lo_lo = mantissa;
#line 3406
			isp->mant_lo_hi = mantissa >> 8;
#line 3406
			isp->mant_hi = mantissa >> 16;
#line 3406
			isp->exp_lo = 0;
#line 3406
			isp->exp_hi = 0;
#line 3406
		}
#line 3406
			break;
#line 3406
		case 0xff : /* max.s.exp */
#line 3406
			if (vsp->mantissa2 == max.s.mantissa2 &&
#line 3406
			    vsp->mantissa1 == max.s.mantissa1)
#line 3406
			{
#line 3406
				/* map largest vax float to ieee infinity */
#line 3406
				*isp = max.ieee;
#line 3406
				break;
#line 3406
			} /* else, fall thru */
#line 3406
		default :
#line 3406
		{
#line 3406
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 3406
			isp->exp_hi = exp >> 1;
#line 3406
			isp->exp_lo = exp;
#line 3406
			isp->mant_lo_lo = vsp->mantissa2;
#line 3406
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 3406
			isp->mant_hi = vsp->mantissa1;
#line 3406
		}
#line 3406
		}
#line 3406

#line 3406
		isp->sign = vsp->sign;
#line 3406

		tp++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return NC_NOERR;
}
#else
{
	char *xp = *xpp;
	int status = NC_NOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++) {
		int lstatus = ncx_put_float_float(xp, tp, fillp);
		if (status == NC_NOERR) /* report the first encountered error */
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}
#endif
int
#line 3427
ncx_putn_float_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3427
{
#line 3427
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3427

#line 3427
 /* basic algorithm is:
#line 3427
  *   - ensure sane alignment of output data
#line 3427
  *   - copy (conversion happens automatically) input data
#line 3427
  *     to output
#line 3427
  *   - update tp to point at next unconverted input, and xpp to point
#line 3427
  *     at next location for converted output
#line 3427
  */
#line 3427
  long i, j, ni;
#line 3427
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3427
  float *xp;
#line 3427
  int nrange = 0;         /* number of range errors */
#line 3427
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3427
  long cxp = (long) *((char**)xpp);
#line 3427

#line 3427
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3427
  /* sjl: manually stripmine so we can limit amount of
#line 3427
   * vector work space reserved to LOOPCNT elements. Also
#line 3427
   * makes vectorisation easy */
#line 3427
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3427
    ni=Min(nelems-j,LOOPCNT);
#line 3427
    if (realign) {
#line 3427
      xp = tmp;
#line 3427
    } else {
#line 3427
      xp = (float *) *xpp;
#line 3427
    }
#line 3427
   /* copy the next block */
#line 3427
#pragma cdir loopcnt=LOOPCNT
#line 3427
#pragma cdir shortloop
#line 3427
    for (i=0; i<ni; i++) {
#line 3427
      /* the normal case: */
#line 3427
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3427
     /* test for range errors (not always needed but do it anyway) */
#line 3427
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3427
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3427
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3427
    }
#line 3427
   /* copy workspace back if necessary */
#line 3427
    if (realign) {
#line 3427
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3427
      xp = (float *) *xpp;
#line 3427
    }
#line 3427
   /* update xpp and tp */
#line 3427
    xp += ni;
#line 3427
    tp += ni;
#line 3427
    *xpp = (void*)xp;
#line 3427
  }
#line 3427
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3427

#line 3427
#else   /* not SX */
#line 3427

#line 3427
	char *xp = (char *) *xpp;
#line 3427
	int status = NC_NOERR;
#line 3427

#line 3427
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3427
	{
#line 3427
		int lstatus = ncx_put_float_schar(xp, tp, fillp);
#line 3427
		if (status == NC_NOERR) /* report the first encountered error */
#line 3427
			status = lstatus;
#line 3427
	}
#line 3427

#line 3427
	*xpp = (void *)xp;
#line 3427
	return status;
#line 3427
#endif
#line 3427
}
#line 3427

int
#line 3428
ncx_putn_float_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3428
{
#line 3428
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3428

#line 3428
 /* basic algorithm is:
#line 3428
  *   - ensure sane alignment of output data
#line 3428
  *   - copy (conversion happens automatically) input data
#line 3428
  *     to output
#line 3428
  *   - update tp to point at next unconverted input, and xpp to point
#line 3428
  *     at next location for converted output
#line 3428
  */
#line 3428
  long i, j, ni;
#line 3428
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3428
  float *xp;
#line 3428
  int nrange = 0;         /* number of range errors */
#line 3428
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3428
  long cxp = (long) *((char**)xpp);
#line 3428

#line 3428
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3428
  /* sjl: manually stripmine so we can limit amount of
#line 3428
   * vector work space reserved to LOOPCNT elements. Also
#line 3428
   * makes vectorisation easy */
#line 3428
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3428
    ni=Min(nelems-j,LOOPCNT);
#line 3428
    if (realign) {
#line 3428
      xp = tmp;
#line 3428
    } else {
#line 3428
      xp = (float *) *xpp;
#line 3428
    }
#line 3428
   /* copy the next block */
#line 3428
#pragma cdir loopcnt=LOOPCNT
#line 3428
#pragma cdir shortloop
#line 3428
    for (i=0; i<ni; i++) {
#line 3428
      /* the normal case: */
#line 3428
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3428
     /* test for range errors (not always needed but do it anyway) */
#line 3428
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3428
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3428
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3428
    }
#line 3428
   /* copy workspace back if necessary */
#line 3428
    if (realign) {
#line 3428
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3428
      xp = (float *) *xpp;
#line 3428
    }
#line 3428
   /* update xpp and tp */
#line 3428
    xp += ni;
#line 3428
    tp += ni;
#line 3428
    *xpp = (void*)xp;
#line 3428
  }
#line 3428
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3428

#line 3428
#else   /* not SX */
#line 3428

#line 3428
	char *xp = (char *) *xpp;
#line 3428
	int status = NC_NOERR;
#line 3428

#line 3428
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3428
	{
#line 3428
		int lstatus = ncx_put_float_short(xp, tp, fillp);
#line 3428
		if (status == NC_NOERR) /* report the first encountered error */
#line 3428
			status = lstatus;
#line 3428
	}
#line 3428

#line 3428
	*xpp = (void *)xp;
#line 3428
	return status;
#line 3428
#endif
#line 3428
}
#line 3428

int
#line 3429
ncx_putn_float_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3429
{
#line 3429
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3429

#line 3429
 /* basic algorithm is:
#line 3429
  *   - ensure sane alignment of output data
#line 3429
  *   - copy (conversion happens automatically) input data
#line 3429
  *     to output
#line 3429
  *   - update tp to point at next unconverted input, and xpp to point
#line 3429
  *     at next location for converted output
#line 3429
  */
#line 3429
  long i, j, ni;
#line 3429
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3429
  float *xp;
#line 3429
  int nrange = 0;         /* number of range errors */
#line 3429
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3429
  long cxp = (long) *((char**)xpp);
#line 3429

#line 3429
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3429
  /* sjl: manually stripmine so we can limit amount of
#line 3429
   * vector work space reserved to LOOPCNT elements. Also
#line 3429
   * makes vectorisation easy */
#line 3429
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3429
    ni=Min(nelems-j,LOOPCNT);
#line 3429
    if (realign) {
#line 3429
      xp = tmp;
#line 3429
    } else {
#line 3429
      xp = (float *) *xpp;
#line 3429
    }
#line 3429
   /* copy the next block */
#line 3429
#pragma cdir loopcnt=LOOPCNT
#line 3429
#pragma cdir shortloop
#line 3429
    for (i=0; i<ni; i++) {
#line 3429
      /* the normal case: */
#line 3429
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3429
     /* test for range errors (not always needed but do it anyway) */
#line 3429
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3429
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3429
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3429
    }
#line 3429
   /* copy workspace back if necessary */
#line 3429
    if (realign) {
#line 3429
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3429
      xp = (float *) *xpp;
#line 3429
    }
#line 3429
   /* update xpp and tp */
#line 3429
    xp += ni;
#line 3429
    tp += ni;
#line 3429
    *xpp = (void*)xp;
#line 3429
  }
#line 3429
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3429

#line 3429
#else   /* not SX */
#line 3429

#line 3429
	char *xp = (char *) *xpp;
#line 3429
	int status = NC_NOERR;
#line 3429

#line 3429
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3429
	{
#line 3429
		int lstatus = ncx_put_float_int(xp, tp, fillp);
#line 3429
		if (status == NC_NOERR) /* report the first encountered error */
#line 3429
			status = lstatus;
#line 3429
	}
#line 3429

#line 3429
	*xpp = (void *)xp;
#line 3429
	return status;
#line 3429
#endif
#line 3429
}
#line 3429

int
#line 3430
ncx_putn_float_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3430
{
#line 3430
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3430

#line 3430
 /* basic algorithm is:
#line 3430
  *   - ensure sane alignment of output data
#line 3430
  *   - copy (conversion happens automatically) input data
#line 3430
  *     to output
#line 3430
  *   - update tp to point at next unconverted input, and xpp to point
#line 3430
  *     at next location for converted output
#line 3430
  */
#line 3430
  long i, j, ni;
#line 3430
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3430
  float *xp;
#line 3430
  int nrange = 0;         /* number of range errors */
#line 3430
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3430
  long cxp = (long) *((char**)xpp);
#line 3430

#line 3430
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3430
  /* sjl: manually stripmine so we can limit amount of
#line 3430
   * vector work space reserved to LOOPCNT elements. Also
#line 3430
   * makes vectorisation easy */
#line 3430
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3430
    ni=Min(nelems-j,LOOPCNT);
#line 3430
    if (realign) {
#line 3430
      xp = tmp;
#line 3430
    } else {
#line 3430
      xp = (float *) *xpp;
#line 3430
    }
#line 3430
   /* copy the next block */
#line 3430
#pragma cdir loopcnt=LOOPCNT
#line 3430
#pragma cdir shortloop
#line 3430
    for (i=0; i<ni; i++) {
#line 3430
      /* the normal case: */
#line 3430
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3430
     /* test for range errors (not always needed but do it anyway) */
#line 3430
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3430
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3430
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3430
    }
#line 3430
   /* copy workspace back if necessary */
#line 3430
    if (realign) {
#line 3430
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3430
      xp = (float *) *xpp;
#line 3430
    }
#line 3430
   /* update xpp and tp */
#line 3430
    xp += ni;
#line 3430
    tp += ni;
#line 3430
    *xpp = (void*)xp;
#line 3430
  }
#line 3430
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3430

#line 3430
#else   /* not SX */
#line 3430

#line 3430
	char *xp = (char *) *xpp;
#line 3430
	int status = NC_NOERR;
#line 3430

#line 3430
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3430
	{
#line 3430
		int lstatus = ncx_put_float_long(xp, tp, fillp);
#line 3430
		if (status == NC_NOERR) /* report the first encountered error */
#line 3430
			status = lstatus;
#line 3430
	}
#line 3430

#line 3430
	*xpp = (void *)xp;
#line 3430
	return status;
#line 3430
#endif
#line 3430
}
#line 3430

int
#line 3431
ncx_putn_float_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3431
{
#line 3431
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3431

#line 3431
 /* basic algorithm is:
#line 3431
  *   - ensure sane alignment of output data
#line 3431
  *   - copy (conversion happens automatically) input data
#line 3431
  *     to output
#line 3431
  *   - update tp to point at next unconverted input, and xpp to point
#line 3431
  *     at next location for converted output
#line 3431
  */
#line 3431
  long i, j, ni;
#line 3431
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3431
  float *xp;
#line 3431
  int nrange = 0;         /* number of range errors */
#line 3431
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3431
  long cxp = (long) *((char**)xpp);
#line 3431

#line 3431
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3431
  /* sjl: manually stripmine so we can limit amount of
#line 3431
   * vector work space reserved to LOOPCNT elements. Also
#line 3431
   * makes vectorisation easy */
#line 3431
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3431
    ni=Min(nelems-j,LOOPCNT);
#line 3431
    if (realign) {
#line 3431
      xp = tmp;
#line 3431
    } else {
#line 3431
      xp = (float *) *xpp;
#line 3431
    }
#line 3431
   /* copy the next block */
#line 3431
#pragma cdir loopcnt=LOOPCNT
#line 3431
#pragma cdir shortloop
#line 3431
    for (i=0; i<ni; i++) {
#line 3431
      /* the normal case: */
#line 3431
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3431
     /* test for range errors (not always needed but do it anyway) */
#line 3431
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3431
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3431
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3431
    }
#line 3431
   /* copy workspace back if necessary */
#line 3431
    if (realign) {
#line 3431
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3431
      xp = (float *) *xpp;
#line 3431
    }
#line 3431
   /* update xpp and tp */
#line 3431
    xp += ni;
#line 3431
    tp += ni;
#line 3431
    *xpp = (void*)xp;
#line 3431
  }
#line 3431
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3431

#line 3431
#else   /* not SX */
#line 3431

#line 3431
	char *xp = (char *) *xpp;
#line 3431
	int status = NC_NOERR;
#line 3431

#line 3431
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3431
	{
#line 3431
		int lstatus = ncx_put_float_double(xp, tp, fillp);
#line 3431
		if (status == NC_NOERR) /* report the first encountered error */
#line 3431
			status = lstatus;
#line 3431
	}
#line 3431

#line 3431
	*xpp = (void *)xp;
#line 3431
	return status;
#line 3431
#endif
#line 3431
}
#line 3431

int
#line 3432
ncx_putn_float_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3432
{
#line 3432
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3432

#line 3432
 /* basic algorithm is:
#line 3432
  *   - ensure sane alignment of output data
#line 3432
  *   - copy (conversion happens automatically) input data
#line 3432
  *     to output
#line 3432
  *   - update tp to point at next unconverted input, and xpp to point
#line 3432
  *     at next location for converted output
#line 3432
  */
#line 3432
  long i, j, ni;
#line 3432
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3432
  float *xp;
#line 3432
  int nrange = 0;         /* number of range errors */
#line 3432
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3432
  long cxp = (long) *((char**)xpp);
#line 3432

#line 3432
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3432
  /* sjl: manually stripmine so we can limit amount of
#line 3432
   * vector work space reserved to LOOPCNT elements. Also
#line 3432
   * makes vectorisation easy */
#line 3432
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3432
    ni=Min(nelems-j,LOOPCNT);
#line 3432
    if (realign) {
#line 3432
      xp = tmp;
#line 3432
    } else {
#line 3432
      xp = (float *) *xpp;
#line 3432
    }
#line 3432
   /* copy the next block */
#line 3432
#pragma cdir loopcnt=LOOPCNT
#line 3432
#pragma cdir shortloop
#line 3432
    for (i=0; i<ni; i++) {
#line 3432
      /* the normal case: */
#line 3432
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3432
     /* test for range errors (not always needed but do it anyway) */
#line 3432
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3432
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3432
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3432
    }
#line 3432
   /* copy workspace back if necessary */
#line 3432
    if (realign) {
#line 3432
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3432
      xp = (float *) *xpp;
#line 3432
    }
#line 3432
   /* update xpp and tp */
#line 3432
    xp += ni;
#line 3432
    tp += ni;
#line 3432
    *xpp = (void*)xp;
#line 3432
  }
#line 3432
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3432

#line 3432
#else   /* not SX */
#line 3432

#line 3432
	char *xp = (char *) *xpp;
#line 3432
	int status = NC_NOERR;
#line 3432

#line 3432
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3432
	{
#line 3432
		int lstatus = ncx_put_float_longlong(xp, tp, fillp);
#line 3432
		if (status == NC_NOERR) /* report the first encountered error */
#line 3432
			status = lstatus;
#line 3432
	}
#line 3432

#line 3432
	*xpp = (void *)xp;
#line 3432
	return status;
#line 3432
#endif
#line 3432
}
#line 3432

int
#line 3433
ncx_putn_float_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3433
{
#line 3433
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3433

#line 3433
 /* basic algorithm is:
#line 3433
  *   - ensure sane alignment of output data
#line 3433
  *   - copy (conversion happens automatically) input data
#line 3433
  *     to output
#line 3433
  *   - update tp to point at next unconverted input, and xpp to point
#line 3433
  *     at next location for converted output
#line 3433
  */
#line 3433
  long i, j, ni;
#line 3433
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3433
  float *xp;
#line 3433
  int nrange = 0;         /* number of range errors */
#line 3433
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3433
  long cxp = (long) *((char**)xpp);
#line 3433

#line 3433
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3433
  /* sjl: manually stripmine so we can limit amount of
#line 3433
   * vector work space reserved to LOOPCNT elements. Also
#line 3433
   * makes vectorisation easy */
#line 3433
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3433
    ni=Min(nelems-j,LOOPCNT);
#line 3433
    if (realign) {
#line 3433
      xp = tmp;
#line 3433
    } else {
#line 3433
      xp = (float *) *xpp;
#line 3433
    }
#line 3433
   /* copy the next block */
#line 3433
#pragma cdir loopcnt=LOOPCNT
#line 3433
#pragma cdir shortloop
#line 3433
    for (i=0; i<ni; i++) {
#line 3433
      /* the normal case: */
#line 3433
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3433
     /* test for range errors (not always needed but do it anyway) */
#line 3433
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3433
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3433
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3433
    }
#line 3433
   /* copy workspace back if necessary */
#line 3433
    if (realign) {
#line 3433
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3433
      xp = (float *) *xpp;
#line 3433
    }
#line 3433
   /* update xpp and tp */
#line 3433
    xp += ni;
#line 3433
    tp += ni;
#line 3433
    *xpp = (void*)xp;
#line 3433
  }
#line 3433
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3433

#line 3433
#else   /* not SX */
#line 3433

#line 3433
	char *xp = (char *) *xpp;
#line 3433
	int status = NC_NOERR;
#line 3433

#line 3433
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3433
	{
#line 3433
		int lstatus = ncx_put_float_uchar(xp, tp, fillp);
#line 3433
		if (status == NC_NOERR) /* report the first encountered error */
#line 3433
			status = lstatus;
#line 3433
	}
#line 3433

#line 3433
	*xpp = (void *)xp;
#line 3433
	return status;
#line 3433
#endif
#line 3433
}
#line 3433

int
#line 3434
ncx_putn_float_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3434
{
#line 3434
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3434

#line 3434
 /* basic algorithm is:
#line 3434
  *   - ensure sane alignment of output data
#line 3434
  *   - copy (conversion happens automatically) input data
#line 3434
  *     to output
#line 3434
  *   - update tp to point at next unconverted input, and xpp to point
#line 3434
  *     at next location for converted output
#line 3434
  */
#line 3434
  long i, j, ni;
#line 3434
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3434
  float *xp;
#line 3434
  int nrange = 0;         /* number of range errors */
#line 3434
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3434
  long cxp = (long) *((char**)xpp);
#line 3434

#line 3434
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3434
  /* sjl: manually stripmine so we can limit amount of
#line 3434
   * vector work space reserved to LOOPCNT elements. Also
#line 3434
   * makes vectorisation easy */
#line 3434
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3434
    ni=Min(nelems-j,LOOPCNT);
#line 3434
    if (realign) {
#line 3434
      xp = tmp;
#line 3434
    } else {
#line 3434
      xp = (float *) *xpp;
#line 3434
    }
#line 3434
   /* copy the next block */
#line 3434
#pragma cdir loopcnt=LOOPCNT
#line 3434
#pragma cdir shortloop
#line 3434
    for (i=0; i<ni; i++) {
#line 3434
      /* the normal case: */
#line 3434
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3434
     /* test for range errors (not always needed but do it anyway) */
#line 3434
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3434
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3434
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3434
    }
#line 3434
   /* copy workspace back if necessary */
#line 3434
    if (realign) {
#line 3434
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3434
      xp = (float *) *xpp;
#line 3434
    }
#line 3434
   /* update xpp and tp */
#line 3434
    xp += ni;
#line 3434
    tp += ni;
#line 3434
    *xpp = (void*)xp;
#line 3434
  }
#line 3434
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3434

#line 3434
#else   /* not SX */
#line 3434

#line 3434
	char *xp = (char *) *xpp;
#line 3434
	int status = NC_NOERR;
#line 3434

#line 3434
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3434
	{
#line 3434
		int lstatus = ncx_put_float_ushort(xp, tp, fillp);
#line 3434
		if (status == NC_NOERR) /* report the first encountered error */
#line 3434
			status = lstatus;
#line 3434
	}
#line 3434

#line 3434
	*xpp = (void *)xp;
#line 3434
	return status;
#line 3434
#endif
#line 3434
}
#line 3434

int
#line 3435
ncx_putn_float_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3435
{
#line 3435
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3435

#line 3435
 /* basic algorithm is:
#line 3435
  *   - ensure sane alignment of output data
#line 3435
  *   - copy (conversion happens automatically) input data
#line 3435
  *     to output
#line 3435
  *   - update tp to point at next unconverted input, and xpp to point
#line 3435
  *     at next location for converted output
#line 3435
  */
#line 3435
  long i, j, ni;
#line 3435
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3435
  float *xp;
#line 3435
  int nrange = 0;         /* number of range errors */
#line 3435
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3435
  long cxp = (long) *((char**)xpp);
#line 3435

#line 3435
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3435
  /* sjl: manually stripmine so we can limit amount of
#line 3435
   * vector work space reserved to LOOPCNT elements. Also
#line 3435
   * makes vectorisation easy */
#line 3435
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3435
    ni=Min(nelems-j,LOOPCNT);
#line 3435
    if (realign) {
#line 3435
      xp = tmp;
#line 3435
    } else {
#line 3435
      xp = (float *) *xpp;
#line 3435
    }
#line 3435
   /* copy the next block */
#line 3435
#pragma cdir loopcnt=LOOPCNT
#line 3435
#pragma cdir shortloop
#line 3435
    for (i=0; i<ni; i++) {
#line 3435
      /* the normal case: */
#line 3435
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3435
     /* test for range errors (not always needed but do it anyway) */
#line 3435
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3435
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3435
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3435
    }
#line 3435
   /* copy workspace back if necessary */
#line 3435
    if (realign) {
#line 3435
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3435
      xp = (float *) *xpp;
#line 3435
    }
#line 3435
   /* update xpp and tp */
#line 3435
    xp += ni;
#line 3435
    tp += ni;
#line 3435
    *xpp = (void*)xp;
#line 3435
  }
#line 3435
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3435

#line 3435
#else   /* not SX */
#line 3435

#line 3435
	char *xp = (char *) *xpp;
#line 3435
	int status = NC_NOERR;
#line 3435

#line 3435
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3435
	{
#line 3435
		int lstatus = ncx_put_float_uint(xp, tp, fillp);
#line 3435
		if (status == NC_NOERR) /* report the first encountered error */
#line 3435
			status = lstatus;
#line 3435
	}
#line 3435

#line 3435
	*xpp = (void *)xp;
#line 3435
	return status;
#line 3435
#endif
#line 3435
}
#line 3435

int
#line 3436
ncx_putn_float_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3436
{
#line 3436
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3436

#line 3436
 /* basic algorithm is:
#line 3436
  *   - ensure sane alignment of output data
#line 3436
  *   - copy (conversion happens automatically) input data
#line 3436
  *     to output
#line 3436
  *   - update tp to point at next unconverted input, and xpp to point
#line 3436
  *     at next location for converted output
#line 3436
  */
#line 3436
  long i, j, ni;
#line 3436
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3436
  float *xp;
#line 3436
  int nrange = 0;         /* number of range errors */
#line 3436
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3436
  long cxp = (long) *((char**)xpp);
#line 3436

#line 3436
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3436
  /* sjl: manually stripmine so we can limit amount of
#line 3436
   * vector work space reserved to LOOPCNT elements. Also
#line 3436
   * makes vectorisation easy */
#line 3436
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3436
    ni=Min(nelems-j,LOOPCNT);
#line 3436
    if (realign) {
#line 3436
      xp = tmp;
#line 3436
    } else {
#line 3436
      xp = (float *) *xpp;
#line 3436
    }
#line 3436
   /* copy the next block */
#line 3436
#pragma cdir loopcnt=LOOPCNT
#line 3436
#pragma cdir shortloop
#line 3436
    for (i=0; i<ni; i++) {
#line 3436
      /* the normal case: */
#line 3436
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3436
     /* test for range errors (not always needed but do it anyway) */
#line 3436
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3436
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3436
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3436
    }
#line 3436
   /* copy workspace back if necessary */
#line 3436
    if (realign) {
#line 3436
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3436
      xp = (float *) *xpp;
#line 3436
    }
#line 3436
   /* update xpp and tp */
#line 3436
    xp += ni;
#line 3436
    tp += ni;
#line 3436
    *xpp = (void*)xp;
#line 3436
  }
#line 3436
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3436

#line 3436
#else   /* not SX */
#line 3436

#line 3436
	char *xp = (char *) *xpp;
#line 3436
	int status = NC_NOERR;
#line 3436

#line 3436
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3436
	{
#line 3436
		int lstatus = ncx_put_float_ulonglong(xp, tp, fillp);
#line 3436
		if (status == NC_NOERR) /* report the first encountered error */
#line 3436
			status = lstatus;
#line 3436
	}
#line 3436

#line 3436
	*xpp = (void *)xp;
#line 3436
	return status;
#line 3436
#endif
#line 3436
}
#line 3436


/* double --------------------------------------------------------------------*/

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_DOUBLE);
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return NC_NOERR;
}
#elif defined(vax) && vax != 0
int
ncx_getn_double_double(const void **xpp, size_t ndoubles, double *ip)
{
	double *const end = ip + ndoubles;

	while (ip < end)
	{
	struct vax_double *const vdp =
#line 3461
			 (struct vax_double *)ip;
#line 3461
	const struct ieee_double *const idp =
#line 3461
			 (const struct ieee_double *) (*xpp);
#line 3461
	{
#line 3461
		const struct dbl_limits *lim;
#line 3461
		int ii;
#line 3461
		for (ii = 0, lim = dbl_limits;
#line 3461
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 3461
			ii++, lim++)
#line 3461
		{
#line 3461
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 3461
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 3461
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 3461
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 3461
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 3461
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 3461
				)
#line 3461
			{
#line 3461
				*vdp = lim->d;
#line 3461
				goto doneit;
#line 3461
			}
#line 3461
		}
#line 3461
	}
#line 3461
	{
#line 3461
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 3461
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 3461
	}
#line 3461
	{
#line 3461
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 3461
				 | (idp->mant_5 << 8)
#line 3461
				 | idp->mant_4);
#line 3461
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 3461
		vdp->mantissa1 = (mant_hi >> 13);
#line 3461
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 3461
				| (mant_lo >> 29);
#line 3461
		vdp->mantissa3 = (mant_lo >> 13);
#line 3461
		vdp->mantissa4 = (mant_lo << 3);
#line 3461
	}
#line 3461
	doneit:
#line 3461
		vdp->sign = idp->sign;
#line 3461

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return NC_NOERR;
}
	/* vax */
#else
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
	const char *xp = *xpp;
	int status = NC_NOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		const int lstatus = ncx_get_double_double(xp, tp, fillp);
		if (status == NC_NOERR) /* report the first encountered error */
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}
#endif
int
#line 3486
ncx_getn_double_schar(const void **xpp, size_t nelems, schar *tp)
#line 3486
{
#line 3486
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3486

#line 3486
 /* basic algorithm is:
#line 3486
  *   - ensure sane alignment of input data
#line 3486
  *   - copy (conversion happens automatically) input data
#line 3486
  *     to output
#line 3486
  *   - update xpp to point at next unconverted input, and tp to point
#line 3486
  *     at next location for converted output
#line 3486
  */
#line 3486
  long i, j, ni;
#line 3486
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3486
  double *xp;
#line 3486
  int nrange = 0;         /* number of range errors */
#line 3486
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3486
  long cxp = (long) *((char**)xpp);
#line 3486

#line 3486
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3486
  /* sjl: manually stripmine so we can limit amount of
#line 3486
   * vector work space reserved to LOOPCNT elements. Also
#line 3486
   * makes vectorisation easy */
#line 3486
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3486
    ni=Min(nelems-j,LOOPCNT);
#line 3486
    if (realign) {
#line 3486
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3486
      xp = tmp;
#line 3486
    } else {
#line 3486
      xp = (double *) *xpp;
#line 3486
    }
#line 3486
   /* copy the next block */
#line 3486
#pragma cdir loopcnt=LOOPCNT
#line 3486
#pragma cdir shortloop
#line 3486
    for (i=0; i<ni; i++) {
#line 3486
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3486
     /* test for range errors (not always needed but do it anyway) */
#line 3486
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3486
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3486
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3486
    }
#line 3486
   /* update xpp and tp */
#line 3486
    if (realign) xp = (double *) *xpp;
#line 3486
    xp += ni;
#line 3486
    tp += ni;
#line 3486
    *xpp = (void*)xp;
#line 3486
  }
#line 3486
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3486

#line 3486
#else   /* not SX */
#line 3486
	const char *xp = (const char *) *xpp;
#line 3486
	int status = NC_NOERR;
#line 3486

#line 3486
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3486
	{
#line 3486
		const int lstatus = ncx_get_double_schar(xp, tp);
#line 3486
		if (status == NC_NOERR) /* report the first encountered error */
#line 3486
			status = lstatus;
#line 3486
	}
#line 3486

#line 3486
	*xpp = (const void *)xp;
#line 3486
	return status;
#line 3486
#endif
#line 3486
}
#line 3486

int
#line 3487
ncx_getn_double_short(const void **xpp, size_t nelems, short *tp)
#line 3487
{
#line 3487
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3487

#line 3487
 /* basic algorithm is:
#line 3487
  *   - ensure sane alignment of input data
#line 3487
  *   - copy (conversion happens automatically) input data
#line 3487
  *     to output
#line 3487
  *   - update xpp to point at next unconverted input, and tp to point
#line 3487
  *     at next location for converted output
#line 3487
  */
#line 3487
  long i, j, ni;
#line 3487
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3487
  double *xp;
#line 3487
  int nrange = 0;         /* number of range errors */
#line 3487
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3487
  long cxp = (long) *((char**)xpp);
#line 3487

#line 3487
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3487
  /* sjl: manually stripmine so we can limit amount of
#line 3487
   * vector work space reserved to LOOPCNT elements. Also
#line 3487
   * makes vectorisation easy */
#line 3487
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3487
    ni=Min(nelems-j,LOOPCNT);
#line 3487
    if (realign) {
#line 3487
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3487
      xp = tmp;
#line 3487
    } else {
#line 3487
      xp = (double *) *xpp;
#line 3487
    }
#line 3487
   /* copy the next block */
#line 3487
#pragma cdir loopcnt=LOOPCNT
#line 3487
#pragma cdir shortloop
#line 3487
    for (i=0; i<ni; i++) {
#line 3487
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3487
     /* test for range errors (not always needed but do it anyway) */
#line 3487
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3487
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3487
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3487
    }
#line 3487
   /* update xpp and tp */
#line 3487
    if (realign) xp = (double *) *xpp;
#line 3487
    xp += ni;
#line 3487
    tp += ni;
#line 3487
    *xpp = (void*)xp;
#line 3487
  }
#line 3487
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3487

#line 3487
#else   /* not SX */
#line 3487
	const char *xp = (const char *) *xpp;
#line 3487
	int status = NC_NOERR;
#line 3487

#line 3487
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3487
	{
#line 3487
		const int lstatus = ncx_get_double_short(xp, tp);
#line 3487
		if (status == NC_NOERR) /* report the first encountered error */
#line 3487
			status = lstatus;
#line 3487
	}
#line 3487

#line 3487
	*xpp = (const void *)xp;
#line 3487
	return status;
#line 3487
#endif
#line 3487
}
#line 3487

int
#line 3488
ncx_getn_double_int(const void **xpp, size_t nelems, int *tp)
#line 3488
{
#line 3488
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3488

#line 3488
 /* basic algorithm is:
#line 3488
  *   - ensure sane alignment of input data
#line 3488
  *   - copy (conversion happens automatically) input data
#line 3488
  *     to output
#line 3488
  *   - update xpp to point at next unconverted input, and tp to point
#line 3488
  *     at next location for converted output
#line 3488
  */
#line 3488
  long i, j, ni;
#line 3488
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3488
  double *xp;
#line 3488
  int nrange = 0;         /* number of range errors */
#line 3488
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3488
  long cxp = (long) *((char**)xpp);
#line 3488

#line 3488
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3488
  /* sjl: manually stripmine so we can limit amount of
#line 3488
   * vector work space reserved to LOOPCNT elements. Also
#line 3488
   * makes vectorisation easy */
#line 3488
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3488
    ni=Min(nelems-j,LOOPCNT);
#line 3488
    if (realign) {
#line 3488
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3488
      xp = tmp;
#line 3488
    } else {
#line 3488
      xp = (double *) *xpp;
#line 3488
    }
#line 3488
   /* copy the next block */
#line 3488
#pragma cdir loopcnt=LOOPCNT
#line 3488
#pragma cdir shortloop
#line 3488
    for (i=0; i<ni; i++) {
#line 3488
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3488
     /* test for range errors (not always needed but do it anyway) */
#line 3488
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3488
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3488
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3488
    }
#line 3488
   /* update xpp and tp */
#line 3488
    if (realign) xp = (double *) *xpp;
#line 3488
    xp += ni;
#line 3488
    tp += ni;
#line 3488
    *xpp = (void*)xp;
#line 3488
  }
#line 3488
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3488

#line 3488
#else   /* not SX */
#line 3488
	const char *xp = (const char *) *xpp;
#line 3488
	int status = NC_NOERR;
#line 3488

#line 3488
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3488
	{
#line 3488
		const int lstatus = ncx_get_double_int(xp, tp);
#line 3488
		if (status == NC_NOERR) /* report the first encountered error */
#line 3488
			status = lstatus;
#line 3488
	}
#line 3488

#line 3488
	*xpp = (const void *)xp;
#line 3488
	return status;
#line 3488
#endif
#line 3488
}
#line 3488

int
#line 3489
ncx_getn_double_long(const void **xpp, size_t nelems, long *tp)
#line 3489
{
#line 3489
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3489

#line 3489
 /* basic algorithm is:
#line 3489
  *   - ensure sane alignment of input data
#line 3489
  *   - copy (conversion happens automatically) input data
#line 3489
  *     to output
#line 3489
  *   - update xpp to point at next unconverted input, and tp to point
#line 3489
  *     at next location for converted output
#line 3489
  */
#line 3489
  long i, j, ni;
#line 3489
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3489
  double *xp;
#line 3489
  int nrange = 0;         /* number of range errors */
#line 3489
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3489
  long cxp = (long) *((char**)xpp);
#line 3489

#line 3489
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3489
  /* sjl: manually stripmine so we can limit amount of
#line 3489
   * vector work space reserved to LOOPCNT elements. Also
#line 3489
   * makes vectorisation easy */
#line 3489
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3489
    ni=Min(nelems-j,LOOPCNT);
#line 3489
    if (realign) {
#line 3489
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3489
      xp = tmp;
#line 3489
    } else {
#line 3489
      xp = (double *) *xpp;
#line 3489
    }
#line 3489
   /* copy the next block */
#line 3489
#pragma cdir loopcnt=LOOPCNT
#line 3489
#pragma cdir shortloop
#line 3489
    for (i=0; i<ni; i++) {
#line 3489
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3489
     /* test for range errors (not always needed but do it anyway) */
#line 3489
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3489
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3489
      nrange += xp[i] > LONG_MAX || xp[i] < LONG_MIN;
#line 3489
    }
#line 3489
   /* update xpp and tp */
#line 3489
    if (realign) xp = (double *) *xpp;
#line 3489
    xp += ni;
#line 3489
    tp += ni;
#line 3489
    *xpp = (void*)xp;
#line 3489
  }
#line 3489
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3489

#line 3489
#else   /* not SX */
#line 3489
	const char *xp = (const char *) *xpp;
#line 3489
	int status = NC_NOERR;
#line 3489

#line 3489
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3489
	{
#line 3489
		const int lstatus = ncx_get_double_long(xp, tp);
#line 3489
		if (status == NC_NOERR) /* report the first encountered error */
#line 3489
			status = lstatus;
#line 3489
	}
#line 3489

#line 3489
	*xpp = (const void *)xp;
#line 3489
	return status;
#line 3489
#endif
#line 3489
}
#line 3489

int
#line 3490
ncx_getn_double_float(const void **xpp, size_t nelems, float *tp)
#line 3490
{
#line 3490
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3490

#line 3490
 /* basic algorithm is:
#line 3490
  *   - ensure sane alignment of input data
#line 3490
  *   - copy (conversion happens automatically) input data
#line 3490
  *     to output
#line 3490
  *   - update xpp to point at next unconverted input, and tp to point
#line 3490
  *     at next location for converted output
#line 3490
  */
#line 3490
  long i, j, ni;
#line 3490
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3490
  double *xp;
#line 3490
  int nrange = 0;         /* number of range errors */
#line 3490
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3490
  long cxp = (long) *((char**)xpp);
#line 3490

#line 3490
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3490
  /* sjl: manually stripmine so we can limit amount of
#line 3490
   * vector work space reserved to LOOPCNT elements. Also
#line 3490
   * makes vectorisation easy */
#line 3490
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3490
    ni=Min(nelems-j,LOOPCNT);
#line 3490
    if (realign) {
#line 3490
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3490
      xp = tmp;
#line 3490
    } else {
#line 3490
      xp = (double *) *xpp;
#line 3490
    }
#line 3490
   /* copy the next block */
#line 3490
#pragma cdir loopcnt=LOOPCNT
#line 3490
#pragma cdir shortloop
#line 3490
    for (i=0; i<ni; i++) {
#line 3490
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3490
     /* test for range errors (not always needed but do it anyway) */
#line 3490
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3490
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3490
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3490
    }
#line 3490
   /* update xpp and tp */
#line 3490
    if (realign) xp = (double *) *xpp;
#line 3490
    xp += ni;
#line 3490
    tp += ni;
#line 3490
    *xpp = (void*)xp;
#line 3490
  }
#line 3490
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3490

#line 3490
#else   /* not SX */
#line 3490
	const char *xp = (const char *) *xpp;
#line 3490
	int status = NC_NOERR;
#line 3490

#line 3490
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3490
	{
#line 3490
		const int lstatus = ncx_get_double_float(xp, tp);
#line 3490
		if (status == NC_NOERR) /* report the first encountered error */
#line 3490
			status = lstatus;
#line 3490
	}
#line 3490

#line 3490
	*xpp = (const void *)xp;
#line 3490
	return status;
#line 3490
#endif
#line 3490
}
#line 3490

int
#line 3491
ncx_getn_double_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3491
{
#line 3491
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3491

#line 3491
 /* basic algorithm is:
#line 3491
  *   - ensure sane alignment of input data
#line 3491
  *   - copy (conversion happens automatically) input data
#line 3491
  *     to output
#line 3491
  *   - update xpp to point at next unconverted input, and tp to point
#line 3491
  *     at next location for converted output
#line 3491
  */
#line 3491
  long i, j, ni;
#line 3491
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3491
  double *xp;
#line 3491
  int nrange = 0;         /* number of range errors */
#line 3491
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3491
  long cxp = (long) *((char**)xpp);
#line 3491

#line 3491
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3491
  /* sjl: manually stripmine so we can limit amount of
#line 3491
   * vector work space reserved to LOOPCNT elements. Also
#line 3491
   * makes vectorisation easy */
#line 3491
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3491
    ni=Min(nelems-j,LOOPCNT);
#line 3491
    if (realign) {
#line 3491
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3491
      xp = tmp;
#line 3491
    } else {
#line 3491
      xp = (double *) *xpp;
#line 3491
    }
#line 3491
   /* copy the next block */
#line 3491
#pragma cdir loopcnt=LOOPCNT
#line 3491
#pragma cdir shortloop
#line 3491
    for (i=0; i<ni; i++) {
#line 3491
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3491
     /* test for range errors (not always needed but do it anyway) */
#line 3491
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3491
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3491
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3491
    }
#line 3491
   /* update xpp and tp */
#line 3491
    if (realign) xp = (double *) *xpp;
#line 3491
    xp += ni;
#line 3491
    tp += ni;
#line 3491
    *xpp = (void*)xp;
#line 3491
  }
#line 3491
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3491

#line 3491
#else   /* not SX */
#line 3491
	const char *xp = (const char *) *xpp;
#line 3491
	int status = NC_NOERR;
#line 3491

#line 3491
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3491
	{
#line 3491
		const int lstatus = ncx_get_double_longlong(xp, tp);
#line 3491
		if (status == NC_NOERR) /* report the first encountered error */
#line 3491
			status = lstatus;
#line 3491
	}
#line 3491

#line 3491
	*xpp = (const void *)xp;
#line 3491
	return status;
#line 3491
#endif
#line 3491
}
#line 3491

int
#line 3492
ncx_getn_double_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3492
{
#line 3492
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3492

#line 3492
 /* basic algorithm is:
#line 3492
  *   - ensure sane alignment of input data
#line 3492
  *   - copy (conversion happens automatically) input data
#line 3492
  *     to output
#line 3492
  *   - update xpp to point at next unconverted input, and tp to point
#line 3492
  *     at next location for converted output
#line 3492
  */
#line 3492
  long i, j, ni;
#line 3492
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3492
  double *xp;
#line 3492
  int nrange = 0;         /* number of range errors */
#line 3492
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3492
  long cxp = (long) *((char**)xpp);
#line 3492

#line 3492
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3492
  /* sjl: manually stripmine so we can limit amount of
#line 3492
   * vector work space reserved to LOOPCNT elements. Also
#line 3492
   * makes vectorisation easy */
#line 3492
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3492
    ni=Min(nelems-j,LOOPCNT);
#line 3492
    if (realign) {
#line 3492
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3492
      xp = tmp;
#line 3492
    } else {
#line 3492
      xp = (double *) *xpp;
#line 3492
    }
#line 3492
   /* copy the next block */
#line 3492
#pragma cdir loopcnt=LOOPCNT
#line 3492
#pragma cdir shortloop
#line 3492
    for (i=0; i<ni; i++) {
#line 3492
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3492
     /* test for range errors (not always needed but do it anyway) */
#line 3492
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3492
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3492
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3492
    }
#line 3492
   /* update xpp and tp */
#line 3492
    if (realign) xp = (double *) *xpp;
#line 3492
    xp += ni;
#line 3492
    tp += ni;
#line 3492
    *xpp = (void*)xp;
#line 3492
  }
#line 3492
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3492

#line 3492
#else   /* not SX */
#line 3492
	const char *xp = (const char *) *xpp;
#line 3492
	int status = NC_NOERR;
#line 3492

#line 3492
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3492
	{
#line 3492
		const int lstatus = ncx_get_double_uchar(xp, tp);
#line 3492
		if (status == NC_NOERR) /* report the first encountered error */
#line 3492
			status = lstatus;
#line 3492
	}
#line 3492

#line 3492
	*xpp = (const void *)xp;
#line 3492
	return status;
#line 3492
#endif
#line 3492
}
#line 3492

int
#line 3493
ncx_getn_double_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3493
{
#line 3493
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3493

#line 3493
 /* basic algorithm is:
#line 3493
  *   - ensure sane alignment of input data
#line 3493
  *   - copy (conversion happens automatically) input data
#line 3493
  *     to output
#line 3493
  *   - update xpp to point at next unconverted input, and tp to point
#line 3493
  *     at next location for converted output
#line 3493
  */
#line 3493
  long i, j, ni;
#line 3493
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3493
  double *xp;
#line 3493
  int nrange = 0;         /* number of range errors */
#line 3493
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3493
  long cxp = (long) *((char**)xpp);
#line 3493

#line 3493
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3493
  /* sjl: manually stripmine so we can limit amount of
#line 3493
   * vector work space reserved to LOOPCNT elements. Also
#line 3493
   * makes vectorisation easy */
#line 3493
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3493
    ni=Min(nelems-j,LOOPCNT);
#line 3493
    if (realign) {
#line 3493
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3493
      xp = tmp;
#line 3493
    } else {
#line 3493
      xp = (double *) *xpp;
#line 3493
    }
#line 3493
   /* copy the next block */
#line 3493
#pragma cdir loopcnt=LOOPCNT
#line 3493
#pragma cdir shortloop
#line 3493
    for (i=0; i<ni; i++) {
#line 3493
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3493
     /* test for range errors (not always needed but do it anyway) */
#line 3493
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3493
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3493
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3493
    }
#line 3493
   /* update xpp and tp */
#line 3493
    if (realign) xp = (double *) *xpp;
#line 3493
    xp += ni;
#line 3493
    tp += ni;
#line 3493
    *xpp = (void*)xp;
#line 3493
  }
#line 3493
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3493

#line 3493
#else   /* not SX */
#line 3493
	const char *xp = (const char *) *xpp;
#line 3493
	int status = NC_NOERR;
#line 3493

#line 3493
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3493
	{
#line 3493
		const int lstatus = ncx_get_double_ushort(xp, tp);
#line 3493
		if (status == NC_NOERR) /* report the first encountered error */
#line 3493
			status = lstatus;
#line 3493
	}
#line 3493

#line 3493
	*xpp = (const void *)xp;
#line 3493
	return status;
#line 3493
#endif
#line 3493
}
#line 3493

int
#line 3494
ncx_getn_double_uint(const void **xpp, size_t nelems, uint *tp)
#line 3494
{
#line 3494
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3494

#line 3494
 /* basic algorithm is:
#line 3494
  *   - ensure sane alignment of input data
#line 3494
  *   - copy (conversion happens automatically) input data
#line 3494
  *     to output
#line 3494
  *   - update xpp to point at next unconverted input, and tp to point
#line 3494
  *     at next location for converted output
#line 3494
  */
#line 3494
  long i, j, ni;
#line 3494
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3494
  double *xp;
#line 3494
  int nrange = 0;         /* number of range errors */
#line 3494
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3494
  long cxp = (long) *((char**)xpp);
#line 3494

#line 3494
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3494
  /* sjl: manually stripmine so we can limit amount of
#line 3494
   * vector work space reserved to LOOPCNT elements. Also
#line 3494
   * makes vectorisation easy */
#line 3494
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3494
    ni=Min(nelems-j,LOOPCNT);
#line 3494
    if (realign) {
#line 3494
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3494
      xp = tmp;
#line 3494
    } else {
#line 3494
      xp = (double *) *xpp;
#line 3494
    }
#line 3494
   /* copy the next block */
#line 3494
#pragma cdir loopcnt=LOOPCNT
#line 3494
#pragma cdir shortloop
#line 3494
    for (i=0; i<ni; i++) {
#line 3494
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3494
     /* test for range errors (not always needed but do it anyway) */
#line 3494
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3494
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3494
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3494
    }
#line 3494
   /* update xpp and tp */
#line 3494
    if (realign) xp = (double *) *xpp;
#line 3494
    xp += ni;
#line 3494
    tp += ni;
#line 3494
    *xpp = (void*)xp;
#line 3494
  }
#line 3494
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3494

#line 3494
#else   /* not SX */
#line 3494
	const char *xp = (const char *) *xpp;
#line 3494
	int status = NC_NOERR;
#line 3494

#line 3494
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3494
	{
#line 3494
		const int lstatus = ncx_get_double_uint(xp, tp);
#line 3494
		if (status == NC_NOERR) /* report the first encountered error */
#line 3494
			status = lstatus;
#line 3494
	}
#line 3494

#line 3494
	*xpp = (const void *)xp;
#line 3494
	return status;
#line 3494
#endif
#line 3494
}
#line 3494

int
#line 3495
ncx_getn_double_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3495
{
#line 3495
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3495

#line 3495
 /* basic algorithm is:
#line 3495
  *   - ensure sane alignment of input data
#line 3495
  *   - copy (conversion happens automatically) input data
#line 3495
  *     to output
#line 3495
  *   - update xpp to point at next unconverted input, and tp to point
#line 3495
  *     at next location for converted output
#line 3495
  */
#line 3495
  long i, j, ni;
#line 3495
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3495
  double *xp;
#line 3495
  int nrange = 0;         /* number of range errors */
#line 3495
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3495
  long cxp = (long) *((char**)xpp);
#line 3495

#line 3495
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3495
  /* sjl: manually stripmine so we can limit amount of
#line 3495
   * vector work space reserved to LOOPCNT elements. Also
#line 3495
   * makes vectorisation easy */
#line 3495
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3495
    ni=Min(nelems-j,LOOPCNT);
#line 3495
    if (realign) {
#line 3495
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3495
      xp = tmp;
#line 3495
    } else {
#line 3495
      xp = (double *) *xpp;
#line 3495
    }
#line 3495
   /* copy the next block */
#line 3495
#pragma cdir loopcnt=LOOPCNT
#line 3495
#pragma cdir shortloop
#line 3495
    for (i=0; i<ni; i++) {
#line 3495
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3495
     /* test for range errors (not always needed but do it anyway) */
#line 3495
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3495
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3495
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3495
    }
#line 3495
   /* update xpp and tp */
#line 3495
    if (realign) xp = (double *) *xpp;
#line 3495
    xp += ni;
#line 3495
    tp += ni;
#line 3495
    *xpp = (void*)xp;
#line 3495
  }
#line 3495
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3495

#line 3495
#else   /* not SX */
#line 3495
	const char *xp = (const char *) *xpp;
#line 3495
	int status = NC_NOERR;
#line 3495

#line 3495
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3495
	{
#line 3495
		const int lstatus = ncx_get_double_ulonglong(xp, tp);
#line 3495
		if (status == NC_NOERR) /* report the first encountered error */
#line 3495
			status = lstatus;
#line 3495
	}
#line 3495

#line 3495
	*xpp = (const void *)xp;
#line 3495
	return status;
#line 3495
#endif
#line 3495
}
#line 3495


#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_DOUBLE);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return NC_NOERR;
}
#elif defined(vax) && vax != 0
int
ncx_putn_double_double(void **xpp, size_t ndoubles, const double *ip, void *fillp)
{
	const double *const end = ip + ndoubles;

	while (ip < end)
	{
	const struct vax_double *const vdp =
#line 3518
			(const struct vax_double *)ip;
#line 3518
	struct ieee_double *const idp =
#line 3518
			 (struct ieee_double *) (*xpp);
#line 3518

#line 3518
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 3518
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 3518
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 3518
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 3518
		(vdp->exp == dbl_limits[0].d.exp))
#line 3518
	{
#line 3518
		*idp = dbl_limits[0].ieee;
#line 3518
		goto shipit;
#line 3518
	}
#line 3518
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 3518
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 3518
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 3518
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 3518
		(vdp->exp == dbl_limits[1].d.exp))
#line 3518
	{
#line 3518
		*idp = dbl_limits[1].ieee;
#line 3518
		goto shipit;
#line 3518
	}
#line 3518

#line 3518
	{
#line 3518
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 3518

#line 3518
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 3518
			(vdp->mantissa3 << 13) |
#line 3518
			((vdp->mantissa4 >> 3) & MASK(13));
#line 3518

#line 3518
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 3518
				 | (vdp->mantissa2 >> 3);
#line 3518

#line 3518
		if ((vdp->mantissa4 & 7) > 4)
#line 3518
		{
#line 3518
			/* round up */
#line 3518
			mant_lo++;
#line 3518
			if (mant_lo == 0)
#line 3518
			{
#line 3518
				mant_hi++;
#line 3518
				if (mant_hi > 0xffffff)
#line 3518
				{
#line 3518
					mant_hi = 0;
#line 3518
					exp++;
#line 3518
				}
#line 3518
			}
#line 3518
		}
#line 3518

#line 3518
		idp->mant_lo = SWAP4(mant_lo);
#line 3518
		idp->mant_6 = mant_hi >> 16;
#line 3518
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 3518
		idp->mant_4 = mant_hi;
#line 3518
		idp->exp_hi = exp >> 4;
#line 3518
		idp->exp_lo = exp;
#line 3518
	}
#line 3518

#line 3518
	shipit:
#line 3518
		idp->sign = vdp->sign;
#line 3518

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return NC_NOERR;
}
	/* vax */
#else
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp, void *fillp)
{
	char *xp = *xpp;
	int status = NC_NOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		int lstatus = ncx_put_double_double(xp, tp, fillp);
		if (status == NC_NOERR) /* report the first encountered error */
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}
#endif
int
#line 3543
ncx_putn_double_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3543
{
#line 3543
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3543

#line 3543
 /* basic algorithm is:
#line 3543
  *   - ensure sane alignment of output data
#line 3543
  *   - copy (conversion happens automatically) input data
#line 3543
  *     to output
#line 3543
  *   - update tp to point at next unconverted input, and xpp to point
#line 3543
  *     at next location for converted output
#line 3543
  */
#line 3543
  long i, j, ni;
#line 3543
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3543
  double *xp;
#line 3543
  int nrange = 0;         /* number of range errors */
#line 3543
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3543
  long cxp = (long) *((char**)xpp);
#line 3543

#line 3543
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3543
  /* sjl: manually stripmine so we can limit amount of
#line 3543
   * vector work space reserved to LOOPCNT elements. Also
#line 3543
   * makes vectorisation easy */
#line 3543
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3543
    ni=Min(nelems-j,LOOPCNT);
#line 3543
    if (realign) {
#line 3543
      xp = tmp;
#line 3543
    } else {
#line 3543
      xp = (double *) *xpp;
#line 3543
    }
#line 3543
   /* copy the next block */
#line 3543
#pragma cdir loopcnt=LOOPCNT
#line 3543
#pragma cdir shortloop
#line 3543
    for (i=0; i<ni; i++) {
#line 3543
      /* the normal case: */
#line 3543
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3543
     /* test for range errors (not always needed but do it anyway) */
#line 3543
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3543
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3543
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3543
    }
#line 3543
   /* copy workspace back if necessary */
#line 3543
    if (realign) {
#line 3543
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3543
      xp = (double *) *xpp;
#line 3543
    }
#line 3543
   /* update xpp and tp */
#line 3543
    xp += ni;
#line 3543
    tp += ni;
#line 3543
    *xpp = (void*)xp;
#line 3543
  }
#line 3543
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3543

#line 3543
#else   /* not SX */
#line 3543

#line 3543
	char *xp = (char *) *xpp;
#line 3543
	int status = NC_NOERR;
#line 3543

#line 3543
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3543
	{
#line 3543
		int lstatus = ncx_put_double_schar(xp, tp, fillp);
#line 3543
		if (status == NC_NOERR) /* report the first encountered error */
#line 3543
			status = lstatus;
#line 3543
	}
#line 3543

#line 3543
	*xpp = (void *)xp;
#line 3543
	return status;
#line 3543
#endif
#line 3543
}
#line 3543

int
#line 3544
ncx_putn_double_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3544
{
#line 3544
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3544

#line 3544
 /* basic algorithm is:
#line 3544
  *   - ensure sane alignment of output data
#line 3544
  *   - copy (conversion happens automatically) input data
#line 3544
  *     to output
#line 3544
  *   - update tp to point at next unconverted input, and xpp to point
#line 3544
  *     at next location for converted output
#line 3544
  */
#line 3544
  long i, j, ni;
#line 3544
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3544
  double *xp;
#line 3544
  int nrange = 0;         /* number of range errors */
#line 3544
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3544
  long cxp = (long) *((char**)xpp);
#line 3544

#line 3544
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3544
  /* sjl: manually stripmine so we can limit amount of
#line 3544
   * vector work space reserved to LOOPCNT elements. Also
#line 3544
   * makes vectorisation easy */
#line 3544
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3544
    ni=Min(nelems-j,LOOPCNT);
#line 3544
    if (realign) {
#line 3544
      xp = tmp;
#line 3544
    } else {
#line 3544
      xp = (double *) *xpp;
#line 3544
    }
#line 3544
   /* copy the next block */
#line 3544
#pragma cdir loopcnt=LOOPCNT
#line 3544
#pragma cdir shortloop
#line 3544
    for (i=0; i<ni; i++) {
#line 3544
      /* the normal case: */
#line 3544
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3544
     /* test for range errors (not always needed but do it anyway) */
#line 3544
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3544
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3544
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3544
    }
#line 3544
   /* copy workspace back if necessary */
#line 3544
    if (realign) {
#line 3544
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3544
      xp = (double *) *xpp;
#line 3544
    }
#line 3544
   /* update xpp and tp */
#line 3544
    xp += ni;
#line 3544
    tp += ni;
#line 3544
    *xpp = (void*)xp;
#line 3544
  }
#line 3544
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3544

#line 3544
#else   /* not SX */
#line 3544

#line 3544
	char *xp = (char *) *xpp;
#line 3544
	int status = NC_NOERR;
#line 3544

#line 3544
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3544
	{
#line 3544
		int lstatus = ncx_put_double_short(xp, tp, fillp);
#line 3544
		if (status == NC_NOERR) /* report the first encountered error */
#line 3544
			status = lstatus;
#line 3544
	}
#line 3544

#line 3544
	*xpp = (void *)xp;
#line 3544
	return status;
#line 3544
#endif
#line 3544
}
#line 3544

int
#line 3545
ncx_putn_double_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3545
{
#line 3545
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3545

#line 3545
 /* basic algorithm is:
#line 3545
  *   - ensure sane alignment of output data
#line 3545
  *   - copy (conversion happens automatically) input data
#line 3545
  *     to output
#line 3545
  *   - update tp to point at next unconverted input, and xpp to point
#line 3545
  *     at next location for converted output
#line 3545
  */
#line 3545
  long i, j, ni;
#line 3545
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3545
  double *xp;
#line 3545
  int nrange = 0;         /* number of range errors */
#line 3545
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3545
  long cxp = (long) *((char**)xpp);
#line 3545

#line 3545
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3545
  /* sjl: manually stripmine so we can limit amount of
#line 3545
   * vector work space reserved to LOOPCNT elements. Also
#line 3545
   * makes vectorisation easy */
#line 3545
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3545
    ni=Min(nelems-j,LOOPCNT);
#line 3545
    if (realign) {
#line 3545
      xp = tmp;
#line 3545
    } else {
#line 3545
      xp = (double *) *xpp;
#line 3545
    }
#line 3545
   /* copy the next block */
#line 3545
#pragma cdir loopcnt=LOOPCNT
#line 3545
#pragma cdir shortloop
#line 3545
    for (i=0; i<ni; i++) {
#line 3545
      /* the normal case: */
#line 3545
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3545
     /* test for range errors (not always needed but do it anyway) */
#line 3545
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3545
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3545
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3545
    }
#line 3545
   /* copy workspace back if necessary */
#line 3545
    if (realign) {
#line 3545
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3545
      xp = (double *) *xpp;
#line 3545
    }
#line 3545
   /* update xpp and tp */
#line 3545
    xp += ni;
#line 3545
    tp += ni;
#line 3545
    *xpp = (void*)xp;
#line 3545
  }
#line 3545
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3545

#line 3545
#else   /* not SX */
#line 3545

#line 3545
	char *xp = (char *) *xpp;
#line 3545
	int status = NC_NOERR;
#line 3545

#line 3545
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3545
	{
#line 3545
		int lstatus = ncx_put_double_int(xp, tp, fillp);
#line 3545
		if (status == NC_NOERR) /* report the first encountered error */
#line 3545
			status = lstatus;
#line 3545
	}
#line 3545

#line 3545
	*xpp = (void *)xp;
#line 3545
	return status;
#line 3545
#endif
#line 3545
}
#line 3545

int
#line 3546
ncx_putn_double_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3546
{
#line 3546
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3546

#line 3546
 /* basic algorithm is:
#line 3546
  *   - ensure sane alignment of output data
#line 3546
  *   - copy (conversion happens automatically) input data
#line 3546
  *     to output
#line 3546
  *   - update tp to point at next unconverted input, and xpp to point
#line 3546
  *     at next location for converted output
#line 3546
  */
#line 3546
  long i, j, ni;
#line 3546
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3546
  double *xp;
#line 3546
  int nrange = 0;         /* number of range errors */
#line 3546
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3546
  long cxp = (long) *((char**)xpp);
#line 3546

#line 3546
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3546
  /* sjl: manually stripmine so we can limit amount of
#line 3546
   * vector work space reserved to LOOPCNT elements. Also
#line 3546
   * makes vectorisation easy */
#line 3546
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3546
    ni=Min(nelems-j,LOOPCNT);
#line 3546
    if (realign) {
#line 3546
      xp = tmp;
#line 3546
    } else {
#line 3546
      xp = (double *) *xpp;
#line 3546
    }
#line 3546
   /* copy the next block */
#line 3546
#pragma cdir loopcnt=LOOPCNT
#line 3546
#pragma cdir shortloop
#line 3546
    for (i=0; i<ni; i++) {
#line 3546
      /* the normal case: */
#line 3546
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3546
     /* test for range errors (not always needed but do it anyway) */
#line 3546
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3546
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3546
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3546
    }
#line 3546
   /* copy workspace back if necessary */
#line 3546
    if (realign) {
#line 3546
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3546
      xp = (double *) *xpp;
#line 3546
    }
#line 3546
   /* update xpp and tp */
#line 3546
    xp += ni;
#line 3546
    tp += ni;
#line 3546
    *xpp = (void*)xp;
#line 3546
  }
#line 3546
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3546

#line 3546
#else   /* not SX */
#line 3546

#line 3546
	char *xp = (char *) *xpp;
#line 3546
	int status = NC_NOERR;
#line 3546

#line 3546
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3546
	{
#line 3546
		int lstatus = ncx_put_double_long(xp, tp, fillp);
#line 3546
		if (status == NC_NOERR) /* report the first encountered error */
#line 3546
			status = lstatus;
#line 3546
	}
#line 3546

#line 3546
	*xpp = (void *)xp;
#line 3546
	return status;
#line 3546
#endif
#line 3546
}
#line 3546

int
#line 3547
ncx_putn_double_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3547
{
#line 3547
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3547

#line 3547
 /* basic algorithm is:
#line 3547
  *   - ensure sane alignment of output data
#line 3547
  *   - copy (conversion happens automatically) input data
#line 3547
  *     to output
#line 3547
  *   - update tp to point at next unconverted input, and xpp to point
#line 3547
  *     at next location for converted output
#line 3547
  */
#line 3547
  long i, j, ni;
#line 3547
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3547
  double *xp;
#line 3547
  int nrange = 0;         /* number of range errors */
#line 3547
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3547
  long cxp = (long) *((char**)xpp);
#line 3547

#line 3547
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3547
  /* sjl: manually stripmine so we can limit amount of
#line 3547
   * vector work space reserved to LOOPCNT elements. Also
#line 3547
   * makes vectorisation easy */
#line 3547
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3547
    ni=Min(nelems-j,LOOPCNT);
#line 3547
    if (realign) {
#line 3547
      xp = tmp;
#line 3547
    } else {
#line 3547
      xp = (double *) *xpp;
#line 3547
    }
#line 3547
   /* copy the next block */
#line 3547
#pragma cdir loopcnt=LOOPCNT
#line 3547
#pragma cdir shortloop
#line 3547
    for (i=0; i<ni; i++) {
#line 3547
      /* the normal case: */
#line 3547
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3547
     /* test for range errors (not always needed but do it anyway) */
#line 3547
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3547
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3547
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3547
    }
#line 3547
   /* copy workspace back if necessary */
#line 3547
    if (realign) {
#line 3547
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3547
      xp = (double *) *xpp;
#line 3547
    }
#line 3547
   /* update xpp and tp */
#line 3547
    xp += ni;
#line 3547
    tp += ni;
#line 3547
    *xpp = (void*)xp;
#line 3547
  }
#line 3547
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3547

#line 3547
#else   /* not SX */
#line 3547

#line 3547
	char *xp = (char *) *xpp;
#line 3547
	int status = NC_NOERR;
#line 3547

#line 3547
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3547
	{
#line 3547
		int lstatus = ncx_put_double_float(xp, tp, fillp);
#line 3547
		if (status == NC_NOERR) /* report the first encountered error */
#line 3547
			status = lstatus;
#line 3547
	}
#line 3547

#line 3547
	*xpp = (void *)xp;
#line 3547
	return status;
#line 3547
#endif
#line 3547
}
#line 3547

int
#line 3548
ncx_putn_double_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3548
{
#line 3548
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3548

#line 3548
 /* basic algorithm is:
#line 3548
  *   - ensure sane alignment of output data
#line 3548
  *   - copy (conversion happens automatically) input data
#line 3548
  *     to output
#line 3548
  *   - update tp to point at next unconverted input, and xpp to point
#line 3548
  *     at next location for converted output
#line 3548
  */
#line 3548
  long i, j, ni;
#line 3548
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3548
  double *xp;
#line 3548
  int nrange = 0;         /* number of range errors */
#line 3548
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3548
  long cxp = (long) *((char**)xpp);
#line 3548

#line 3548
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3548
  /* sjl: manually stripmine so we can limit amount of
#line 3548
   * vector work space reserved to LOOPCNT elements. Also
#line 3548
   * makes vectorisation easy */
#line 3548
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3548
    ni=Min(nelems-j,LOOPCNT);
#line 3548
    if (realign) {
#line 3548
      xp = tmp;
#line 3548
    } else {
#line 3548
      xp = (double *) *xpp;
#line 3548
    }
#line 3548
   /* copy the next block */
#line 3548
#pragma cdir loopcnt=LOOPCNT
#line 3548
#pragma cdir shortloop
#line 3548
    for (i=0; i<ni; i++) {
#line 3548
      /* the normal case: */
#line 3548
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3548
     /* test for range errors (not always needed but do it anyway) */
#line 3548
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3548
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3548
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3548
    }
#line 3548
   /* copy workspace back if necessary */
#line 3548
    if (realign) {
#line 3548
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3548
      xp = (double *) *xpp;
#line 3548
    }
#line 3548
   /* update xpp and tp */
#line 3548
    xp += ni;
#line 3548
    tp += ni;
#line 3548
    *xpp = (void*)xp;
#line 3548
  }
#line 3548
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3548

#line 3548
#else   /* not SX */
#line 3548

#line 3548
	char *xp = (char *) *xpp;
#line 3548
	int status = NC_NOERR;
#line 3548

#line 3548
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3548
	{
#line 3548
		int lstatus = ncx_put_double_longlong(xp, tp, fillp);
#line 3548
		if (status == NC_NOERR) /* report the first encountered error */
#line 3548
			status = lstatus;
#line 3548
	}
#line 3548

#line 3548
	*xpp = (void *)xp;
#line 3548
	return status;
#line 3548
#endif
#line 3548
}
#line 3548

int
#line 3549
ncx_putn_double_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3549
{
#line 3549
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3549

#line 3549
 /* basic algorithm is:
#line 3549
  *   - ensure sane alignment of output data
#line 3549
  *   - copy (conversion happens automatically) input data
#line 3549
  *     to output
#line 3549
  *   - update tp to point at next unconverted input, and xpp to point
#line 3549
  *     at next location for converted output
#line 3549
  */
#line 3549
  long i, j, ni;
#line 3549
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3549
  double *xp;
#line 3549
  int nrange = 0;         /* number of range errors */
#line 3549
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3549
  long cxp = (long) *((char**)xpp);
#line 3549

#line 3549
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3549
  /* sjl: manually stripmine so we can limit amount of
#line 3549
   * vector work space reserved to LOOPCNT elements. Also
#line 3549
   * makes vectorisation easy */
#line 3549
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3549
    ni=Min(nelems-j,LOOPCNT);
#line 3549
    if (realign) {
#line 3549
      xp = tmp;
#line 3549
    } else {
#line 3549
      xp = (double *) *xpp;
#line 3549
    }
#line 3549
   /* copy the next block */
#line 3549
#pragma cdir loopcnt=LOOPCNT
#line 3549
#pragma cdir shortloop
#line 3549
    for (i=0; i<ni; i++) {
#line 3549
      /* the normal case: */
#line 3549
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3549
     /* test for range errors (not always needed but do it anyway) */
#line 3549
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3549
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3549
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3549
    }
#line 3549
   /* copy workspace back if necessary */
#line 3549
    if (realign) {
#line 3549
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3549
      xp = (double *) *xpp;
#line 3549
    }
#line 3549
   /* update xpp and tp */
#line 3549
    xp += ni;
#line 3549
    tp += ni;
#line 3549
    *xpp = (void*)xp;
#line 3549
  }
#line 3549
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3549

#line 3549
#else   /* not SX */
#line 3549

#line 3549
	char *xp = (char *) *xpp;
#line 3549
	int status = NC_NOERR;
#line 3549

#line 3549
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3549
	{
#line 3549
		int lstatus = ncx_put_double_uchar(xp, tp, fillp);
#line 3549
		if (status == NC_NOERR) /* report the first encountered error */
#line 3549
			status = lstatus;
#line 3549
	}
#line 3549

#line 3549
	*xpp = (void *)xp;
#line 3549
	return status;
#line 3549
#endif
#line 3549
}
#line 3549

int
#line 3550
ncx_putn_double_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3550
{
#line 3550
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3550

#line 3550
 /* basic algorithm is:
#line 3550
  *   - ensure sane alignment of output data
#line 3550
  *   - copy (conversion happens automatically) input data
#line 3550
  *     to output
#line 3550
  *   - update tp to point at next unconverted input, and xpp to point
#line 3550
  *     at next location for converted output
#line 3550
  */
#line 3550
  long i, j, ni;
#line 3550
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3550
  double *xp;
#line 3550
  int nrange = 0;         /* number of range errors */
#line 3550
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3550
  long cxp = (long) *((char**)xpp);
#line 3550

#line 3550
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3550
  /* sjl: manually stripmine so we can limit amount of
#line 3550
   * vector work space reserved to LOOPCNT elements. Also
#line 3550
   * makes vectorisation easy */
#line 3550
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3550
    ni=Min(nelems-j,LOOPCNT);
#line 3550
    if (realign) {
#line 3550
      xp = tmp;
#line 3550
    } else {
#line 3550
      xp = (double *) *xpp;
#line 3550
    }
#line 3550
   /* copy the next block */
#line 3550
#pragma cdir loopcnt=LOOPCNT
#line 3550
#pragma cdir shortloop
#line 3550
    for (i=0; i<ni; i++) {
#line 3550
      /* the normal case: */
#line 3550
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3550
     /* test for range errors (not always needed but do it anyway) */
#line 3550
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3550
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3550
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3550
    }
#line 3550
   /* copy workspace back if necessary */
#line 3550
    if (realign) {
#line 3550
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3550
      xp = (double *) *xpp;
#line 3550
    }
#line 3550
   /* update xpp and tp */
#line 3550
    xp += ni;
#line 3550
    tp += ni;
#line 3550
    *xpp = (void*)xp;
#line 3550
  }
#line 3550
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3550

#line 3550
#else   /* not SX */
#line 3550

#line 3550
	char *xp = (char *) *xpp;
#line 3550
	int status = NC_NOERR;
#line 3550

#line 3550
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3550
	{
#line 3550
		int lstatus = ncx_put_double_ushort(xp, tp, fillp);
#line 3550
		if (status == NC_NOERR) /* report the first encountered error */
#line 3550
			status = lstatus;
#line 3550
	}
#line 3550

#line 3550
	*xpp = (void *)xp;
#line 3550
	return status;
#line 3550
#endif
#line 3550
}
#line 3550

int
#line 3551
ncx_putn_double_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3551
{
#line 3551
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3551

#line 3551
 /* basic algorithm is:
#line 3551
  *   - ensure sane alignment of output data
#line 3551
  *   - copy (conversion happens automatically) input data
#line 3551
  *     to output
#line 3551
  *   - update tp to point at next unconverted input, and xpp to point
#line 3551
  *     at next location for converted output
#line 3551
  */
#line 3551
  long i, j, ni;
#line 3551
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3551
  double *xp;
#line 3551
  int nrange = 0;         /* number of range errors */
#line 3551
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3551
  long cxp = (long) *((char**)xpp);
#line 3551

#line 3551
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3551
  /* sjl: manually stripmine so we can limit amount of
#line 3551
   * vector work space reserved to LOOPCNT elements. Also
#line 3551
   * makes vectorisation easy */
#line 3551
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3551
    ni=Min(nelems-j,LOOPCNT);
#line 3551
    if (realign) {
#line 3551
      xp = tmp;
#line 3551
    } else {
#line 3551
      xp = (double *) *xpp;
#line 3551
    }
#line 3551
   /* copy the next block */
#line 3551
#pragma cdir loopcnt=LOOPCNT
#line 3551
#pragma cdir shortloop
#line 3551
    for (i=0; i<ni; i++) {
#line 3551
      /* the normal case: */
#line 3551
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3551
     /* test for range errors (not always needed but do it anyway) */
#line 3551
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3551
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3551
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3551
    }
#line 3551
   /* copy workspace back if necessary */
#line 3551
    if (realign) {
#line 3551
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3551
      xp = (double *) *xpp;
#line 3551
    }
#line 3551
   /* update xpp and tp */
#line 3551
    xp += ni;
#line 3551
    tp += ni;
#line 3551
    *xpp = (void*)xp;
#line 3551
  }
#line 3551
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3551

#line 3551
#else   /* not SX */
#line 3551

#line 3551
	char *xp = (char *) *xpp;
#line 3551
	int status = NC_NOERR;
#line 3551

#line 3551
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3551
	{
#line 3551
		int lstatus = ncx_put_double_uint(xp, tp, fillp);
#line 3551
		if (status == NC_NOERR) /* report the first encountered error */
#line 3551
			status = lstatus;
#line 3551
	}
#line 3551

#line 3551
	*xpp = (void *)xp;
#line 3551
	return status;
#line 3551
#endif
#line 3551
}
#line 3551

int
#line 3552
ncx_putn_double_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3552
{
#line 3552
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3552

#line 3552
 /* basic algorithm is:
#line 3552
  *   - ensure sane alignment of output data
#line 3552
  *   - copy (conversion happens automatically) input data
#line 3552
  *     to output
#line 3552
  *   - update tp to point at next unconverted input, and xpp to point
#line 3552
  *     at next location for converted output
#line 3552
  */
#line 3552
  long i, j, ni;
#line 3552
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3552
  double *xp;
#line 3552
  int nrange = 0;         /* number of range errors */
#line 3552
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3552
  long cxp = (long) *((char**)xpp);
#line 3552

#line 3552
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3552
  /* sjl: manually stripmine so we can limit amount of
#line 3552
   * vector work space reserved to LOOPCNT elements. Also
#line 3552
   * makes vectorisation easy */
#line 3552
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3552
    ni=Min(nelems-j,LOOPCNT);
#line 3552
    if (realign) {
#line 3552
      xp = tmp;
#line 3552
    } else {
#line 3552
      xp = (double *) *xpp;
#line 3552
    }
#line 3552
   /* copy the next block */
#line 3552
#pragma cdir loopcnt=LOOPCNT
#line 3552
#pragma cdir shortloop
#line 3552
    for (i=0; i<ni; i++) {
#line 3552
      /* the normal case: */
#line 3552
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3552
     /* test for range errors (not always needed but do it anyway) */
#line 3552
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3552
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3552
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3552
    }
#line 3552
   /* copy workspace back if necessary */
#line 3552
    if (realign) {
#line 3552
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3552
      xp = (double *) *xpp;
#line 3552
    }
#line 3552
   /* update xpp and tp */
#line 3552
    xp += ni;
#line 3552
    tp += ni;
#line 3552
    *xpp = (void*)xp;
#line 3552
  }
#line 3552
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3552

#line 3552
#else   /* not SX */
#line 3552

#line 3552
	char *xp = (char *) *xpp;
#line 3552
	int status = NC_NOERR;
#line 3552

#line 3552
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3552
	{
#line 3552
		int lstatus = ncx_put_double_ulonglong(xp, tp, fillp);
#line 3552
		if (status == NC_NOERR) /* report the first encountered error */
#line 3552
			status = lstatus;
#line 3552
	}
#line 3552

#line 3552
	*xpp = (void *)xp;
#line 3552
	return status;
#line 3552
#endif
#line 3552
}
#line 3552



/* longlong ------------------------------------------------------------------*/

#if X_SIZEOF_INT64 == SIZEOF_LONGLONG
/* optimized version */
int
ncx_getn_longlong_longlong(const void **xpp, size_t nelems, long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_LONG_LONG);
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_INT64);
	return NC_NOERR;
}
#else
int
#line 3571
ncx_getn_longlong_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3571
{
#line 3571
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3571

#line 3571
 /* basic algorithm is:
#line 3571
  *   - ensure sane alignment of input data
#line 3571
  *   - copy (conversion happens automatically) input data
#line 3571
  *     to output
#line 3571
  *   - update xpp to point at next unconverted input, and tp to point
#line 3571
  *     at next location for converted output
#line 3571
  */
#line 3571
  long i, j, ni;
#line 3571
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3571
  int64 *xp;
#line 3571
  int nrange = 0;         /* number of range errors */
#line 3571
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3571
  long cxp = (long) *((char**)xpp);
#line 3571

#line 3571
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3571
  /* sjl: manually stripmine so we can limit amount of
#line 3571
   * vector work space reserved to LOOPCNT elements. Also
#line 3571
   * makes vectorisation easy */
#line 3571
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3571
    ni=Min(nelems-j,LOOPCNT);
#line 3571
    if (realign) {
#line 3571
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3571
      xp = tmp;
#line 3571
    } else {
#line 3571
      xp = (int64 *) *xpp;
#line 3571
    }
#line 3571
   /* copy the next block */
#line 3571
#pragma cdir loopcnt=LOOPCNT
#line 3571
#pragma cdir shortloop
#line 3571
    for (i=0; i<ni; i++) {
#line 3571
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3571
     /* test for range errors (not always needed but do it anyway) */
#line 3571
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3571
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3571
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3571
    }
#line 3571
   /* update xpp and tp */
#line 3571
    if (realign) xp = (int64 *) *xpp;
#line 3571
    xp += ni;
#line 3571
    tp += ni;
#line 3571
    *xpp = (void*)xp;
#line 3571
  }
#line 3571
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3571

#line 3571
#else   /* not SX */
#line 3571
	const char *xp = (const char *) *xpp;
#line 3571
	int status = NC_NOERR;
#line 3571

#line 3571
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3571
	{
#line 3571
		const int lstatus = ncx_get_longlong_longlong(xp, tp);
#line 3571
		if (status == NC_NOERR) /* report the first encountered error */
#line 3571
			status = lstatus;
#line 3571
	}
#line 3571

#line 3571
	*xpp = (const void *)xp;
#line 3571
	return status;
#line 3571
#endif
#line 3571
}
#line 3571

#endif
int
#line 3573
ncx_getn_longlong_schar(const void **xpp, size_t nelems, schar *tp)
#line 3573
{
#line 3573
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3573

#line 3573
 /* basic algorithm is:
#line 3573
  *   - ensure sane alignment of input data
#line 3573
  *   - copy (conversion happens automatically) input data
#line 3573
  *     to output
#line 3573
  *   - update xpp to point at next unconverted input, and tp to point
#line 3573
  *     at next location for converted output
#line 3573
  */
#line 3573
  long i, j, ni;
#line 3573
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3573
  int64 *xp;
#line 3573
  int nrange = 0;         /* number of range errors */
#line 3573
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3573
  long cxp = (long) *((char**)xpp);
#line 3573

#line 3573
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3573
  /* sjl: manually stripmine so we can limit amount of
#line 3573
   * vector work space reserved to LOOPCNT elements. Also
#line 3573
   * makes vectorisation easy */
#line 3573
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3573
    ni=Min(nelems-j,LOOPCNT);
#line 3573
    if (realign) {
#line 3573
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3573
      xp = tmp;
#line 3573
    } else {
#line 3573
      xp = (int64 *) *xpp;
#line 3573
    }
#line 3573
   /* copy the next block */
#line 3573
#pragma cdir loopcnt=LOOPCNT
#line 3573
#pragma cdir shortloop
#line 3573
    for (i=0; i<ni; i++) {
#line 3573
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3573
     /* test for range errors (not always needed but do it anyway) */
#line 3573
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3573
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3573
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3573
    }
#line 3573
   /* update xpp and tp */
#line 3573
    if (realign) xp = (int64 *) *xpp;
#line 3573
    xp += ni;
#line 3573
    tp += ni;
#line 3573
    *xpp = (void*)xp;
#line 3573
  }
#line 3573
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3573

#line 3573
#else   /* not SX */
#line 3573
	const char *xp = (const char *) *xpp;
#line 3573
	int status = NC_NOERR;
#line 3573

#line 3573
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3573
	{
#line 3573
		const int lstatus = ncx_get_longlong_schar(xp, tp);
#line 3573
		if (status == NC_NOERR) /* report the first encountered error */
#line 3573
			status = lstatus;
#line 3573
	}
#line 3573

#line 3573
	*xpp = (const void *)xp;
#line 3573
	return status;
#line 3573
#endif
#line 3573
}
#line 3573

int
#line 3574
ncx_getn_longlong_short(const void **xpp, size_t nelems, short *tp)
#line 3574
{
#line 3574
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3574

#line 3574
 /* basic algorithm is:
#line 3574
  *   - ensure sane alignment of input data
#line 3574
  *   - copy (conversion happens automatically) input data
#line 3574
  *     to output
#line 3574
  *   - update xpp to point at next unconverted input, and tp to point
#line 3574
  *     at next location for converted output
#line 3574
  */
#line 3574
  long i, j, ni;
#line 3574
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3574
  int64 *xp;
#line 3574
  int nrange = 0;         /* number of range errors */
#line 3574
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3574
  long cxp = (long) *((char**)xpp);
#line 3574

#line 3574
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3574
  /* sjl: manually stripmine so we can limit amount of
#line 3574
   * vector work space reserved to LOOPCNT elements. Also
#line 3574
   * makes vectorisation easy */
#line 3574
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3574
    ni=Min(nelems-j,LOOPCNT);
#line 3574
    if (realign) {
#line 3574
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3574
      xp = tmp;
#line 3574
    } else {
#line 3574
      xp = (int64 *) *xpp;
#line 3574
    }
#line 3574
   /* copy the next block */
#line 3574
#pragma cdir loopcnt=LOOPCNT
#line 3574
#pragma cdir shortloop
#line 3574
    for (i=0; i<ni; i++) {
#line 3574
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3574
     /* test for range errors (not always needed but do it anyway) */
#line 3574
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3574
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3574
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3574
    }
#line 3574
   /* update xpp and tp */
#line 3574
    if (realign) xp = (int64 *) *xpp;
#line 3574
    xp += ni;
#line 3574
    tp += ni;
#line 3574
    *xpp = (void*)xp;
#line 3574
  }
#line 3574
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3574

#line 3574
#else   /* not SX */
#line 3574
	const char *xp = (const char *) *xpp;
#line 3574
	int status = NC_NOERR;
#line 3574

#line 3574
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3574
	{
#line 3574
		const int lstatus = ncx_get_longlong_short(xp, tp);
#line 3574
		if (status == NC_NOERR) /* report the first encountered error */
#line 3574
			status = lstatus;
#line 3574
	}
#line 3574

#line 3574
	*xpp = (const void *)xp;
#line 3574
	return status;
#line 3574
#endif
#line 3574
}
#line 3574

int
#line 3575
ncx_getn_longlong_int(const void **xpp, size_t nelems, int *tp)
#line 3575
{
#line 3575
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3575

#line 3575
 /* basic algorithm is:
#line 3575
  *   - ensure sane alignment of input data
#line 3575
  *   - copy (conversion happens automatically) input data
#line 3575
  *     to output
#line 3575
  *   - update xpp to point at next unconverted input, and tp to point
#line 3575
  *     at next location for converted output
#line 3575
  */
#line 3575
  long i, j, ni;
#line 3575
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3575
  int64 *xp;
#line 3575
  int nrange = 0;         /* number of range errors */
#line 3575
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3575
  long cxp = (long) *((char**)xpp);
#line 3575

#line 3575
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3575
  /* sjl: manually stripmine so we can limit amount of
#line 3575
   * vector work space reserved to LOOPCNT elements. Also
#line 3575
   * makes vectorisation easy */
#line 3575
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3575
    ni=Min(nelems-j,LOOPCNT);
#line 3575
    if (realign) {
#line 3575
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3575
      xp = tmp;
#line 3575
    } else {
#line 3575
      xp = (int64 *) *xpp;
#line 3575
    }
#line 3575
   /* copy the next block */
#line 3575
#pragma cdir loopcnt=LOOPCNT
#line 3575
#pragma cdir shortloop
#line 3575
    for (i=0; i<ni; i++) {
#line 3575
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3575
     /* test for range errors (not always needed but do it anyway) */
#line 3575
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3575
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3575
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3575
    }
#line 3575
   /* update xpp and tp */
#line 3575
    if (realign) xp = (int64 *) *xpp;
#line 3575
    xp += ni;
#line 3575
    tp += ni;
#line 3575
    *xpp = (void*)xp;
#line 3575
  }
#line 3575
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3575

#line 3575
#else   /* not SX */
#line 3575
	const char *xp = (const char *) *xpp;
#line 3575
	int status = NC_NOERR;
#line 3575

#line 3575
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3575
	{
#line 3575
		const int lstatus = ncx_get_longlong_int(xp, tp);
#line 3575
		if (status == NC_NOERR) /* report the first encountered error */
#line 3575
			status = lstatus;
#line 3575
	}
#line 3575

#line 3575
	*xpp = (const void *)xp;
#line 3575
	return status;
#line 3575
#endif
#line 3575
}
#line 3575

int
#line 3576
ncx_getn_longlong_long(const void **xpp, size_t nelems, long *tp)
#line 3576
{
#line 3576
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3576

#line 3576
 /* basic algorithm is:
#line 3576
  *   - ensure sane alignment of input data
#line 3576
  *   - copy (conversion happens automatically) input data
#line 3576
  *     to output
#line 3576
  *   - update xpp to point at next unconverted input, and tp to point
#line 3576
  *     at next location for converted output
#line 3576
  */
#line 3576
  long i, j, ni;
#line 3576
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3576
  int64 *xp;
#line 3576
  int nrange = 0;         /* number of range errors */
#line 3576
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3576
  long cxp = (long) *((char**)xpp);
#line 3576

#line 3576
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3576
  /* sjl: manually stripmine so we can limit amount of
#line 3576
   * vector work space reserved to LOOPCNT elements. Also
#line 3576
   * makes vectorisation easy */
#line 3576
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3576
    ni=Min(nelems-j,LOOPCNT);
#line 3576
    if (realign) {
#line 3576
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3576
      xp = tmp;
#line 3576
    } else {
#line 3576
      xp = (int64 *) *xpp;
#line 3576
    }
#line 3576
   /* copy the next block */
#line 3576
#pragma cdir loopcnt=LOOPCNT
#line 3576
#pragma cdir shortloop
#line 3576
    for (i=0; i<ni; i++) {
#line 3576
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3576
     /* test for range errors (not always needed but do it anyway) */
#line 3576
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3576
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3576
      nrange += xp[i] > LONG_MAX || xp[i] < LONG_MIN;
#line 3576
    }
#line 3576
   /* update xpp and tp */
#line 3576
    if (realign) xp = (int64 *) *xpp;
#line 3576
    xp += ni;
#line 3576
    tp += ni;
#line 3576
    *xpp = (void*)xp;
#line 3576
  }
#line 3576
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3576

#line 3576
#else   /* not SX */
#line 3576
	const char *xp = (const char *) *xpp;
#line 3576
	int status = NC_NOERR;
#line 3576

#line 3576
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3576
	{
#line 3576
		const int lstatus = ncx_get_longlong_long(xp, tp);
#line 3576
		if (status == NC_NOERR) /* report the first encountered error */
#line 3576
			status = lstatus;
#line 3576
	}
#line 3576

#line 3576
	*xpp = (const void *)xp;
#line 3576
	return status;
#line 3576
#endif
#line 3576
}
#line 3576

int
#line 3577
ncx_getn_longlong_float(const void **xpp, size_t nelems, float *tp)
#line 3577
{
#line 3577
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3577

#line 3577
 /* basic algorithm is:
#line 3577
  *   - ensure sane alignment of input data
#line 3577
  *   - copy (conversion happens automatically) input data
#line 3577
  *     to output
#line 3577
  *   - update xpp to point at next unconverted input, and tp to point
#line 3577
  *     at next location for converted output
#line 3577
  */
#line 3577
  long i, j, ni;
#line 3577
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3577
  int64 *xp;
#line 3577
  int nrange = 0;         /* number of range errors */
#line 3577
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3577
  long cxp = (long) *((char**)xpp);
#line 3577

#line 3577
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3577
  /* sjl: manually stripmine so we can limit amount of
#line 3577
   * vector work space reserved to LOOPCNT elements. Also
#line 3577
   * makes vectorisation easy */
#line 3577
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3577
    ni=Min(nelems-j,LOOPCNT);
#line 3577
    if (realign) {
#line 3577
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3577
      xp = tmp;
#line 3577
    } else {
#line 3577
      xp = (int64 *) *xpp;
#line 3577
    }
#line 3577
   /* copy the next block */
#line 3577
#pragma cdir loopcnt=LOOPCNT
#line 3577
#pragma cdir shortloop
#line 3577
    for (i=0; i<ni; i++) {
#line 3577
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3577
     /* test for range errors (not always needed but do it anyway) */
#line 3577
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3577
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3577
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3577
    }
#line 3577
   /* update xpp and tp */
#line 3577
    if (realign) xp = (int64 *) *xpp;
#line 3577
    xp += ni;
#line 3577
    tp += ni;
#line 3577
    *xpp = (void*)xp;
#line 3577
  }
#line 3577
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3577

#line 3577
#else   /* not SX */
#line 3577
	const char *xp = (const char *) *xpp;
#line 3577
	int status = NC_NOERR;
#line 3577

#line 3577
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3577
	{
#line 3577
		const int lstatus = ncx_get_longlong_float(xp, tp);
#line 3577
		if (status == NC_NOERR) /* report the first encountered error */
#line 3577
			status = lstatus;
#line 3577
	}
#line 3577

#line 3577
	*xpp = (const void *)xp;
#line 3577
	return status;
#line 3577
#endif
#line 3577
}
#line 3577

int
#line 3578
ncx_getn_longlong_double(const void **xpp, size_t nelems, double *tp)
#line 3578
{
#line 3578
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3578

#line 3578
 /* basic algorithm is:
#line 3578
  *   - ensure sane alignment of input data
#line 3578
  *   - copy (conversion happens automatically) input data
#line 3578
  *     to output
#line 3578
  *   - update xpp to point at next unconverted input, and tp to point
#line 3578
  *     at next location for converted output
#line 3578
  */
#line 3578
  long i, j, ni;
#line 3578
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3578
  int64 *xp;
#line 3578
  int nrange = 0;         /* number of range errors */
#line 3578
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3578
  long cxp = (long) *((char**)xpp);
#line 3578

#line 3578
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3578
  /* sjl: manually stripmine so we can limit amount of
#line 3578
   * vector work space reserved to LOOPCNT elements. Also
#line 3578
   * makes vectorisation easy */
#line 3578
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3578
    ni=Min(nelems-j,LOOPCNT);
#line 3578
    if (realign) {
#line 3578
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3578
      xp = tmp;
#line 3578
    } else {
#line 3578
      xp = (int64 *) *xpp;
#line 3578
    }
#line 3578
   /* copy the next block */
#line 3578
#pragma cdir loopcnt=LOOPCNT
#line 3578
#pragma cdir shortloop
#line 3578
    for (i=0; i<ni; i++) {
#line 3578
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3578
     /* test for range errors (not always needed but do it anyway) */
#line 3578
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3578
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3578
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3578
    }
#line 3578
   /* update xpp and tp */
#line 3578
    if (realign) xp = (int64 *) *xpp;
#line 3578
    xp += ni;
#line 3578
    tp += ni;
#line 3578
    *xpp = (void*)xp;
#line 3578
  }
#line 3578
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3578

#line 3578
#else   /* not SX */
#line 3578
	const char *xp = (const char *) *xpp;
#line 3578
	int status = NC_NOERR;
#line 3578

#line 3578
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3578
	{
#line 3578
		const int lstatus = ncx_get_longlong_double(xp, tp);
#line 3578
		if (status == NC_NOERR) /* report the first encountered error */
#line 3578
			status = lstatus;
#line 3578
	}
#line 3578

#line 3578
	*xpp = (const void *)xp;
#line 3578
	return status;
#line 3578
#endif
#line 3578
}
#line 3578

int
#line 3579
ncx_getn_longlong_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3579
{
#line 3579
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3579

#line 3579
 /* basic algorithm is:
#line 3579
  *   - ensure sane alignment of input data
#line 3579
  *   - copy (conversion happens automatically) input data
#line 3579
  *     to output
#line 3579
  *   - update xpp to point at next unconverted input, and tp to point
#line 3579
  *     at next location for converted output
#line 3579
  */
#line 3579
  long i, j, ni;
#line 3579
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3579
  int64 *xp;
#line 3579
  int nrange = 0;         /* number of range errors */
#line 3579
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3579
  long cxp = (long) *((char**)xpp);
#line 3579

#line 3579
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3579
  /* sjl: manually stripmine so we can limit amount of
#line 3579
   * vector work space reserved to LOOPCNT elements. Also
#line 3579
   * makes vectorisation easy */
#line 3579
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3579
    ni=Min(nelems-j,LOOPCNT);
#line 3579
    if (realign) {
#line 3579
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3579
      xp = tmp;
#line 3579
    } else {
#line 3579
      xp = (int64 *) *xpp;
#line 3579
    }
#line 3579
   /* copy the next block */
#line 3579
#pragma cdir loopcnt=LOOPCNT
#line 3579
#pragma cdir shortloop
#line 3579
    for (i=0; i<ni; i++) {
#line 3579
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3579
     /* test for range errors (not always needed but do it anyway) */
#line 3579
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3579
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3579
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3579
    }
#line 3579
   /* update xpp and tp */
#line 3579
    if (realign) xp = (int64 *) *xpp;
#line 3579
    xp += ni;
#line 3579
    tp += ni;
#line 3579
    *xpp = (void*)xp;
#line 3579
  }
#line 3579
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3579

#line 3579
#else   /* not SX */
#line 3579
	const char *xp = (const char *) *xpp;
#line 3579
	int status = NC_NOERR;
#line 3579

#line 3579
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3579
	{
#line 3579
		const int lstatus = ncx_get_longlong_uchar(xp, tp);
#line 3579
		if (status == NC_NOERR) /* report the first encountered error */
#line 3579
			status = lstatus;
#line 3579
	}
#line 3579

#line 3579
	*xpp = (const void *)xp;
#line 3579
	return status;
#line 3579
#endif
#line 3579
}
#line 3579

int
#line 3580
ncx_getn_longlong_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3580
{
#line 3580
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3580

#line 3580
 /* basic algorithm is:
#line 3580
  *   - ensure sane alignment of input data
#line 3580
  *   - copy (conversion happens automatically) input data
#line 3580
  *     to output
#line 3580
  *   - update xpp to point at next unconverted input, and tp to point
#line 3580
  *     at next location for converted output
#line 3580
  */
#line 3580
  long i, j, ni;
#line 3580
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3580
  int64 *xp;
#line 3580
  int nrange = 0;         /* number of range errors */
#line 3580
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3580
  long cxp = (long) *((char**)xpp);
#line 3580

#line 3580
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3580
  /* sjl: manually stripmine so we can limit amount of
#line 3580
   * vector work space reserved to LOOPCNT elements. Also
#line 3580
   * makes vectorisation easy */
#line 3580
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3580
    ni=Min(nelems-j,LOOPCNT);
#line 3580
    if (realign) {
#line 3580
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3580
      xp = tmp;
#line 3580
    } else {
#line 3580
      xp = (int64 *) *xpp;
#line 3580
    }
#line 3580
   /* copy the next block */
#line 3580
#pragma cdir loopcnt=LOOPCNT
#line 3580
#pragma cdir shortloop
#line 3580
    for (i=0; i<ni; i++) {
#line 3580
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3580
     /* test for range errors (not always needed but do it anyway) */
#line 3580
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3580
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3580
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3580
    }
#line 3580
   /* update xpp and tp */
#line 3580
    if (realign) xp = (int64 *) *xpp;
#line 3580
    xp += ni;
#line 3580
    tp += ni;
#line 3580
    *xpp = (void*)xp;
#line 3580
  }
#line 3580
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3580

#line 3580
#else   /* not SX */
#line 3580
	const char *xp = (const char *) *xpp;
#line 3580
	int status = NC_NOERR;
#line 3580

#line 3580
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3580
	{
#line 3580
		const int lstatus = ncx_get_longlong_ushort(xp, tp);
#line 3580
		if (status == NC_NOERR) /* report the first encountered error */
#line 3580
			status = lstatus;
#line 3580
	}
#line 3580

#line 3580
	*xpp = (const void *)xp;
#line 3580
	return status;
#line 3580
#endif
#line 3580
}
#line 3580

int
#line 3581
ncx_getn_longlong_uint(const void **xpp, size_t nelems, uint *tp)
#line 3581
{
#line 3581
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3581

#line 3581
 /* basic algorithm is:
#line 3581
  *   - ensure sane alignment of input data
#line 3581
  *   - copy (conversion happens automatically) input data
#line 3581
  *     to output
#line 3581
  *   - update xpp to point at next unconverted input, and tp to point
#line 3581
  *     at next location for converted output
#line 3581
  */
#line 3581
  long i, j, ni;
#line 3581
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3581
  int64 *xp;
#line 3581
  int nrange = 0;         /* number of range errors */
#line 3581
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3581
  long cxp = (long) *((char**)xpp);
#line 3581

#line 3581
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3581
  /* sjl: manually stripmine so we can limit amount of
#line 3581
   * vector work space reserved to LOOPCNT elements. Also
#line 3581
   * makes vectorisation easy */
#line 3581
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3581
    ni=Min(nelems-j,LOOPCNT);
#line 3581
    if (realign) {
#line 3581
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3581
      xp = tmp;
#line 3581
    } else {
#line 3581
      xp = (int64 *) *xpp;
#line 3581
    }
#line 3581
   /* copy the next block */
#line 3581
#pragma cdir loopcnt=LOOPCNT
#line 3581
#pragma cdir shortloop
#line 3581
    for (i=0; i<ni; i++) {
#line 3581
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3581
     /* test for range errors (not always needed but do it anyway) */
#line 3581
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3581
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3581
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3581
    }
#line 3581
   /* update xpp and tp */
#line 3581
    if (realign) xp = (int64 *) *xpp;
#line 3581
    xp += ni;
#line 3581
    tp += ni;
#line 3581
    *xpp = (void*)xp;
#line 3581
  }
#line 3581
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3581

#line 3581
#else   /* not SX */
#line 3581
	const char *xp = (const char *) *xpp;
#line 3581
	int status = NC_NOERR;
#line 3581

#line 3581
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3581
	{
#line 3581
		const int lstatus = ncx_get_longlong_uint(xp, tp);
#line 3581
		if (status == NC_NOERR) /* report the first encountered error */
#line 3581
			status = lstatus;
#line 3581
	}
#line 3581

#line 3581
	*xpp = (const void *)xp;
#line 3581
	return status;
#line 3581
#endif
#line 3581
}
#line 3581

int
#line 3582
ncx_getn_longlong_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3582
{
#line 3582
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3582

#line 3582
 /* basic algorithm is:
#line 3582
  *   - ensure sane alignment of input data
#line 3582
  *   - copy (conversion happens automatically) input data
#line 3582
  *     to output
#line 3582
  *   - update xpp to point at next unconverted input, and tp to point
#line 3582
  *     at next location for converted output
#line 3582
  */
#line 3582
  long i, j, ni;
#line 3582
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3582
  int64 *xp;
#line 3582
  int nrange = 0;         /* number of range errors */
#line 3582
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3582
  long cxp = (long) *((char**)xpp);
#line 3582

#line 3582
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3582
  /* sjl: manually stripmine so we can limit amount of
#line 3582
   * vector work space reserved to LOOPCNT elements. Also
#line 3582
   * makes vectorisation easy */
#line 3582
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3582
    ni=Min(nelems-j,LOOPCNT);
#line 3582
    if (realign) {
#line 3582
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3582
      xp = tmp;
#line 3582
    } else {
#line 3582
      xp = (int64 *) *xpp;
#line 3582
    }
#line 3582
   /* copy the next block */
#line 3582
#pragma cdir loopcnt=LOOPCNT
#line 3582
#pragma cdir shortloop
#line 3582
    for (i=0; i<ni; i++) {
#line 3582
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3582
     /* test for range errors (not always needed but do it anyway) */
#line 3582
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3582
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3582
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3582
    }
#line 3582
   /* update xpp and tp */
#line 3582
    if (realign) xp = (int64 *) *xpp;
#line 3582
    xp += ni;
#line 3582
    tp += ni;
#line 3582
    *xpp = (void*)xp;
#line 3582
  }
#line 3582
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3582

#line 3582
#else   /* not SX */
#line 3582
	const char *xp = (const char *) *xpp;
#line 3582
	int status = NC_NOERR;
#line 3582

#line 3582
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3582
	{
#line 3582
		const int lstatus = ncx_get_longlong_ulonglong(xp, tp);
#line 3582
		if (status == NC_NOERR) /* report the first encountered error */
#line 3582
			status = lstatus;
#line 3582
	}
#line 3582

#line 3582
	*xpp = (const void *)xp;
#line 3582
	return status;
#line 3582
#endif
#line 3582
}
#line 3582


#if X_SIZEOF_INT64 == SIZEOF_LONGLONG
/* optimized version */
int
ncx_putn_longlong_longlong(void **xpp, size_t nelems, const long long *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_INT64);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT64);
	return NC_NOERR;
}
#else
int
#line 3598
ncx_putn_longlong_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3598
{
#line 3598
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3598

#line 3598
 /* basic algorithm is:
#line 3598
  *   - ensure sane alignment of output data
#line 3598
  *   - copy (conversion happens automatically) input data
#line 3598
  *     to output
#line 3598
  *   - update tp to point at next unconverted input, and xpp to point
#line 3598
  *     at next location for converted output
#line 3598
  */
#line 3598
  long i, j, ni;
#line 3598
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3598
  int64 *xp;
#line 3598
  int nrange = 0;         /* number of range errors */
#line 3598
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3598
  long cxp = (long) *((char**)xpp);
#line 3598

#line 3598
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3598
  /* sjl: manually stripmine so we can limit amount of
#line 3598
   * vector work space reserved to LOOPCNT elements. Also
#line 3598
   * makes vectorisation easy */
#line 3598
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3598
    ni=Min(nelems-j,LOOPCNT);
#line 3598
    if (realign) {
#line 3598
      xp = tmp;
#line 3598
    } else {
#line 3598
      xp = (int64 *) *xpp;
#line 3598
    }
#line 3598
   /* copy the next block */
#line 3598
#pragma cdir loopcnt=LOOPCNT
#line 3598
#pragma cdir shortloop
#line 3598
    for (i=0; i<ni; i++) {
#line 3598
      /* the normal case: */
#line 3598
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3598
     /* test for range errors (not always needed but do it anyway) */
#line 3598
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3598
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3598
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3598
    }
#line 3598
   /* copy workspace back if necessary */
#line 3598
    if (realign) {
#line 3598
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3598
      xp = (int64 *) *xpp;
#line 3598
    }
#line 3598
   /* update xpp and tp */
#line 3598
    xp += ni;
#line 3598
    tp += ni;
#line 3598
    *xpp = (void*)xp;
#line 3598
  }
#line 3598
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3598

#line 3598
#else   /* not SX */
#line 3598

#line 3598
	char *xp = (char *) *xpp;
#line 3598
	int status = NC_NOERR;
#line 3598

#line 3598
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3598
	{
#line 3598
		int lstatus = ncx_put_longlong_longlong(xp, tp, fillp);
#line 3598
		if (status == NC_NOERR) /* report the first encountered error */
#line 3598
			status = lstatus;
#line 3598
	}
#line 3598

#line 3598
	*xpp = (void *)xp;
#line 3598
	return status;
#line 3598
#endif
#line 3598
}
#line 3598

#endif
int
#line 3600
ncx_putn_longlong_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3600
{
#line 3600
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3600

#line 3600
 /* basic algorithm is:
#line 3600
  *   - ensure sane alignment of output data
#line 3600
  *   - copy (conversion happens automatically) input data
#line 3600
  *     to output
#line 3600
  *   - update tp to point at next unconverted input, and xpp to point
#line 3600
  *     at next location for converted output
#line 3600
  */
#line 3600
  long i, j, ni;
#line 3600
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3600
  int64 *xp;
#line 3600
  int nrange = 0;         /* number of range errors */
#line 3600
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3600
  long cxp = (long) *((char**)xpp);
#line 3600

#line 3600
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3600
  /* sjl: manually stripmine so we can limit amount of
#line 3600
   * vector work space reserved to LOOPCNT elements. Also
#line 3600
   * makes vectorisation easy */
#line 3600
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3600
    ni=Min(nelems-j,LOOPCNT);
#line 3600
    if (realign) {
#line 3600
      xp = tmp;
#line 3600
    } else {
#line 3600
      xp = (int64 *) *xpp;
#line 3600
    }
#line 3600
   /* copy the next block */
#line 3600
#pragma cdir loopcnt=LOOPCNT
#line 3600
#pragma cdir shortloop
#line 3600
    for (i=0; i<ni; i++) {
#line 3600
      /* the normal case: */
#line 3600
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3600
     /* test for range errors (not always needed but do it anyway) */
#line 3600
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3600
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3600
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3600
    }
#line 3600
   /* copy workspace back if necessary */
#line 3600
    if (realign) {
#line 3600
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3600
      xp = (int64 *) *xpp;
#line 3600
    }
#line 3600
   /* update xpp and tp */
#line 3600
    xp += ni;
#line 3600
    tp += ni;
#line 3600
    *xpp = (void*)xp;
#line 3600
  }
#line 3600
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3600

#line 3600
#else   /* not SX */
#line 3600

#line 3600
	char *xp = (char *) *xpp;
#line 3600
	int status = NC_NOERR;
#line 3600

#line 3600
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3600
	{
#line 3600
		int lstatus = ncx_put_longlong_schar(xp, tp, fillp);
#line 3600
		if (status == NC_NOERR) /* report the first encountered error */
#line 3600
			status = lstatus;
#line 3600
	}
#line 3600

#line 3600
	*xpp = (void *)xp;
#line 3600
	return status;
#line 3600
#endif
#line 3600
}
#line 3600

int
#line 3601
ncx_putn_longlong_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3601
{
#line 3601
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3601

#line 3601
 /* basic algorithm is:
#line 3601
  *   - ensure sane alignment of output data
#line 3601
  *   - copy (conversion happens automatically) input data
#line 3601
  *     to output
#line 3601
  *   - update tp to point at next unconverted input, and xpp to point
#line 3601
  *     at next location for converted output
#line 3601
  */
#line 3601
  long i, j, ni;
#line 3601
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3601
  int64 *xp;
#line 3601
  int nrange = 0;         /* number of range errors */
#line 3601
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3601
  long cxp = (long) *((char**)xpp);
#line 3601

#line 3601
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3601
  /* sjl: manually stripmine so we can limit amount of
#line 3601
   * vector work space reserved to LOOPCNT elements. Also
#line 3601
   * makes vectorisation easy */
#line 3601
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3601
    ni=Min(nelems-j,LOOPCNT);
#line 3601
    if (realign) {
#line 3601
      xp = tmp;
#line 3601
    } else {
#line 3601
      xp = (int64 *) *xpp;
#line 3601
    }
#line 3601
   /* copy the next block */
#line 3601
#pragma cdir loopcnt=LOOPCNT
#line 3601
#pragma cdir shortloop
#line 3601
    for (i=0; i<ni; i++) {
#line 3601
      /* the normal case: */
#line 3601
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3601
     /* test for range errors (not always needed but do it anyway) */
#line 3601
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3601
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3601
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3601
    }
#line 3601
   /* copy workspace back if necessary */
#line 3601
    if (realign) {
#line 3601
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3601
      xp = (int64 *) *xpp;
#line 3601
    }
#line 3601
   /* update xpp and tp */
#line 3601
    xp += ni;
#line 3601
    tp += ni;
#line 3601
    *xpp = (void*)xp;
#line 3601
  }
#line 3601
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3601

#line 3601
#else   /* not SX */
#line 3601

#line 3601
	char *xp = (char *) *xpp;
#line 3601
	int status = NC_NOERR;
#line 3601

#line 3601
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3601
	{
#line 3601
		int lstatus = ncx_put_longlong_short(xp, tp, fillp);
#line 3601
		if (status == NC_NOERR) /* report the first encountered error */
#line 3601
			status = lstatus;
#line 3601
	}
#line 3601

#line 3601
	*xpp = (void *)xp;
#line 3601
	return status;
#line 3601
#endif
#line 3601
}
#line 3601

int
#line 3602
ncx_putn_longlong_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3602
{
#line 3602
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3602

#line 3602
 /* basic algorithm is:
#line 3602
  *   - ensure sane alignment of output data
#line 3602
  *   - copy (conversion happens automatically) input data
#line 3602
  *     to output
#line 3602
  *   - update tp to point at next unconverted input, and xpp to point
#line 3602
  *     at next location for converted output
#line 3602
  */
#line 3602
  long i, j, ni;
#line 3602
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3602
  int64 *xp;
#line 3602
  int nrange = 0;         /* number of range errors */
#line 3602
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3602
  long cxp = (long) *((char**)xpp);
#line 3602

#line 3602
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3602
  /* sjl: manually stripmine so we can limit amount of
#line 3602
   * vector work space reserved to LOOPCNT elements. Also
#line 3602
   * makes vectorisation easy */
#line 3602
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3602
    ni=Min(nelems-j,LOOPCNT);
#line 3602
    if (realign) {
#line 3602
      xp = tmp;
#line 3602
    } else {
#line 3602
      xp = (int64 *) *xpp;
#line 3602
    }
#line 3602
   /* copy the next block */
#line 3602
#pragma cdir loopcnt=LOOPCNT
#line 3602
#pragma cdir shortloop
#line 3602
    for (i=0; i<ni; i++) {
#line 3602
      /* the normal case: */
#line 3602
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3602
     /* test for range errors (not always needed but do it anyway) */
#line 3602
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3602
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3602
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3602
    }
#line 3602
   /* copy workspace back if necessary */
#line 3602
    if (realign) {
#line 3602
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3602
      xp = (int64 *) *xpp;
#line 3602
    }
#line 3602
   /* update xpp and tp */
#line 3602
    xp += ni;
#line 3602
    tp += ni;
#line 3602
    *xpp = (void*)xp;
#line 3602
  }
#line 3602
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3602

#line 3602
#else   /* not SX */
#line 3602

#line 3602
	char *xp = (char *) *xpp;
#line 3602
	int status = NC_NOERR;
#line 3602

#line 3602
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3602
	{
#line 3602
		int lstatus = ncx_put_longlong_int(xp, tp, fillp);
#line 3602
		if (status == NC_NOERR) /* report the first encountered error */
#line 3602
			status = lstatus;
#line 3602
	}
#line 3602

#line 3602
	*xpp = (void *)xp;
#line 3602
	return status;
#line 3602
#endif
#line 3602
}
#line 3602

int
#line 3603
ncx_putn_longlong_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3603
{
#line 3603
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3603

#line 3603
 /* basic algorithm is:
#line 3603
  *   - ensure sane alignment of output data
#line 3603
  *   - copy (conversion happens automatically) input data
#line 3603
  *     to output
#line 3603
  *   - update tp to point at next unconverted input, and xpp to point
#line 3603
  *     at next location for converted output
#line 3603
  */
#line 3603
  long i, j, ni;
#line 3603
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3603
  int64 *xp;
#line 3603
  int nrange = 0;         /* number of range errors */
#line 3603
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3603
  long cxp = (long) *((char**)xpp);
#line 3603

#line 3603
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3603
  /* sjl: manually stripmine so we can limit amount of
#line 3603
   * vector work space reserved to LOOPCNT elements. Also
#line 3603
   * makes vectorisation easy */
#line 3603
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3603
    ni=Min(nelems-j,LOOPCNT);
#line 3603
    if (realign) {
#line 3603
      xp = tmp;
#line 3603
    } else {
#line 3603
      xp = (int64 *) *xpp;
#line 3603
    }
#line 3603
   /* copy the next block */
#line 3603
#pragma cdir loopcnt=LOOPCNT
#line 3603
#pragma cdir shortloop
#line 3603
    for (i=0; i<ni; i++) {
#line 3603
      /* the normal case: */
#line 3603
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3603
     /* test for range errors (not always needed but do it anyway) */
#line 3603
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3603
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3603
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3603
    }
#line 3603
   /* copy workspace back if necessary */
#line 3603
    if (realign) {
#line 3603
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3603
      xp = (int64 *) *xpp;
#line 3603
    }
#line 3603
   /* update xpp and tp */
#line 3603
    xp += ni;
#line 3603
    tp += ni;
#line 3603
    *xpp = (void*)xp;
#line 3603
  }
#line 3603
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3603

#line 3603
#else   /* not SX */
#line 3603

#line 3603
	char *xp = (char *) *xpp;
#line 3603
	int status = NC_NOERR;
#line 3603

#line 3603
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3603
	{
#line 3603
		int lstatus = ncx_put_longlong_long(xp, tp, fillp);
#line 3603
		if (status == NC_NOERR) /* report the first encountered error */
#line 3603
			status = lstatus;
#line 3603
	}
#line 3603

#line 3603
	*xpp = (void *)xp;
#line 3603
	return status;
#line 3603
#endif
#line 3603
}
#line 3603

int
#line 3604
ncx_putn_longlong_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3604
{
#line 3604
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3604

#line 3604
 /* basic algorithm is:
#line 3604
  *   - ensure sane alignment of output data
#line 3604
  *   - copy (conversion happens automatically) input data
#line 3604
  *     to output
#line 3604
  *   - update tp to point at next unconverted input, and xpp to point
#line 3604
  *     at next location for converted output
#line 3604
  */
#line 3604
  long i, j, ni;
#line 3604
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3604
  int64 *xp;
#line 3604
  int nrange = 0;         /* number of range errors */
#line 3604
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3604
  long cxp = (long) *((char**)xpp);
#line 3604

#line 3604
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3604
  /* sjl: manually stripmine so we can limit amount of
#line 3604
   * vector work space reserved to LOOPCNT elements. Also
#line 3604
   * makes vectorisation easy */
#line 3604
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3604
    ni=Min(nelems-j,LOOPCNT);
#line 3604
    if (realign) {
#line 3604
      xp = tmp;
#line 3604
    } else {
#line 3604
      xp = (int64 *) *xpp;
#line 3604
    }
#line 3604
   /* copy the next block */
#line 3604
#pragma cdir loopcnt=LOOPCNT
#line 3604
#pragma cdir shortloop
#line 3604
    for (i=0; i<ni; i++) {
#line 3604
      /* the normal case: */
#line 3604
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3604
     /* test for range errors (not always needed but do it anyway) */
#line 3604
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3604
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3604
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3604
    }
#line 3604
   /* copy workspace back if necessary */
#line 3604
    if (realign) {
#line 3604
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3604
      xp = (int64 *) *xpp;
#line 3604
    }
#line 3604
   /* update xpp and tp */
#line 3604
    xp += ni;
#line 3604
    tp += ni;
#line 3604
    *xpp = (void*)xp;
#line 3604
  }
#line 3604
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3604

#line 3604
#else   /* not SX */
#line 3604

#line 3604
	char *xp = (char *) *xpp;
#line 3604
	int status = NC_NOERR;
#line 3604

#line 3604
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3604
	{
#line 3604
		int lstatus = ncx_put_longlong_float(xp, tp, fillp);
#line 3604
		if (status == NC_NOERR) /* report the first encountered error */
#line 3604
			status = lstatus;
#line 3604
	}
#line 3604

#line 3604
	*xpp = (void *)xp;
#line 3604
	return status;
#line 3604
#endif
#line 3604
}
#line 3604

int
#line 3605
ncx_putn_longlong_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3605
{
#line 3605
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3605

#line 3605
 /* basic algorithm is:
#line 3605
  *   - ensure sane alignment of output data
#line 3605
  *   - copy (conversion happens automatically) input data
#line 3605
  *     to output
#line 3605
  *   - update tp to point at next unconverted input, and xpp to point
#line 3605
  *     at next location for converted output
#line 3605
  */
#line 3605
  long i, j, ni;
#line 3605
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3605
  int64 *xp;
#line 3605
  int nrange = 0;         /* number of range errors */
#line 3605
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3605
  long cxp = (long) *((char**)xpp);
#line 3605

#line 3605
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3605
  /* sjl: manually stripmine so we can limit amount of
#line 3605
   * vector work space reserved to LOOPCNT elements. Also
#line 3605
   * makes vectorisation easy */
#line 3605
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3605
    ni=Min(nelems-j,LOOPCNT);
#line 3605
    if (realign) {
#line 3605
      xp = tmp;
#line 3605
    } else {
#line 3605
      xp = (int64 *) *xpp;
#line 3605
    }
#line 3605
   /* copy the next block */
#line 3605
#pragma cdir loopcnt=LOOPCNT
#line 3605
#pragma cdir shortloop
#line 3605
    for (i=0; i<ni; i++) {
#line 3605
      /* the normal case: */
#line 3605
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3605
     /* test for range errors (not always needed but do it anyway) */
#line 3605
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3605
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3605
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3605
    }
#line 3605
   /* copy workspace back if necessary */
#line 3605
    if (realign) {
#line 3605
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3605
      xp = (int64 *) *xpp;
#line 3605
    }
#line 3605
   /* update xpp and tp */
#line 3605
    xp += ni;
#line 3605
    tp += ni;
#line 3605
    *xpp = (void*)xp;
#line 3605
  }
#line 3605
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3605

#line 3605
#else   /* not SX */
#line 3605

#line 3605
	char *xp = (char *) *xpp;
#line 3605
	int status = NC_NOERR;
#line 3605

#line 3605
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3605
	{
#line 3605
		int lstatus = ncx_put_longlong_double(xp, tp, fillp);
#line 3605
		if (status == NC_NOERR) /* report the first encountered error */
#line 3605
			status = lstatus;
#line 3605
	}
#line 3605

#line 3605
	*xpp = (void *)xp;
#line 3605
	return status;
#line 3605
#endif
#line 3605
}
#line 3605

int
#line 3606
ncx_putn_longlong_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3606
{
#line 3606
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3606

#line 3606
 /* basic algorithm is:
#line 3606
  *   - ensure sane alignment of output data
#line 3606
  *   - copy (conversion happens automatically) input data
#line 3606
  *     to output
#line 3606
  *   - update tp to point at next unconverted input, and xpp to point
#line 3606
  *     at next location for converted output
#line 3606
  */
#line 3606
  long i, j, ni;
#line 3606
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3606
  int64 *xp;
#line 3606
  int nrange = 0;         /* number of range errors */
#line 3606
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3606
  long cxp = (long) *((char**)xpp);
#line 3606

#line 3606
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3606
  /* sjl: manually stripmine so we can limit amount of
#line 3606
   * vector work space reserved to LOOPCNT elements. Also
#line 3606
   * makes vectorisation easy */
#line 3606
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3606
    ni=Min(nelems-j,LOOPCNT);
#line 3606
    if (realign) {
#line 3606
      xp = tmp;
#line 3606
    } else {
#line 3606
      xp = (int64 *) *xpp;
#line 3606
    }
#line 3606
   /* copy the next block */
#line 3606
#pragma cdir loopcnt=LOOPCNT
#line 3606
#pragma cdir shortloop
#line 3606
    for (i=0; i<ni; i++) {
#line 3606
      /* the normal case: */
#line 3606
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3606
     /* test for range errors (not always needed but do it anyway) */
#line 3606
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3606
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3606
      nrange += tp[i] > X_INT64_MAX ;
#line 3606
    }
#line 3606
   /* copy workspace back if necessary */
#line 3606
    if (realign) {
#line 3606
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3606
      xp = (int64 *) *xpp;
#line 3606
    }
#line 3606
   /* update xpp and tp */
#line 3606
    xp += ni;
#line 3606
    tp += ni;
#line 3606
    *xpp = (void*)xp;
#line 3606
  }
#line 3606
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3606

#line 3606
#else   /* not SX */
#line 3606

#line 3606
	char *xp = (char *) *xpp;
#line 3606
	int status = NC_NOERR;
#line 3606

#line 3606
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3606
	{
#line 3606
		int lstatus = ncx_put_longlong_uchar(xp, tp, fillp);
#line 3606
		if (status == NC_NOERR) /* report the first encountered error */
#line 3606
			status = lstatus;
#line 3606
	}
#line 3606

#line 3606
	*xpp = (void *)xp;
#line 3606
	return status;
#line 3606
#endif
#line 3606
}
#line 3606

int
#line 3607
ncx_putn_longlong_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3607
{
#line 3607
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3607

#line 3607
 /* basic algorithm is:
#line 3607
  *   - ensure sane alignment of output data
#line 3607
  *   - copy (conversion happens automatically) input data
#line 3607
  *     to output
#line 3607
  *   - update tp to point at next unconverted input, and xpp to point
#line 3607
  *     at next location for converted output
#line 3607
  */
#line 3607
  long i, j, ni;
#line 3607
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3607
  int64 *xp;
#line 3607
  int nrange = 0;         /* number of range errors */
#line 3607
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3607
  long cxp = (long) *((char**)xpp);
#line 3607

#line 3607
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3607
  /* sjl: manually stripmine so we can limit amount of
#line 3607
   * vector work space reserved to LOOPCNT elements. Also
#line 3607
   * makes vectorisation easy */
#line 3607
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3607
    ni=Min(nelems-j,LOOPCNT);
#line 3607
    if (realign) {
#line 3607
      xp = tmp;
#line 3607
    } else {
#line 3607
      xp = (int64 *) *xpp;
#line 3607
    }
#line 3607
   /* copy the next block */
#line 3607
#pragma cdir loopcnt=LOOPCNT
#line 3607
#pragma cdir shortloop
#line 3607
    for (i=0; i<ni; i++) {
#line 3607
      /* the normal case: */
#line 3607
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3607
     /* test for range errors (not always needed but do it anyway) */
#line 3607
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3607
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3607
      nrange += tp[i] > X_INT64_MAX ;
#line 3607
    }
#line 3607
   /* copy workspace back if necessary */
#line 3607
    if (realign) {
#line 3607
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3607
      xp = (int64 *) *xpp;
#line 3607
    }
#line 3607
   /* update xpp and tp */
#line 3607
    xp += ni;
#line 3607
    tp += ni;
#line 3607
    *xpp = (void*)xp;
#line 3607
  }
#line 3607
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3607

#line 3607
#else   /* not SX */
#line 3607

#line 3607
	char *xp = (char *) *xpp;
#line 3607
	int status = NC_NOERR;
#line 3607

#line 3607
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3607
	{
#line 3607
		int lstatus = ncx_put_longlong_ushort(xp, tp, fillp);
#line 3607
		if (status == NC_NOERR) /* report the first encountered error */
#line 3607
			status = lstatus;
#line 3607
	}
#line 3607

#line 3607
	*xpp = (void *)xp;
#line 3607
	return status;
#line 3607
#endif
#line 3607
}
#line 3607

int
#line 3608
ncx_putn_longlong_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3608
{
#line 3608
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3608

#line 3608
 /* basic algorithm is:
#line 3608
  *   - ensure sane alignment of output data
#line 3608
  *   - copy (conversion happens automatically) input data
#line 3608
  *     to output
#line 3608
  *   - update tp to point at next unconverted input, and xpp to point
#line 3608
  *     at next location for converted output
#line 3608
  */
#line 3608
  long i, j, ni;
#line 3608
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3608
  int64 *xp;
#line 3608
  int nrange = 0;         /* number of range errors */
#line 3608
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3608
  long cxp = (long) *((char**)xpp);
#line 3608

#line 3608
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3608
  /* sjl: manually stripmine so we can limit amount of
#line 3608
   * vector work space reserved to LOOPCNT elements. Also
#line 3608
   * makes vectorisation easy */
#line 3608
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3608
    ni=Min(nelems-j,LOOPCNT);
#line 3608
    if (realign) {
#line 3608
      xp = tmp;
#line 3608
    } else {
#line 3608
      xp = (int64 *) *xpp;
#line 3608
    }
#line 3608
   /* copy the next block */
#line 3608
#pragma cdir loopcnt=LOOPCNT
#line 3608
#pragma cdir shortloop
#line 3608
    for (i=0; i<ni; i++) {
#line 3608
      /* the normal case: */
#line 3608
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3608
     /* test for range errors (not always needed but do it anyway) */
#line 3608
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3608
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3608
      nrange += tp[i] > X_INT64_MAX ;
#line 3608
    }
#line 3608
   /* copy workspace back if necessary */
#line 3608
    if (realign) {
#line 3608
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3608
      xp = (int64 *) *xpp;
#line 3608
    }
#line 3608
   /* update xpp and tp */
#line 3608
    xp += ni;
#line 3608
    tp += ni;
#line 3608
    *xpp = (void*)xp;
#line 3608
  }
#line 3608
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3608

#line 3608
#else   /* not SX */
#line 3608

#line 3608
	char *xp = (char *) *xpp;
#line 3608
	int status = NC_NOERR;
#line 3608

#line 3608
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3608
	{
#line 3608
		int lstatus = ncx_put_longlong_uint(xp, tp, fillp);
#line 3608
		if (status == NC_NOERR) /* report the first encountered error */
#line 3608
			status = lstatus;
#line 3608
	}
#line 3608

#line 3608
	*xpp = (void *)xp;
#line 3608
	return status;
#line 3608
#endif
#line 3608
}
#line 3608

int
#line 3609
ncx_putn_longlong_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3609
{
#line 3609
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3609

#line 3609
 /* basic algorithm is:
#line 3609
  *   - ensure sane alignment of output data
#line 3609
  *   - copy (conversion happens automatically) input data
#line 3609
  *     to output
#line 3609
  *   - update tp to point at next unconverted input, and xpp to point
#line 3609
  *     at next location for converted output
#line 3609
  */
#line 3609
  long i, j, ni;
#line 3609
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3609
  int64 *xp;
#line 3609
  int nrange = 0;         /* number of range errors */
#line 3609
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3609
  long cxp = (long) *((char**)xpp);
#line 3609

#line 3609
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3609
  /* sjl: manually stripmine so we can limit amount of
#line 3609
   * vector work space reserved to LOOPCNT elements. Also
#line 3609
   * makes vectorisation easy */
#line 3609
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3609
    ni=Min(nelems-j,LOOPCNT);
#line 3609
    if (realign) {
#line 3609
      xp = tmp;
#line 3609
    } else {
#line 3609
      xp = (int64 *) *xpp;
#line 3609
    }
#line 3609
   /* copy the next block */
#line 3609
#pragma cdir loopcnt=LOOPCNT
#line 3609
#pragma cdir shortloop
#line 3609
    for (i=0; i<ni; i++) {
#line 3609
      /* the normal case: */
#line 3609
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3609
     /* test for range errors (not always needed but do it anyway) */
#line 3609
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3609
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3609
      nrange += tp[i] > X_INT64_MAX ;
#line 3609
    }
#line 3609
   /* copy workspace back if necessary */
#line 3609
    if (realign) {
#line 3609
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3609
      xp = (int64 *) *xpp;
#line 3609
    }
#line 3609
   /* update xpp and tp */
#line 3609
    xp += ni;
#line 3609
    tp += ni;
#line 3609
    *xpp = (void*)xp;
#line 3609
  }
#line 3609
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3609

#line 3609
#else   /* not SX */
#line 3609

#line 3609
	char *xp = (char *) *xpp;
#line 3609
	int status = NC_NOERR;
#line 3609

#line 3609
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3609
	{
#line 3609
		int lstatus = ncx_put_longlong_ulonglong(xp, tp, fillp);
#line 3609
		if (status == NC_NOERR) /* report the first encountered error */
#line 3609
			status = lstatus;
#line 3609
	}
#line 3609

#line 3609
	*xpp = (void *)xp;
#line 3609
	return status;
#line 3609
#endif
#line 3609
}
#line 3609


/* uint64 --------------------------------------------------------------------*/

#if X_SIZEOF_UINT64 == SIZEOF_ULONGLONG
/* optimized version */
int
ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, unsigned long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_UNSIGNED_LONG_LONG);
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_UINT64);
	return NC_NOERR;
}
#else
int
#line 3627
ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3627
{
#line 3627
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3627

#line 3627
 /* basic algorithm is:
#line 3627
  *   - ensure sane alignment of input data
#line 3627
  *   - copy (conversion happens automatically) input data
#line 3627
  *     to output
#line 3627
  *   - update xpp to point at next unconverted input, and tp to point
#line 3627
  *     at next location for converted output
#line 3627
  */
#line 3627
  long i, j, ni;
#line 3627
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3627
  uint64 *xp;
#line 3627
  int nrange = 0;         /* number of range errors */
#line 3627
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3627
  long cxp = (long) *((char**)xpp);
#line 3627

#line 3627
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3627
  /* sjl: manually stripmine so we can limit amount of
#line 3627
   * vector work space reserved to LOOPCNT elements. Also
#line 3627
   * makes vectorisation easy */
#line 3627
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3627
    ni=Min(nelems-j,LOOPCNT);
#line 3627
    if (realign) {
#line 3627
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3627
      xp = tmp;
#line 3627
    } else {
#line 3627
      xp = (uint64 *) *xpp;
#line 3627
    }
#line 3627
   /* copy the next block */
#line 3627
#pragma cdir loopcnt=LOOPCNT
#line 3627
#pragma cdir shortloop
#line 3627
    for (i=0; i<ni; i++) {
#line 3627
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3627
     /* test for range errors (not always needed but do it anyway) */
#line 3627
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3627
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3627
      nrange += xp[i] > ULONGLONG_MAX ;
#line 3627
    }
#line 3627
   /* update xpp and tp */
#line 3627
    if (realign) xp = (uint64 *) *xpp;
#line 3627
    xp += ni;
#line 3627
    tp += ni;
#line 3627
    *xpp = (void*)xp;
#line 3627
  }
#line 3627
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3627

#line 3627
#else   /* not SX */
#line 3627
	const char *xp = (const char *) *xpp;
#line 3627
	int status = NC_NOERR;
#line 3627

#line 3627
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3627
	{
#line 3627
		const int lstatus = ncx_get_ulonglong_ulonglong(xp, tp);
#line 3627
		if (status == NC_NOERR) /* report the first encountered error */
#line 3627
			status = lstatus;
#line 3627
	}
#line 3627

#line 3627
	*xpp = (const void *)xp;
#line 3627
	return status;
#line 3627
#endif
#line 3627
}
#line 3627

#endif
int
#line 3629
ncx_getn_ulonglong_schar(const void **xpp, size_t nelems, schar *tp)
#line 3629
{
#line 3629
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3629

#line 3629
 /* basic algorithm is:
#line 3629
  *   - ensure sane alignment of input data
#line 3629
  *   - copy (conversion happens automatically) input data
#line 3629
  *     to output
#line 3629
  *   - update xpp to point at next unconverted input, and tp to point
#line 3629
  *     at next location for converted output
#line 3629
  */
#line 3629
  long i, j, ni;
#line 3629
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3629
  uint64 *xp;
#line 3629
  int nrange = 0;         /* number of range errors */
#line 3629
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3629
  long cxp = (long) *((char**)xpp);
#line 3629

#line 3629
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3629
  /* sjl: manually stripmine so we can limit amount of
#line 3629
   * vector work space reserved to LOOPCNT elements. Also
#line 3629
   * makes vectorisation easy */
#line 3629
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3629
    ni=Min(nelems-j,LOOPCNT);
#line 3629
    if (realign) {
#line 3629
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3629
      xp = tmp;
#line 3629
    } else {
#line 3629
      xp = (uint64 *) *xpp;
#line 3629
    }
#line 3629
   /* copy the next block */
#line 3629
#pragma cdir loopcnt=LOOPCNT
#line 3629
#pragma cdir shortloop
#line 3629
    for (i=0; i<ni; i++) {
#line 3629
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3629
     /* test for range errors (not always needed but do it anyway) */
#line 3629
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3629
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3629
      nrange += xp[i] > SCHAR_MAX ;
#line 3629
    }
#line 3629
   /* update xpp and tp */
#line 3629
    if (realign) xp = (uint64 *) *xpp;
#line 3629
    xp += ni;
#line 3629
    tp += ni;
#line 3629
    *xpp = (void*)xp;
#line 3629
  }
#line 3629
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3629

#line 3629
#else   /* not SX */
#line 3629
	const char *xp = (const char *) *xpp;
#line 3629
	int status = NC_NOERR;
#line 3629

#line 3629
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3629
	{
#line 3629
		const int lstatus = ncx_get_ulonglong_schar(xp, tp);
#line 3629
		if (status == NC_NOERR) /* report the first encountered error */
#line 3629
			status = lstatus;
#line 3629
	}
#line 3629

#line 3629
	*xpp = (const void *)xp;
#line 3629
	return status;
#line 3629
#endif
#line 3629
}
#line 3629

int
#line 3630
ncx_getn_ulonglong_short(const void **xpp, size_t nelems, short *tp)
#line 3630
{
#line 3630
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3630

#line 3630
 /* basic algorithm is:
#line 3630
  *   - ensure sane alignment of input data
#line 3630
  *   - copy (conversion happens automatically) input data
#line 3630
  *     to output
#line 3630
  *   - update xpp to point at next unconverted input, and tp to point
#line 3630
  *     at next location for converted output
#line 3630
  */
#line 3630
  long i, j, ni;
#line 3630
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3630
  uint64 *xp;
#line 3630
  int nrange = 0;         /* number of range errors */
#line 3630
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3630
  long cxp = (long) *((char**)xpp);
#line 3630

#line 3630
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3630
  /* sjl: manually stripmine so we can limit amount of
#line 3630
   * vector work space reserved to LOOPCNT elements. Also
#line 3630
   * makes vectorisation easy */
#line 3630
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3630
    ni=Min(nelems-j,LOOPCNT);
#line 3630
    if (realign) {
#line 3630
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3630
      xp = tmp;
#line 3630
    } else {
#line 3630
      xp = (uint64 *) *xpp;
#line 3630
    }
#line 3630
   /* copy the next block */
#line 3630
#pragma cdir loopcnt=LOOPCNT
#line 3630
#pragma cdir shortloop
#line 3630
    for (i=0; i<ni; i++) {
#line 3630
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3630
     /* test for range errors (not always needed but do it anyway) */
#line 3630
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3630
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3630
      nrange += xp[i] > SHORT_MAX ;
#line 3630
    }
#line 3630
   /* update xpp and tp */
#line 3630
    if (realign) xp = (uint64 *) *xpp;
#line 3630
    xp += ni;
#line 3630
    tp += ni;
#line 3630
    *xpp = (void*)xp;
#line 3630
  }
#line 3630
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3630

#line 3630
#else   /* not SX */
#line 3630
	const char *xp = (const char *) *xpp;
#line 3630
	int status = NC_NOERR;
#line 3630

#line 3630
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3630
	{
#line 3630
		const int lstatus = ncx_get_ulonglong_short(xp, tp);
#line 3630
		if (status == NC_NOERR) /* report the first encountered error */
#line 3630
			status = lstatus;
#line 3630
	}
#line 3630

#line 3630
	*xpp = (const void *)xp;
#line 3630
	return status;
#line 3630
#endif
#line 3630
}
#line 3630

int
#line 3631
ncx_getn_ulonglong_int(const void **xpp, size_t nelems, int *tp)
#line 3631
{
#line 3631
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3631

#line 3631
 /* basic algorithm is:
#line 3631
  *   - ensure sane alignment of input data
#line 3631
  *   - copy (conversion happens automatically) input data
#line 3631
  *     to output
#line 3631
  *   - update xpp to point at next unconverted input, and tp to point
#line 3631
  *     at next location for converted output
#line 3631
  */
#line 3631
  long i, j, ni;
#line 3631
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3631
  uint64 *xp;
#line 3631
  int nrange = 0;         /* number of range errors */
#line 3631
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3631
  long cxp = (long) *((char**)xpp);
#line 3631

#line 3631
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3631
  /* sjl: manually stripmine so we can limit amount of
#line 3631
   * vector work space reserved to LOOPCNT elements. Also
#line 3631
   * makes vectorisation easy */
#line 3631
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3631
    ni=Min(nelems-j,LOOPCNT);
#line 3631
    if (realign) {
#line 3631
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3631
      xp = tmp;
#line 3631
    } else {
#line 3631
      xp = (uint64 *) *xpp;
#line 3631
    }
#line 3631
   /* copy the next block */
#line 3631
#pragma cdir loopcnt=LOOPCNT
#line 3631
#pragma cdir shortloop
#line 3631
    for (i=0; i<ni; i++) {
#line 3631
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3631
     /* test for range errors (not always needed but do it anyway) */
#line 3631
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3631
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3631
      nrange += xp[i] > INT_MAX ;
#line 3631
    }
#line 3631
   /* update xpp and tp */
#line 3631
    if (realign) xp = (uint64 *) *xpp;
#line 3631
    xp += ni;
#line 3631
    tp += ni;
#line 3631
    *xpp = (void*)xp;
#line 3631
  }
#line 3631
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3631

#line 3631
#else   /* not SX */
#line 3631
	const char *xp = (const char *) *xpp;
#line 3631
	int status = NC_NOERR;
#line 3631

#line 3631
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3631
	{
#line 3631
		const int lstatus = ncx_get_ulonglong_int(xp, tp);
#line 3631
		if (status == NC_NOERR) /* report the first encountered error */
#line 3631
			status = lstatus;
#line 3631
	}
#line 3631

#line 3631
	*xpp = (const void *)xp;
#line 3631
	return status;
#line 3631
#endif
#line 3631
}
#line 3631

int
#line 3632
ncx_getn_ulonglong_long(const void **xpp, size_t nelems, long *tp)
#line 3632
{
#line 3632
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3632

#line 3632
 /* basic algorithm is:
#line 3632
  *   - ensure sane alignment of input data
#line 3632
  *   - copy (conversion happens automatically) input data
#line 3632
  *     to output
#line 3632
  *   - update xpp to point at next unconverted input, and tp to point
#line 3632
  *     at next location for converted output
#line 3632
  */
#line 3632
  long i, j, ni;
#line 3632
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3632
  uint64 *xp;
#line 3632
  int nrange = 0;         /* number of range errors */
#line 3632
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3632
  long cxp = (long) *((char**)xpp);
#line 3632

#line 3632
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3632
  /* sjl: manually stripmine so we can limit amount of
#line 3632
   * vector work space reserved to LOOPCNT elements. Also
#line 3632
   * makes vectorisation easy */
#line 3632
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3632
    ni=Min(nelems-j,LOOPCNT);
#line 3632
    if (realign) {
#line 3632
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3632
      xp = tmp;
#line 3632
    } else {
#line 3632
      xp = (uint64 *) *xpp;
#line 3632
    }
#line 3632
   /* copy the next block */
#line 3632
#pragma cdir loopcnt=LOOPCNT
#line 3632
#pragma cdir shortloop
#line 3632
    for (i=0; i<ni; i++) {
#line 3632
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3632
     /* test for range errors (not always needed but do it anyway) */
#line 3632
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3632
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3632
      nrange += xp[i] > LONG_MAX ;
#line 3632
    }
#line 3632
   /* update xpp and tp */
#line 3632
    if (realign) xp = (uint64 *) *xpp;
#line 3632
    xp += ni;
#line 3632
    tp += ni;
#line 3632
    *xpp = (void*)xp;
#line 3632
  }
#line 3632
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3632

#line 3632
#else   /* not SX */
#line 3632
	const char *xp = (const char *) *xpp;
#line 3632
	int status = NC_NOERR;
#line 3632

#line 3632
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3632
	{
#line 3632
		const int lstatus = ncx_get_ulonglong_long(xp, tp);
#line 3632
		if (status == NC_NOERR) /* report the first encountered error */
#line 3632
			status = lstatus;
#line 3632
	}
#line 3632

#line 3632
	*xpp = (const void *)xp;
#line 3632
	return status;
#line 3632
#endif
#line 3632
}
#line 3632

int
#line 3633
ncx_getn_ulonglong_float(const void **xpp, size_t nelems, float *tp)
#line 3633
{
#line 3633
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3633

#line 3633
 /* basic algorithm is:
#line 3633
  *   - ensure sane alignment of input data
#line 3633
  *   - copy (conversion happens automatically) input data
#line 3633
  *     to output
#line 3633
  *   - update xpp to point at next unconverted input, and tp to point
#line 3633
  *     at next location for converted output
#line 3633
  */
#line 3633
  long i, j, ni;
#line 3633
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3633
  uint64 *xp;
#line 3633
  int nrange = 0;         /* number of range errors */
#line 3633
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3633
  long cxp = (long) *((char**)xpp);
#line 3633

#line 3633
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3633
  /* sjl: manually stripmine so we can limit amount of
#line 3633
   * vector work space reserved to LOOPCNT elements. Also
#line 3633
   * makes vectorisation easy */
#line 3633
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3633
    ni=Min(nelems-j,LOOPCNT);
#line 3633
    if (realign) {
#line 3633
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3633
      xp = tmp;
#line 3633
    } else {
#line 3633
      xp = (uint64 *) *xpp;
#line 3633
    }
#line 3633
   /* copy the next block */
#line 3633
#pragma cdir loopcnt=LOOPCNT
#line 3633
#pragma cdir shortloop
#line 3633
    for (i=0; i<ni; i++) {
#line 3633
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3633
     /* test for range errors (not always needed but do it anyway) */
#line 3633
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3633
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3633
      nrange += xp[i] > FLOAT_MAX ;
#line 3633
    }
#line 3633
   /* update xpp and tp */
#line 3633
    if (realign) xp = (uint64 *) *xpp;
#line 3633
    xp += ni;
#line 3633
    tp += ni;
#line 3633
    *xpp = (void*)xp;
#line 3633
  }
#line 3633
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3633

#line 3633
#else   /* not SX */
#line 3633
	const char *xp = (const char *) *xpp;
#line 3633
	int status = NC_NOERR;
#line 3633

#line 3633
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3633
	{
#line 3633
		const int lstatus = ncx_get_ulonglong_float(xp, tp);
#line 3633
		if (status == NC_NOERR) /* report the first encountered error */
#line 3633
			status = lstatus;
#line 3633
	}
#line 3633

#line 3633
	*xpp = (const void *)xp;
#line 3633
	return status;
#line 3633
#endif
#line 3633
}
#line 3633

int
#line 3634
ncx_getn_ulonglong_double(const void **xpp, size_t nelems, double *tp)
#line 3634
{
#line 3634
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3634

#line 3634
 /* basic algorithm is:
#line 3634
  *   - ensure sane alignment of input data
#line 3634
  *   - copy (conversion happens automatically) input data
#line 3634
  *     to output
#line 3634
  *   - update xpp to point at next unconverted input, and tp to point
#line 3634
  *     at next location for converted output
#line 3634
  */
#line 3634
  long i, j, ni;
#line 3634
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3634
  uint64 *xp;
#line 3634
  int nrange = 0;         /* number of range errors */
#line 3634
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3634
  long cxp = (long) *((char**)xpp);
#line 3634

#line 3634
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3634
  /* sjl: manually stripmine so we can limit amount of
#line 3634
   * vector work space reserved to LOOPCNT elements. Also
#line 3634
   * makes vectorisation easy */
#line 3634
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3634
    ni=Min(nelems-j,LOOPCNT);
#line 3634
    if (realign) {
#line 3634
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3634
      xp = tmp;
#line 3634
    } else {
#line 3634
      xp = (uint64 *) *xpp;
#line 3634
    }
#line 3634
   /* copy the next block */
#line 3634
#pragma cdir loopcnt=LOOPCNT
#line 3634
#pragma cdir shortloop
#line 3634
    for (i=0; i<ni; i++) {
#line 3634
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3634
     /* test for range errors (not always needed but do it anyway) */
#line 3634
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3634
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3634
      nrange += xp[i] > DOUBLE_MAX ;
#line 3634
    }
#line 3634
   /* update xpp and tp */
#line 3634
    if (realign) xp = (uint64 *) *xpp;
#line 3634
    xp += ni;
#line 3634
    tp += ni;
#line 3634
    *xpp = (void*)xp;
#line 3634
  }
#line 3634
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3634

#line 3634
#else   /* not SX */
#line 3634
	const char *xp = (const char *) *xpp;
#line 3634
	int status = NC_NOERR;
#line 3634

#line 3634
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3634
	{
#line 3634
		const int lstatus = ncx_get_ulonglong_double(xp, tp);
#line 3634
		if (status == NC_NOERR) /* report the first encountered error */
#line 3634
			status = lstatus;
#line 3634
	}
#line 3634

#line 3634
	*xpp = (const void *)xp;
#line 3634
	return status;
#line 3634
#endif
#line 3634
}
#line 3634

int
#line 3635
ncx_getn_ulonglong_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3635
{
#line 3635
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3635

#line 3635
 /* basic algorithm is:
#line 3635
  *   - ensure sane alignment of input data
#line 3635
  *   - copy (conversion happens automatically) input data
#line 3635
  *     to output
#line 3635
  *   - update xpp to point at next unconverted input, and tp to point
#line 3635
  *     at next location for converted output
#line 3635
  */
#line 3635
  long i, j, ni;
#line 3635
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3635
  uint64 *xp;
#line 3635
  int nrange = 0;         /* number of range errors */
#line 3635
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3635
  long cxp = (long) *((char**)xpp);
#line 3635

#line 3635
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3635
  /* sjl: manually stripmine so we can limit amount of
#line 3635
   * vector work space reserved to LOOPCNT elements. Also
#line 3635
   * makes vectorisation easy */
#line 3635
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3635
    ni=Min(nelems-j,LOOPCNT);
#line 3635
    if (realign) {
#line 3635
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3635
      xp = tmp;
#line 3635
    } else {
#line 3635
      xp = (uint64 *) *xpp;
#line 3635
    }
#line 3635
   /* copy the next block */
#line 3635
#pragma cdir loopcnt=LOOPCNT
#line 3635
#pragma cdir shortloop
#line 3635
    for (i=0; i<ni; i++) {
#line 3635
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3635
     /* test for range errors (not always needed but do it anyway) */
#line 3635
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3635
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3635
      nrange += xp[i] > LONGLONG_MAX ;
#line 3635
    }
#line 3635
   /* update xpp and tp */
#line 3635
    if (realign) xp = (uint64 *) *xpp;
#line 3635
    xp += ni;
#line 3635
    tp += ni;
#line 3635
    *xpp = (void*)xp;
#line 3635
  }
#line 3635
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3635

#line 3635
#else   /* not SX */
#line 3635
	const char *xp = (const char *) *xpp;
#line 3635
	int status = NC_NOERR;
#line 3635

#line 3635
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3635
	{
#line 3635
		const int lstatus = ncx_get_ulonglong_longlong(xp, tp);
#line 3635
		if (status == NC_NOERR) /* report the first encountered error */
#line 3635
			status = lstatus;
#line 3635
	}
#line 3635

#line 3635
	*xpp = (const void *)xp;
#line 3635
	return status;
#line 3635
#endif
#line 3635
}
#line 3635

int
#line 3636
ncx_getn_ulonglong_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3636
{
#line 3636
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3636

#line 3636
 /* basic algorithm is:
#line 3636
  *   - ensure sane alignment of input data
#line 3636
  *   - copy (conversion happens automatically) input data
#line 3636
  *     to output
#line 3636
  *   - update xpp to point at next unconverted input, and tp to point
#line 3636
  *     at next location for converted output
#line 3636
  */
#line 3636
  long i, j, ni;
#line 3636
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3636
  uint64 *xp;
#line 3636
  int nrange = 0;         /* number of range errors */
#line 3636
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3636
  long cxp = (long) *((char**)xpp);
#line 3636

#line 3636
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3636
  /* sjl: manually stripmine so we can limit amount of
#line 3636
   * vector work space reserved to LOOPCNT elements. Also
#line 3636
   * makes vectorisation easy */
#line 3636
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3636
    ni=Min(nelems-j,LOOPCNT);
#line 3636
    if (realign) {
#line 3636
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3636
      xp = tmp;
#line 3636
    } else {
#line 3636
      xp = (uint64 *) *xpp;
#line 3636
    }
#line 3636
   /* copy the next block */
#line 3636
#pragma cdir loopcnt=LOOPCNT
#line 3636
#pragma cdir shortloop
#line 3636
    for (i=0; i<ni; i++) {
#line 3636
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3636
     /* test for range errors (not always needed but do it anyway) */
#line 3636
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3636
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3636
      nrange += xp[i] > UCHAR_MAX ;
#line 3636
    }
#line 3636
   /* update xpp and tp */
#line 3636
    if (realign) xp = (uint64 *) *xpp;
#line 3636
    xp += ni;
#line 3636
    tp += ni;
#line 3636
    *xpp = (void*)xp;
#line 3636
  }
#line 3636
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3636

#line 3636
#else   /* not SX */
#line 3636
	const char *xp = (const char *) *xpp;
#line 3636
	int status = NC_NOERR;
#line 3636

#line 3636
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3636
	{
#line 3636
		const int lstatus = ncx_get_ulonglong_uchar(xp, tp);
#line 3636
		if (status == NC_NOERR) /* report the first encountered error */
#line 3636
			status = lstatus;
#line 3636
	}
#line 3636

#line 3636
	*xpp = (const void *)xp;
#line 3636
	return status;
#line 3636
#endif
#line 3636
}
#line 3636

int
#line 3637
ncx_getn_ulonglong_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3637
{
#line 3637
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3637

#line 3637
 /* basic algorithm is:
#line 3637
  *   - ensure sane alignment of input data
#line 3637
  *   - copy (conversion happens automatically) input data
#line 3637
  *     to output
#line 3637
  *   - update xpp to point at next unconverted input, and tp to point
#line 3637
  *     at next location for converted output
#line 3637
  */
#line 3637
  long i, j, ni;
#line 3637
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3637
  uint64 *xp;
#line 3637
  int nrange = 0;         /* number of range errors */
#line 3637
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3637
  long cxp = (long) *((char**)xpp);
#line 3637

#line 3637
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3637
  /* sjl: manually stripmine so we can limit amount of
#line 3637
   * vector work space reserved to LOOPCNT elements. Also
#line 3637
   * makes vectorisation easy */
#line 3637
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3637
    ni=Min(nelems-j,LOOPCNT);
#line 3637
    if (realign) {
#line 3637
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3637
      xp = tmp;
#line 3637
    } else {
#line 3637
      xp = (uint64 *) *xpp;
#line 3637
    }
#line 3637
   /* copy the next block */
#line 3637
#pragma cdir loopcnt=LOOPCNT
#line 3637
#pragma cdir shortloop
#line 3637
    for (i=0; i<ni; i++) {
#line 3637
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3637
     /* test for range errors (not always needed but do it anyway) */
#line 3637
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3637
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3637
      nrange += xp[i] > USHORT_MAX ;
#line 3637
    }
#line 3637
   /* update xpp and tp */
#line 3637
    if (realign) xp = (uint64 *) *xpp;
#line 3637
    xp += ni;
#line 3637
    tp += ni;
#line 3637
    *xpp = (void*)xp;
#line 3637
  }
#line 3637
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3637

#line 3637
#else   /* not SX */
#line 3637
	const char *xp = (const char *) *xpp;
#line 3637
	int status = NC_NOERR;
#line 3637

#line 3637
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3637
	{
#line 3637
		const int lstatus = ncx_get_ulonglong_ushort(xp, tp);
#line 3637
		if (status == NC_NOERR) /* report the first encountered error */
#line 3637
			status = lstatus;
#line 3637
	}
#line 3637

#line 3637
	*xpp = (const void *)xp;
#line 3637
	return status;
#line 3637
#endif
#line 3637
}
#line 3637

int
#line 3638
ncx_getn_ulonglong_uint(const void **xpp, size_t nelems, uint *tp)
#line 3638
{
#line 3638
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3638

#line 3638
 /* basic algorithm is:
#line 3638
  *   - ensure sane alignment of input data
#line 3638
  *   - copy (conversion happens automatically) input data
#line 3638
  *     to output
#line 3638
  *   - update xpp to point at next unconverted input, and tp to point
#line 3638
  *     at next location for converted output
#line 3638
  */
#line 3638
  long i, j, ni;
#line 3638
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3638
  uint64 *xp;
#line 3638
  int nrange = 0;         /* number of range errors */
#line 3638
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3638
  long cxp = (long) *((char**)xpp);
#line 3638

#line 3638
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3638
  /* sjl: manually stripmine so we can limit amount of
#line 3638
   * vector work space reserved to LOOPCNT elements. Also
#line 3638
   * makes vectorisation easy */
#line 3638
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3638
    ni=Min(nelems-j,LOOPCNT);
#line 3638
    if (realign) {
#line 3638
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3638
      xp = tmp;
#line 3638
    } else {
#line 3638
      xp = (uint64 *) *xpp;
#line 3638
    }
#line 3638
   /* copy the next block */
#line 3638
#pragma cdir loopcnt=LOOPCNT
#line 3638
#pragma cdir shortloop
#line 3638
    for (i=0; i<ni; i++) {
#line 3638
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3638
     /* test for range errors (not always needed but do it anyway) */
#line 3638
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3638
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3638
      nrange += xp[i] > UINT_MAX ;
#line 3638
    }
#line 3638
   /* update xpp and tp */
#line 3638
    if (realign) xp = (uint64 *) *xpp;
#line 3638
    xp += ni;
#line 3638
    tp += ni;
#line 3638
    *xpp = (void*)xp;
#line 3638
  }
#line 3638
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3638

#line 3638
#else   /* not SX */
#line 3638
	const char *xp = (const char *) *xpp;
#line 3638
	int status = NC_NOERR;
#line 3638

#line 3638
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3638
	{
#line 3638
		const int lstatus = ncx_get_ulonglong_uint(xp, tp);
#line 3638
		if (status == NC_NOERR) /* report the first encountered error */
#line 3638
			status = lstatus;
#line 3638
	}
#line 3638

#line 3638
	*xpp = (const void *)xp;
#line 3638
	return status;
#line 3638
#endif
#line 3638
}
#line 3638


#if X_SIZEOF_UINT64 == SIZEOF_ULONGLONG
/* optimized version */
int
ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const unsigned long long *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_UINT64);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_UINT64);
	return NC_NOERR;
}
#else
int
#line 3654
ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3654
{
#line 3654
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3654

#line 3654
 /* basic algorithm is:
#line 3654
  *   - ensure sane alignment of output data
#line 3654
  *   - copy (conversion happens automatically) input data
#line 3654
  *     to output
#line 3654
  *   - update tp to point at next unconverted input, and xpp to point
#line 3654
  *     at next location for converted output
#line 3654
  */
#line 3654
  long i, j, ni;
#line 3654
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3654
  uint64 *xp;
#line 3654
  int nrange = 0;         /* number of range errors */
#line 3654
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3654
  long cxp = (long) *((char**)xpp);
#line 3654

#line 3654
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3654
  /* sjl: manually stripmine so we can limit amount of
#line 3654
   * vector work space reserved to LOOPCNT elements. Also
#line 3654
   * makes vectorisation easy */
#line 3654
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3654
    ni=Min(nelems-j,LOOPCNT);
#line 3654
    if (realign) {
#line 3654
      xp = tmp;
#line 3654
    } else {
#line 3654
      xp = (uint64 *) *xpp;
#line 3654
    }
#line 3654
   /* copy the next block */
#line 3654
#pragma cdir loopcnt=LOOPCNT
#line 3654
#pragma cdir shortloop
#line 3654
    for (i=0; i<ni; i++) {
#line 3654
      /* the normal case: */
#line 3654
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3654
     /* test for range errors (not always needed but do it anyway) */
#line 3654
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3654
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3654
      nrange += tp[i] > X_UINT64_MAX ;
#line 3654
    }
#line 3654
   /* copy workspace back if necessary */
#line 3654
    if (realign) {
#line 3654
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3654
      xp = (uint64 *) *xpp;
#line 3654
    }
#line 3654
   /* update xpp and tp */
#line 3654
    xp += ni;
#line 3654
    tp += ni;
#line 3654
    *xpp = (void*)xp;
#line 3654
  }
#line 3654
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3654

#line 3654
#else   /* not SX */
#line 3654

#line 3654
	char *xp = (char *) *xpp;
#line 3654
	int status = NC_NOERR;
#line 3654

#line 3654
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3654
	{
#line 3654
		int lstatus = ncx_put_ulonglong_ulonglong(xp, tp, fillp);
#line 3654
		if (status == NC_NOERR) /* report the first encountered error */
#line 3654
			status = lstatus;
#line 3654
	}
#line 3654

#line 3654
	*xpp = (void *)xp;
#line 3654
	return status;
#line 3654
#endif
#line 3654
}
#line 3654

#endif
int
#line 3656
ncx_putn_ulonglong_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3656
{
#line 3656
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3656

#line 3656
 /* basic algorithm is:
#line 3656
  *   - ensure sane alignment of output data
#line 3656
  *   - copy (conversion happens automatically) input data
#line 3656
  *     to output
#line 3656
  *   - update tp to point at next unconverted input, and xpp to point
#line 3656
  *     at next location for converted output
#line 3656
  */
#line 3656
  long i, j, ni;
#line 3656
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3656
  uint64 *xp;
#line 3656
  int nrange = 0;         /* number of range errors */
#line 3656
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3656
  long cxp = (long) *((char**)xpp);
#line 3656

#line 3656
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3656
  /* sjl: manually stripmine so we can limit amount of
#line 3656
   * vector work space reserved to LOOPCNT elements. Also
#line 3656
   * makes vectorisation easy */
#line 3656
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3656
    ni=Min(nelems-j,LOOPCNT);
#line 3656
    if (realign) {
#line 3656
      xp = tmp;
#line 3656
    } else {
#line 3656
      xp = (uint64 *) *xpp;
#line 3656
    }
#line 3656
   /* copy the next block */
#line 3656
#pragma cdir loopcnt=LOOPCNT
#line 3656
#pragma cdir shortloop
#line 3656
    for (i=0; i<ni; i++) {
#line 3656
      /* the normal case: */
#line 3656
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3656
     /* test for range errors (not always needed but do it anyway) */
#line 3656
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3656
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3656
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3656
    }
#line 3656
   /* copy workspace back if necessary */
#line 3656
    if (realign) {
#line 3656
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3656
      xp = (uint64 *) *xpp;
#line 3656
    }
#line 3656
   /* update xpp and tp */
#line 3656
    xp += ni;
#line 3656
    tp += ni;
#line 3656
    *xpp = (void*)xp;
#line 3656
  }
#line 3656
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3656

#line 3656
#else   /* not SX */
#line 3656

#line 3656
	char *xp = (char *) *xpp;
#line 3656
	int status = NC_NOERR;
#line 3656

#line 3656
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3656
	{
#line 3656
		int lstatus = ncx_put_ulonglong_schar(xp, tp, fillp);
#line 3656
		if (status == NC_NOERR) /* report the first encountered error */
#line 3656
			status = lstatus;
#line 3656
	}
#line 3656

#line 3656
	*xpp = (void *)xp;
#line 3656
	return status;
#line 3656
#endif
#line 3656
}
#line 3656

int
#line 3657
ncx_putn_ulonglong_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3657
{
#line 3657
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3657

#line 3657
 /* basic algorithm is:
#line 3657
  *   - ensure sane alignment of output data
#line 3657
  *   - copy (conversion happens automatically) input data
#line 3657
  *     to output
#line 3657
  *   - update tp to point at next unconverted input, and xpp to point
#line 3657
  *     at next location for converted output
#line 3657
  */
#line 3657
  long i, j, ni;
#line 3657
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3657
  uint64 *xp;
#line 3657
  int nrange = 0;         /* number of range errors */
#line 3657
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3657
  long cxp = (long) *((char**)xpp);
#line 3657

#line 3657
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3657
  /* sjl: manually stripmine so we can limit amount of
#line 3657
   * vector work space reserved to LOOPCNT elements. Also
#line 3657
   * makes vectorisation easy */
#line 3657
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3657
    ni=Min(nelems-j,LOOPCNT);
#line 3657
    if (realign) {
#line 3657
      xp = tmp;
#line 3657
    } else {
#line 3657
      xp = (uint64 *) *xpp;
#line 3657
    }
#line 3657
   /* copy the next block */
#line 3657
#pragma cdir loopcnt=LOOPCNT
#line 3657
#pragma cdir shortloop
#line 3657
    for (i=0; i<ni; i++) {
#line 3657
      /* the normal case: */
#line 3657
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3657
     /* test for range errors (not always needed but do it anyway) */
#line 3657
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3657
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3657
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3657
    }
#line 3657
   /* copy workspace back if necessary */
#line 3657
    if (realign) {
#line 3657
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3657
      xp = (uint64 *) *xpp;
#line 3657
    }
#line 3657
   /* update xpp and tp */
#line 3657
    xp += ni;
#line 3657
    tp += ni;
#line 3657
    *xpp = (void*)xp;
#line 3657
  }
#line 3657
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3657

#line 3657
#else   /* not SX */
#line 3657

#line 3657
	char *xp = (char *) *xpp;
#line 3657
	int status = NC_NOERR;
#line 3657

#line 3657
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3657
	{
#line 3657
		int lstatus = ncx_put_ulonglong_short(xp, tp, fillp);
#line 3657
		if (status == NC_NOERR) /* report the first encountered error */
#line 3657
			status = lstatus;
#line 3657
	}
#line 3657

#line 3657
	*xpp = (void *)xp;
#line 3657
	return status;
#line 3657
#endif
#line 3657
}
#line 3657

int
#line 3658
ncx_putn_ulonglong_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3658
{
#line 3658
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3658

#line 3658
 /* basic algorithm is:
#line 3658
  *   - ensure sane alignment of output data
#line 3658
  *   - copy (conversion happens automatically) input data
#line 3658
  *     to output
#line 3658
  *   - update tp to point at next unconverted input, and xpp to point
#line 3658
  *     at next location for converted output
#line 3658
  */
#line 3658
  long i, j, ni;
#line 3658
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3658
  uint64 *xp;
#line 3658
  int nrange = 0;         /* number of range errors */
#line 3658
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3658
  long cxp = (long) *((char**)xpp);
#line 3658

#line 3658
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3658
  /* sjl: manually stripmine so we can limit amount of
#line 3658
   * vector work space reserved to LOOPCNT elements. Also
#line 3658
   * makes vectorisation easy */
#line 3658
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3658
    ni=Min(nelems-j,LOOPCNT);
#line 3658
    if (realign) {
#line 3658
      xp = tmp;
#line 3658
    } else {
#line 3658
      xp = (uint64 *) *xpp;
#line 3658
    }
#line 3658
   /* copy the next block */
#line 3658
#pragma cdir loopcnt=LOOPCNT
#line 3658
#pragma cdir shortloop
#line 3658
    for (i=0; i<ni; i++) {
#line 3658
      /* the normal case: */
#line 3658
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3658
     /* test for range errors (not always needed but do it anyway) */
#line 3658
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3658
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3658
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3658
    }
#line 3658
   /* copy workspace back if necessary */
#line 3658
    if (realign) {
#line 3658
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3658
      xp = (uint64 *) *xpp;
#line 3658
    }
#line 3658
   /* update xpp and tp */
#line 3658
    xp += ni;
#line 3658
    tp += ni;
#line 3658
    *xpp = (void*)xp;
#line 3658
  }
#line 3658
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3658

#line 3658
#else   /* not SX */
#line 3658

#line 3658
	char *xp = (char *) *xpp;
#line 3658
	int status = NC_NOERR;
#line 3658

#line 3658
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3658
	{
#line 3658
		int lstatus = ncx_put_ulonglong_int(xp, tp, fillp);
#line 3658
		if (status == NC_NOERR) /* report the first encountered error */
#line 3658
			status = lstatus;
#line 3658
	}
#line 3658

#line 3658
	*xpp = (void *)xp;
#line 3658
	return status;
#line 3658
#endif
#line 3658
}
#line 3658

int
#line 3659
ncx_putn_ulonglong_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3659
{
#line 3659
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3659

#line 3659
 /* basic algorithm is:
#line 3659
  *   - ensure sane alignment of output data
#line 3659
  *   - copy (conversion happens automatically) input data
#line 3659
  *     to output
#line 3659
  *   - update tp to point at next unconverted input, and xpp to point
#line 3659
  *     at next location for converted output
#line 3659
  */
#line 3659
  long i, j, ni;
#line 3659
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3659
  uint64 *xp;
#line 3659
  int nrange = 0;         /* number of range errors */
#line 3659
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3659
  long cxp = (long) *((char**)xpp);
#line 3659

#line 3659
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3659
  /* sjl: manually stripmine so we can limit amount of
#line 3659
   * vector work space reserved to LOOPCNT elements. Also
#line 3659
   * makes vectorisation easy */
#line 3659
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3659
    ni=Min(nelems-j,LOOPCNT);
#line 3659
    if (realign) {
#line 3659
      xp = tmp;
#line 3659
    } else {
#line 3659
      xp = (uint64 *) *xpp;
#line 3659
    }
#line 3659
   /* copy the next block */
#line 3659
#pragma cdir loopcnt=LOOPCNT
#line 3659
#pragma cdir shortloop
#line 3659
    for (i=0; i<ni; i++) {
#line 3659
      /* the normal case: */
#line 3659
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3659
     /* test for range errors (not always needed but do it anyway) */
#line 3659
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3659
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3659
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3659
    }
#line 3659
   /* copy workspace back if necessary */
#line 3659
    if (realign) {
#line 3659
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3659
      xp = (uint64 *) *xpp;
#line 3659
    }
#line 3659
   /* update xpp and tp */
#line 3659
    xp += ni;
#line 3659
    tp += ni;
#line 3659
    *xpp = (void*)xp;
#line 3659
  }
#line 3659
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3659

#line 3659
#else   /* not SX */
#line 3659

#line 3659
	char *xp = (char *) *xpp;
#line 3659
	int status = NC_NOERR;
#line 3659

#line 3659
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3659
	{
#line 3659
		int lstatus = ncx_put_ulonglong_long(xp, tp, fillp);
#line 3659
		if (status == NC_NOERR) /* report the first encountered error */
#line 3659
			status = lstatus;
#line 3659
	}
#line 3659

#line 3659
	*xpp = (void *)xp;
#line 3659
	return status;
#line 3659
#endif
#line 3659
}
#line 3659

int
#line 3660
ncx_putn_ulonglong_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3660
{
#line 3660
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3660

#line 3660
 /* basic algorithm is:
#line 3660
  *   - ensure sane alignment of output data
#line 3660
  *   - copy (conversion happens automatically) input data
#line 3660
  *     to output
#line 3660
  *   - update tp to point at next unconverted input, and xpp to point
#line 3660
  *     at next location for converted output
#line 3660
  */
#line 3660
  long i, j, ni;
#line 3660
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3660
  uint64 *xp;
#line 3660
  int nrange = 0;         /* number of range errors */
#line 3660
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3660
  long cxp = (long) *((char**)xpp);
#line 3660

#line 3660
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3660
  /* sjl: manually stripmine so we can limit amount of
#line 3660
   * vector work space reserved to LOOPCNT elements. Also
#line 3660
   * makes vectorisation easy */
#line 3660
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3660
    ni=Min(nelems-j,LOOPCNT);
#line 3660
    if (realign) {
#line 3660
      xp = tmp;
#line 3660
    } else {
#line 3660
      xp = (uint64 *) *xpp;
#line 3660
    }
#line 3660
   /* copy the next block */
#line 3660
#pragma cdir loopcnt=LOOPCNT
#line 3660
#pragma cdir shortloop
#line 3660
    for (i=0; i<ni; i++) {
#line 3660
      /* the normal case: */
#line 3660
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3660
     /* test for range errors (not always needed but do it anyway) */
#line 3660
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3660
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3660
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3660
    }
#line 3660
   /* copy workspace back if necessary */
#line 3660
    if (realign) {
#line 3660
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3660
      xp = (uint64 *) *xpp;
#line 3660
    }
#line 3660
   /* update xpp and tp */
#line 3660
    xp += ni;
#line 3660
    tp += ni;
#line 3660
    *xpp = (void*)xp;
#line 3660
  }
#line 3660
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3660

#line 3660
#else   /* not SX */
#line 3660

#line 3660
	char *xp = (char *) *xpp;
#line 3660
	int status = NC_NOERR;
#line 3660

#line 3660
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3660
	{
#line 3660
		int lstatus = ncx_put_ulonglong_float(xp, tp, fillp);
#line 3660
		if (status == NC_NOERR) /* report the first encountered error */
#line 3660
			status = lstatus;
#line 3660
	}
#line 3660

#line 3660
	*xpp = (void *)xp;
#line 3660
	return status;
#line 3660
#endif
#line 3660
}
#line 3660

int
#line 3661
ncx_putn_ulonglong_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3661
{
#line 3661
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3661

#line 3661
 /* basic algorithm is:
#line 3661
  *   - ensure sane alignment of output data
#line 3661
  *   - copy (conversion happens automatically) input data
#line 3661
  *     to output
#line 3661
  *   - update tp to point at next unconverted input, and xpp to point
#line 3661
  *     at next location for converted output
#line 3661
  */
#line 3661
  long i, j, ni;
#line 3661
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3661
  uint64 *xp;
#line 3661
  int nrange = 0;         /* number of range errors */
#line 3661
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3661
  long cxp = (long) *((char**)xpp);
#line 3661

#line 3661
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3661
  /* sjl: manually stripmine so we can limit amount of
#line 3661
   * vector work space reserved to LOOPCNT elements. Also
#line 3661
   * makes vectorisation easy */
#line 3661
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3661
    ni=Min(nelems-j,LOOPCNT);
#line 3661
    if (realign) {
#line 3661
      xp = tmp;
#line 3661
    } else {
#line 3661
      xp = (uint64 *) *xpp;
#line 3661
    }
#line 3661
   /* copy the next block */
#line 3661
#pragma cdir loopcnt=LOOPCNT
#line 3661
#pragma cdir shortloop
#line 3661
    for (i=0; i<ni; i++) {
#line 3661
      /* the normal case: */
#line 3661
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3661
     /* test for range errors (not always needed but do it anyway) */
#line 3661
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3661
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3661
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3661
    }
#line 3661
   /* copy workspace back if necessary */
#line 3661
    if (realign) {
#line 3661
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3661
      xp = (uint64 *) *xpp;
#line 3661
    }
#line 3661
   /* update xpp and tp */
#line 3661
    xp += ni;
#line 3661
    tp += ni;
#line 3661
    *xpp = (void*)xp;
#line 3661
  }
#line 3661
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3661

#line 3661
#else   /* not SX */
#line 3661

#line 3661
	char *xp = (char *) *xpp;
#line 3661
	int status = NC_NOERR;
#line 3661

#line 3661
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3661
	{
#line 3661
		int lstatus = ncx_put_ulonglong_double(xp, tp, fillp);
#line 3661
		if (status == NC_NOERR) /* report the first encountered error */
#line 3661
			status = lstatus;
#line 3661
	}
#line 3661

#line 3661
	*xpp = (void *)xp;
#line 3661
	return status;
#line 3661
#endif
#line 3661
}
#line 3661

int
#line 3662
ncx_putn_ulonglong_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3662
{
#line 3662
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3662

#line 3662
 /* basic algorithm is:
#line 3662
  *   - ensure sane alignment of output data
#line 3662
  *   - copy (conversion happens automatically) input data
#line 3662
  *     to output
#line 3662
  *   - update tp to point at next unconverted input, and xpp to point
#line 3662
  *     at next location for converted output
#line 3662
  */
#line 3662
  long i, j, ni;
#line 3662
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3662
  uint64 *xp;
#line 3662
  int nrange = 0;         /* number of range errors */
#line 3662
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3662
  long cxp = (long) *((char**)xpp);
#line 3662

#line 3662
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3662
  /* sjl: manually stripmine so we can limit amount of
#line 3662
   * vector work space reserved to LOOPCNT elements. Also
#line 3662
   * makes vectorisation easy */
#line 3662
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3662
    ni=Min(nelems-j,LOOPCNT);
#line 3662
    if (realign) {
#line 3662
      xp = tmp;
#line 3662
    } else {
#line 3662
      xp = (uint64 *) *xpp;
#line 3662
    }
#line 3662
   /* copy the next block */
#line 3662
#pragma cdir loopcnt=LOOPCNT
#line 3662
#pragma cdir shortloop
#line 3662
    for (i=0; i<ni; i++) {
#line 3662
      /* the normal case: */
#line 3662
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3662
     /* test for range errors (not always needed but do it anyway) */
#line 3662
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3662
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3662
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3662
    }
#line 3662
   /* copy workspace back if necessary */
#line 3662
    if (realign) {
#line 3662
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3662
      xp = (uint64 *) *xpp;
#line 3662
    }
#line 3662
   /* update xpp and tp */
#line 3662
    xp += ni;
#line 3662
    tp += ni;
#line 3662
    *xpp = (void*)xp;
#line 3662
  }
#line 3662
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3662

#line 3662
#else   /* not SX */
#line 3662

#line 3662
	char *xp = (char *) *xpp;
#line 3662
	int status = NC_NOERR;
#line 3662

#line 3662
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3662
	{
#line 3662
		int lstatus = ncx_put_ulonglong_longlong(xp, tp, fillp);
#line 3662
		if (status == NC_NOERR) /* report the first encountered error */
#line 3662
			status = lstatus;
#line 3662
	}
#line 3662

#line 3662
	*xpp = (void *)xp;
#line 3662
	return status;
#line 3662
#endif
#line 3662
}
#line 3662

int
#line 3663
ncx_putn_ulonglong_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3663
{
#line 3663
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3663

#line 3663
 /* basic algorithm is:
#line 3663
  *   - ensure sane alignment of output data
#line 3663
  *   - copy (conversion happens automatically) input data
#line 3663
  *     to output
#line 3663
  *   - update tp to point at next unconverted input, and xpp to point
#line 3663
  *     at next location for converted output
#line 3663
  */
#line 3663
  long i, j, ni;
#line 3663
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3663
  uint64 *xp;
#line 3663
  int nrange = 0;         /* number of range errors */
#line 3663
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3663
  long cxp = (long) *((char**)xpp);
#line 3663

#line 3663
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3663
  /* sjl: manually stripmine so we can limit amount of
#line 3663
   * vector work space reserved to LOOPCNT elements. Also
#line 3663
   * makes vectorisation easy */
#line 3663
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3663
    ni=Min(nelems-j,LOOPCNT);
#line 3663
    if (realign) {
#line 3663
      xp = tmp;
#line 3663
    } else {
#line 3663
      xp = (uint64 *) *xpp;
#line 3663
    }
#line 3663
   /* copy the next block */
#line 3663
#pragma cdir loopcnt=LOOPCNT
#line 3663
#pragma cdir shortloop
#line 3663
    for (i=0; i<ni; i++) {
#line 3663
      /* the normal case: */
#line 3663
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3663
     /* test for range errors (not always needed but do it anyway) */
#line 3663
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3663
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3663
      nrange += tp[i] > X_UINT64_MAX ;
#line 3663
    }
#line 3663
   /* copy workspace back if necessary */
#line 3663
    if (realign) {
#line 3663
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3663
      xp = (uint64 *) *xpp;
#line 3663
    }
#line 3663
   /* update xpp and tp */
#line 3663
    xp += ni;
#line 3663
    tp += ni;
#line 3663
    *xpp = (void*)xp;
#line 3663
  }
#line 3663
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3663

#line 3663
#else   /* not SX */
#line 3663

#line 3663
	char *xp = (char *) *xpp;
#line 3663
	int status = NC_NOERR;
#line 3663

#line 3663
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3663
	{
#line 3663
		int lstatus = ncx_put_ulonglong_uchar(xp, tp, fillp);
#line 3663
		if (status == NC_NOERR) /* report the first encountered error */
#line 3663
			status = lstatus;
#line 3663
	}
#line 3663

#line 3663
	*xpp = (void *)xp;
#line 3663
	return status;
#line 3663
#endif
#line 3663
}
#line 3663

int
#line 3664
ncx_putn_ulonglong_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3664
{
#line 3664
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3664

#line 3664
 /* basic algorithm is:
#line 3664
  *   - ensure sane alignment of output data
#line 3664
  *   - copy (conversion happens automatically) input data
#line 3664
  *     to output
#line 3664
  *   - update tp to point at next unconverted input, and xpp to point
#line 3664
  *     at next location for converted output
#line 3664
  */
#line 3664
  long i, j, ni;
#line 3664
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3664
  uint64 *xp;
#line 3664
  int nrange = 0;         /* number of range errors */
#line 3664
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3664
  long cxp = (long) *((char**)xpp);
#line 3664

#line 3664
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3664
  /* sjl: manually stripmine so we can limit amount of
#line 3664
   * vector work space reserved to LOOPCNT elements. Also
#line 3664
   * makes vectorisation easy */
#line 3664
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3664
    ni=Min(nelems-j,LOOPCNT);
#line 3664
    if (realign) {
#line 3664
      xp = tmp;
#line 3664
    } else {
#line 3664
      xp = (uint64 *) *xpp;
#line 3664
    }
#line 3664
   /* copy the next block */
#line 3664
#pragma cdir loopcnt=LOOPCNT
#line 3664
#pragma cdir shortloop
#line 3664
    for (i=0; i<ni; i++) {
#line 3664
      /* the normal case: */
#line 3664
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3664
     /* test for range errors (not always needed but do it anyway) */
#line 3664
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3664
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3664
      nrange += tp[i] > X_UINT64_MAX ;
#line 3664
    }
#line 3664
   /* copy workspace back if necessary */
#line 3664
    if (realign) {
#line 3664
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3664
      xp = (uint64 *) *xpp;
#line 3664
    }
#line 3664
   /* update xpp and tp */
#line 3664
    xp += ni;
#line 3664
    tp += ni;
#line 3664
    *xpp = (void*)xp;
#line 3664
  }
#line 3664
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3664

#line 3664
#else   /* not SX */
#line 3664

#line 3664
	char *xp = (char *) *xpp;
#line 3664
	int status = NC_NOERR;
#line 3664

#line 3664
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3664
	{
#line 3664
		int lstatus = ncx_put_ulonglong_ushort(xp, tp, fillp);
#line 3664
		if (status == NC_NOERR) /* report the first encountered error */
#line 3664
			status = lstatus;
#line 3664
	}
#line 3664

#line 3664
	*xpp = (void *)xp;
#line 3664
	return status;
#line 3664
#endif
#line 3664
}
#line 3664

int
#line 3665
ncx_putn_ulonglong_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3665
{
#line 3665
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3665

#line 3665
 /* basic algorithm is:
#line 3665
  *   - ensure sane alignment of output data
#line 3665
  *   - copy (conversion happens automatically) input data
#line 3665
  *     to output
#line 3665
  *   - update tp to point at next unconverted input, and xpp to point
#line 3665
  *     at next location for converted output
#line 3665
  */
#line 3665
  long i, j, ni;
#line 3665
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3665
  uint64 *xp;
#line 3665
  int nrange = 0;         /* number of range errors */
#line 3665
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3665
  long cxp = (long) *((char**)xpp);
#line 3665

#line 3665
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3665
  /* sjl: manually stripmine so we can limit amount of
#line 3665
   * vector work space reserved to LOOPCNT elements. Also
#line 3665
   * makes vectorisation easy */
#line 3665
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3665
    ni=Min(nelems-j,LOOPCNT);
#line 3665
    if (realign) {
#line 3665
      xp = tmp;
#line 3665
    } else {
#line 3665
      xp = (uint64 *) *xpp;
#line 3665
    }
#line 3665
   /* copy the next block */
#line 3665
#pragma cdir loopcnt=LOOPCNT
#line 3665
#pragma cdir shortloop
#line 3665
    for (i=0; i<ni; i++) {
#line 3665
      /* the normal case: */
#line 3665
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3665
     /* test for range errors (not always needed but do it anyway) */
#line 3665
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3665
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3665
      nrange += tp[i] > X_UINT64_MAX ;
#line 3665
    }
#line 3665
   /* copy workspace back if necessary */
#line 3665
    if (realign) {
#line 3665
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3665
      xp = (uint64 *) *xpp;
#line 3665
    }
#line 3665
   /* update xpp and tp */
#line 3665
    xp += ni;
#line 3665
    tp += ni;
#line 3665
    *xpp = (void*)xp;
#line 3665
  }
#line 3665
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3665

#line 3665
#else   /* not SX */
#line 3665

#line 3665
	char *xp = (char *) *xpp;
#line 3665
	int status = NC_NOERR;
#line 3665

#line 3665
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3665
	{
#line 3665
		int lstatus = ncx_put_ulonglong_uint(xp, tp, fillp);
#line 3665
		if (status == NC_NOERR) /* report the first encountered error */
#line 3665
			status = lstatus;
#line 3665
	}
#line 3665

#line 3665
	*xpp = (void *)xp;
#line 3665
	return status;
#line 3665
#endif
#line 3665
}
#line 3665



/*
 * Other aggregate conversion functions.
 */

/* text */

int
ncx_getn_text(const void **xpp, size_t nelems, char *tp)
{
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 3677
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3677
	return NC_NOERR;
#line 3677

}

int
ncx_pad_getn_text(const void **xpp, size_t nelems, char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3683

#line 3683
	if (rndup)
#line 3683
		rndup = X_ALIGN - rndup;
#line 3683

#line 3683
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 3683
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3683

#line 3683
	return NC_NOERR;
#line 3683

}

int
ncx_putn_text(void **xpp, size_t nelems, const char *tp)
{
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3689
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3689

#line 3689
	return NC_NOERR;
#line 3689

}

int
ncx_pad_putn_text(void **xpp, size_t nelems, const char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3695

#line 3695
	if (rndup)
#line 3695
		rndup = X_ALIGN - rndup;
#line 3695

#line 3695
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3695
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3695

#line 3695
	if (rndup)
#line 3695
	{
#line 3695
		(void) memcpy(*xpp, nada, (size_t)rndup);
#line 3695
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3695
	}
#line 3695

#line 3695
	return NC_NOERR;
#line 3695

}


/* opaque */

int
ncx_getn_void(const void **xpp, size_t nelems, void *tp)
{
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 3704
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3704
	return NC_NOERR;
#line 3704

}

int
ncx_pad_getn_void(const void **xpp, size_t nelems, void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3710

#line 3710
	if (rndup)
#line 3710
		rndup = X_ALIGN - rndup;
#line 3710

#line 3710
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 3710
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3710

#line 3710
	return NC_NOERR;
#line 3710

}

int
ncx_putn_void(void **xpp, size_t nelems, const void *tp)
{
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3716
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3716

#line 3716
	return NC_NOERR;
#line 3716

}

int
ncx_pad_putn_void(void **xpp, size_t nelems, const void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3722

#line 3722
	if (rndup)
#line 3722
		rndup = X_ALIGN - rndup;
#line 3722

#line 3722
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3722
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3722

#line 3722
	if (rndup)
#line 3722
	{
#line 3722
		(void) memcpy(*xpp, nada, (size_t)rndup);
#line 3722
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3722
	}
#line 3722

#line 3722
	return NC_NOERR;
#line 3722

}
