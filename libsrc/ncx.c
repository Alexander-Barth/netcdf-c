#line 6 "ncx.m4"
/* Do not edit this file. It is produced from the corresponding .m4 source */
#line 8
/*
 *  Copyright (C) 2014, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id: ncx.m4 2601 2016-11-07 04:54:42Z wkliao $ */

#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif

#line 22



#line 31

#line 38

#line 38
#if HAVE_CONFIG_H
#line 38
#include <config.h>
#line 38
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#line 50

#line 50
#pragma GCC diagnostic ignored "-Wdeprecated"
#line 50
#include "ncx.h"
#line 50
#include "nc3dispatch.h"

#line 69




#ifdef HAVE_INTTYPES_H
#include <inttypes.h> /* uint16_t, uint32_t, uint64_t */
#elif defined(HAVE_STDINT_H)
#include <stdint.h>   /* uint16_t, uint32_t, uint64_t */
#endif

#line 97

#line 115

/*
 * The only error code returned from subroutines in this file is NC_ERANGE,
 * if errors are detected.
 */

/*
 * An external data representation interface.
 */

/* alias poorly named limits.h macros */
#define  SHORT_MAX  SHRT_MAX
#define  SHORT_MIN  SHRT_MIN
#define USHORT_MAX USHRT_MAX
#ifndef LLONG_MAX
#   define LLONG_MAX	9223372036854775807LL
#   define LLONG_MIN	(-LLONG_MAX - 1LL)
#   define ULLONG_MAX	18446744073709551615ULL
#endif
#ifndef LONG_LONG_MAX
#define LONG_LONG_MAX LLONG_MAX
#endif
#ifndef LONGLONG_MAX
#define LONGLONG_MAX LONG_LONG_MAX
#endif
#ifndef LONG_LONG_MIN
#define LONG_LONG_MIN LLONG_MIN
#endif
#ifndef LONGLONG_MIN
#define LONGLONG_MIN LONG_LONG_MIN
#endif
#ifndef ULONG_LONG_MAX
#define ULONG_LONG_MAX ULLONG_MAX
#endif
#ifndef ULONGLONG_MAX
#define ULONGLONG_MAX ULONG_LONG_MAX
#endif
#include <float.h>
#ifndef FLT_MAX /* This POSIX macro missing on some systems */
# ifndef NO_IEEE_FLOAT
# define FLT_MAX 3.40282347e+38f
# else
# error "You will need to define FLT_MAX"
# endif
#endif
/* alias poorly named float.h macros */
#define FLOAT_MAX FLT_MAX
#define FLOAT_MIN (-FLT_MAX)
#define DOUBLE_MAX DBL_MAX
#define DOUBLE_MIN (-DBL_MAX)
#define FLOAT_MAX_EXP FLT_MAX_EXP
#define DOUBLE_MAX_EXP DBL_MAX_EXP
#include <assert.h>
#define UCHAR_MIN 0
#define Min(a,b) ((a) < (b) ? (a) : (b))
#define Max(a,b) ((a) > (b) ? (a) : (b))

#ifndef SIZEOF_UCHAR
#ifdef  SIZEOF_UNSIGNED_CHAR
#define SIZEOF_UCHAR SIZEOF_UNSIGNED_CHAR
#else
#error "unknown SIZEOF_UCHAR"
#endif
#endif

#ifndef SIZEOF_USHORT
#ifdef  SIZEOF_UNSIGNED_SHORT_INT
#define SIZEOF_USHORT SIZEOF_UNSIGNED_SHORT_INT
#elif defined(SIZEOF_UNSIGNED_SHORT)
#define SIZEOF_USHORT SIZEOF_UNSIGNED_SHORT
#else
#error "unknown SIZEOF_USHORT"
#endif
#endif

#ifndef SIZEOF_UINT
#ifdef  SIZEOF_UNSIGNED_INT
#define SIZEOF_UINT SIZEOF_UNSIGNED_INT
#else
#error "unknown SIZEOF_UINT"
#endif
#endif

#ifndef SIZEOF_LONGLONG
#ifdef  SIZEOF_LONG_LONG
#define SIZEOF_LONGLONG SIZEOF_LONG_LONG
#else
#error "unknown SIZEOF_LONGLONG"
#endif
#endif

#ifndef SIZEOF_INT64
#ifdef  SIZEOF_LONG_LONG
#define SIZEOF_INT64 SIZEOF_LONG_LONG
#elif defined(SIZEOF_LONGLONG)
#define SIZEOF_INT64 SIZEOF_LONGLONG
#else
#error "unknown SIZEOF_INT64"
#endif
#endif

#ifndef SIZEOF_ULONGLONG
#ifdef  SIZEOF_UNSIGNED_LONG_LONG
#define SIZEOF_ULONGLONG SIZEOF_UNSIGNED_LONG_LONG
#else
#error "unknown SIZEOF_ULONGLONG"
#endif
#endif

#ifndef SIZEOF_UINT64
#ifdef  SIZEOF_UNSIGNED_LONG_LONG
#define SIZEOF_UINT64 SIZEOF_UNSIGNED_LONG_LONG
#elif defined(SIZEOF_ULONGLONG)
#define SIZEOF_UINT64 SIZEOF_ULONGLONG
#else
#error "unknown SIZEOF_UINT64"
#endif
#endif

/*
 * If the machine's float domain is "smaller" than the external one
 * use the machine domain
 */
#if defined(FLT_MAX_EXP) && FLT_MAX_EXP < 128 /* 128 is X_FLT_MAX_EXP */
#undef X_FLOAT_MAX
# define X_FLOAT_MAX FLT_MAX
#undef X_FLOAT_MIN
# define X_FLOAT_MIN (-X_FLOAT_MAX)
#endif

#if defined(_SX) && _SX != 0 /* NEC SUPER UX */
#define LOOPCNT 256    /* must be no longer than hardware vector length */
#if _INT64
#undef  INT_MAX /* workaround cpp bug */
#define INT_MAX  X_INT_MAX
#undef  INT_MIN /* workaround cpp bug */
#define INT_MIN  X_INT_MIN
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  X_INT_MAX
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN  X_INT_MIN
#elif _LONG64
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  4294967295L
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN -4294967295L
#endif
#if !_FLOAT0
#error "FLOAT1 and FLOAT2 not supported"
#endif
#endif /* _SX */

static const char nada[X_ALIGN] = {0, 0, 0, 0};

#ifndef WORDS_BIGENDIAN
/* LITTLE_ENDIAN: DEC and intel */
/*
 * Routines to convert to BIG ENDIAN.
 * Optimize the swapn?b() and swap?b() routines aggressively.
 */

#define SWAP2(a) ( (((a) & 0xff) << 8) | \
                   (((a) >> 8) & 0xff) )

#define SWAP4(a) ( ((a) << 24) | \
                  (((a) <<  8) & 0x00ff0000) | \
                  (((a) >>  8) & 0x0000ff00) | \
                  (((a) >> 24) & 0x000000ff) )

#define SWAP8(a) ( (((a) & 0x00000000000000FFULL) << 56) | \
                   (((a) & 0x000000000000FF00ULL) << 40) | \
                   (((a) & 0x0000000000FF0000ULL) << 24) | \
                   (((a) & 0x00000000FF000000ULL) <<  8) | \
                   (((a) & 0x000000FF00000000ULL) >>  8) | \
                   (((a) & 0x0000FF0000000000ULL) >> 24) | \
                   (((a) & 0x00FF000000000000ULL) >> 40) | \
                   (((a) & 0xFF00000000000000ULL) >> 56) )


inline static void
swapn2b(void *dst, const void *src, size_t nn)
{
    /* it is OK if dst == src */
    int i;
    uint16_t *op = (uint16_t*) dst;
    uint16_t *ip = (uint16_t*) src;
    for (i=0; i<nn; i++) {
        op[i] = ip[i];
        op[i] = (uint16_t)SWAP2(op[i]);
    }
#if 0
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *
 *	while (nn-- > 0)
 *	{
 *		*op++ = *(++ip);
 *		*op++ = *(ip++ -1);
 *	}
 */
	while (nn > 3)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		nn -= 4;
	}
	while (nn-- > 0)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
	}
#endif
}

# ifndef vax
inline static void
swap4b(void *dst, const void *src)
{
    /* copy over, make the below swap in-place */
    uint32_t tmp = *(uint32_t*)src;
    tmp = SWAP4(tmp);
    memcpy(dst, &tmp, 4);

    /* Codes below will cause "break strict-aliasing rules" in gcc
    uint32_t *op = (uint32_t*)dst;
    *op = *(uint32_t*)src;
    *op = SWAP4(*op);
    */

    /* Below are copied from netCDF-4.
     * See https://bugtracking.unidata.ucar.edu/browse/NCF-338
     * Quote "One issue we are wrestling with is how compilers optimize this
     * code.  For some reason, we are actually needing to add an artificial
     * move to a 4 byte space to get it to work.  I think what is happening is
     * that the optimizer is bit shifting within a double, which is incorrect.
     * The following code actually does work correctly.
     *  This is in Linux land, gcc.
     *
     * However, the above in-place byte-swap does not appear affected by this.
     */
#if 0
    uint32_t *ip = (uint32_t*)src;
    uint32_t tempOut;  /* cannot use pointer when gcc O2 optimizer is used */
    tempOut = SWAP4(*ip);

    *(float *)dst = *(float *)(&tempOut);
#endif

    /* OLD implementation that results in four load and four store CPU
       instructions
    char *op = dst;
    const char *ip = src;
    op[0] = ip[3];
    op[1] = ip[2];
    op[2] = ip[1];
    op[3] = ip[0];
    */

}
# endif /* !vax */

inline static void
swapn4b(void *dst, const void *src, size_t nn)
{
    int i;
    uint32_t *op = (uint32_t*) dst;
    uint32_t *ip = (uint32_t*) src;
    for (i=0; i<nn; i++) {
        /* copy over, make the below swap in-place */
        op[i] = ip[i];
        op[i] = SWAP4(op[i]);
    }

#if 0
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while (nn-- > 0)
 *	{
 *		op[0] = ip[3];
 *		op[1] = ip[2];
 *		op[2] = ip[1];
 *		op[3] = ip[0];
 *		op += 4;
 *		ip += 4;
 *	}
 */
	while (nn > 3)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op[8] = ip[11];
		op[9] = ip[10];
		op[10] = ip[9];
		op[11] = ip[8];
		op[12] = ip[15];
		op[13] = ip[14];
		op[14] = ip[13];
		op[15] = ip[12];
		op += 16;
		ip += 16;
		nn -= 4;
	}
	while (nn-- > 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op += 4;
		ip += 4;
	}
#endif
}

# ifndef vax
inline static void
swap8b(void *dst, const void *src)
{
#ifdef FLOAT_WORDS_BIGENDIAN
    /* copy over, make the below swap in-place */
    *(uint64_t*)dst = *(uint64_t*)src;

    uint32_t *op = (uint32_t*)dst;
    *op = SWAP4(*op);
    op = (uint32_t*)((char*)dst+4);
    *op = SWAP4(*op);
#else
    uint64_t *op = (uint64_t*)dst;
    /* copy over, make the below swap in-place */
    *op = *(uint64_t*)src;
    *op = SWAP8(*op);
#endif

#if 0
	char *op = dst;
	const char *ip = src;
#  ifndef FLOAT_WORDS_BIGENDIAN
	op[0] = ip[7];
	op[1] = ip[6];
	op[2] = ip[5];
	op[3] = ip[4];
	op[4] = ip[3];
	op[5] = ip[2];
	op[6] = ip[1];
	op[7] = ip[0];
#  else
	op[0] = ip[3];
	op[1] = ip[2];
	op[2] = ip[1];
	op[3] = ip[0];
	op[4] = ip[7];
	op[5] = ip[6];
	op[6] = ip[5];
	op[7] = ip[4];
#endif
#endif
}
# endif /* !vax */

# ifndef vax
inline static void
swapn8b(void *dst, const void *src, size_t nn)
{
#ifdef FLOAT_WORDS_BIGENDIAN
    int i;
    uint64_t *dst_p = (uint64_t*) dst;
    uint64_t *src_p = (uint64_t*) src;
    for (i=0; i<nn; i++) {
        /* copy over, make the below swap in-place */
        dst_p[i] = src_p[i];
        uint32_t *op = (uint32_t*)(&dst_p[i]);
        *op = SWAP4(*op);
        op = (uint32_t*)((char*)op+4);
        *op = SWAP4(*op);
    }
#else
    int i;
    uint64_t *op = (uint64_t*) dst;
    uint64_t *ip = (uint64_t*) src;
    for (i=0; i<nn; i++) {
        /* copy over, make the below swap in-place */
        op[i] = ip[i];
        op[i] = SWAP8(op[i]);
    }
#endif

#if 0
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while (nn-- > 0)
 *	{
 *		op[0] = ip[7];
 *		op[1] = ip[6];
 *		op[2] = ip[5];
 *		op[3] = ip[4];
 *		op[4] = ip[3];
 *		op[5] = ip[2];
 *		op[6] = ip[1];
 *		op[7] = ip[0];
 *		op += 8;
 *		ip += 8;
 *	}
 */
#  ifndef FLOAT_WORDS_BIGENDIAN
	while (nn > 1)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op[8] = ip[15];
		op[9] = ip[14];
		op[10] = ip[13];
		op[11] = ip[12];
		op[12] = ip[11];
		op[13] = ip[10];
		op[14] = ip[9];
		op[15] = ip[8];
		op += 16;
		ip += 16;
		nn -= 2;
	}
	while (nn-- > 0)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op += 8;
		ip += 8;
	}
#  else
	while (nn-- > 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op += 8;
		ip += 8;
	}
#endif
#endif
}
# endif /* !vax */

#endif /* LITTLE_ENDIAN */

#line 616

#line 620

#line 630

#line 643


/*
 * Primitive numeric conversion functions.
 */

#line 671

#line 715

#line 742

#line 782

/* x_schar */
/* x_uchar */

/* We don't implement any x_schar and x_uchar primitives. */


/* external NC_SHORT --------------------------------------------------------*/

#if SHORT_MAX == X_SHORT_MAX
typedef short ix_short;
#define SIZEOF_IX_SHORT SIZEOF_SHORT
#define IX_SHORT_MAX SHORT_MAX
#elif INT_MAX >= X_SHORT_MAX
typedef int ix_short;
#define SIZEOF_IX_SHORT SIZEOF_INT
#define IX_SHORT_MAX INT_MAX
#elif LONG_MAX >= X_SHORT_MAX
typedef long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONG
#define IX_SHORT_MAX LONG_MAX
#elif LLONG_MAX >= X_SHORT_MAX
typedef long long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONGLONG
#define IX_SHORT_MAX LLONG_MAX
#else
#error "ix_short implementation"
#endif

static void
get_ix_short(const void *xp, ix_short *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = (ix_short)(*cp++ << 8);
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if (*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip = (ix_short)(*ip | *cp);
}

static void
put_ix_short(void *xp, const ix_short *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (uchar)((*ip) >> 8);
	*cp   = (uchar)((*ip) & 0xff);
}

static int
#line 834
ncx_get_short_schar(const void *xp, schar *ip)
#line 834
{
#line 834
    int err=NC_NOERR;
#line 834
    ix_short xx;
#line 834
    get_ix_short(xp, &xx);
#line 834

#line 834
#if IX_SHORT_MAX > SCHAR_MAX
#line 834
    if (xx > SCHAR_MAX || xx < SCHAR_MIN) {
#line 834

#line 834
        err = NC_ERANGE;
#line 834
    }
#line 834
#endif
#line 834

#line 834

#line 834
    *ip = (schar) xx;
#line 834
    return err;
#line 834
}
#line 834

static int
#line 835
ncx_get_short_short(const void *xp, short *ip)
#line 835
{
#line 835
    int err=NC_NOERR;
#line 835
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
#line 835
    get_ix_short(xp, (ix_short *)ip);
#line 835
#else
#line 835
    ix_short xx;
#line 835
    get_ix_short(xp, &xx);
#line 835

#line 835
#if IX_SHORT_MAX > SHORT_MAX
#line 835
    if (xx > SHORT_MAX || xx < SHORT_MIN) {
#line 835

#line 835
        err = NC_ERANGE;
#line 835
    }
#line 835
#endif
#line 835

#line 835

#line 835
    *ip = (short) xx;
#line 835
#endif
#line 835
    return err;
#line 835
}
#line 835

static int
#line 836
ncx_get_short_int(const void *xp, int *ip)
#line 836
{
#line 836
    int err=NC_NOERR;
#line 836
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
#line 836
    get_ix_short(xp, (ix_short *)ip);
#line 836
#else
#line 836
    ix_short xx;
#line 836
    get_ix_short(xp, &xx);
#line 836

#line 836
#if IX_SHORT_MAX > INT_MAX
#line 836
    if (xx > INT_MAX || xx < INT_MIN) {
#line 836

#line 836
        err = NC_ERANGE;
#line 836
    }
#line 836
#endif
#line 836

#line 836

#line 836
    *ip = (int) xx;
#line 836
#endif
#line 836
    return err;
#line 836
}
#line 836

static int
#line 837
ncx_get_short_long(const void *xp, long *ip)
#line 837
{
#line 837
    int err=NC_NOERR;
#line 837
#if SIZEOF_IX_SHORT == SIZEOF_LONG && IX_SHORT_MAX == LONG_MAX
#line 837
    get_ix_short(xp, (ix_short *)ip);
#line 837
#else
#line 837
    ix_short xx;
#line 837
    get_ix_short(xp, &xx);
#line 837

#line 837
#if IX_SHORT_MAX > LONG_MAX
#line 837
    if (xx > LONG_MAX || xx < LONG_MIN) {
#line 837

#line 837
        err = NC_ERANGE;
#line 837
    }
#line 837
#endif
#line 837

#line 837

#line 837
    *ip = (long) xx;
#line 837
#endif
#line 837
    return err;
#line 837
}
#line 837

static int
#line 838
ncx_get_short_longlong(const void *xp, longlong *ip)
#line 838
{
#line 838
    int err=NC_NOERR;
#line 838
#if SIZEOF_IX_SHORT == SIZEOF_LONGLONG && IX_SHORT_MAX == LONGLONG_MAX
#line 838
    get_ix_short(xp, (ix_short *)ip);
#line 838
#else
#line 838
    ix_short xx;
#line 838
    get_ix_short(xp, &xx);
#line 838

#line 838
#if IX_SHORT_MAX > LONGLONG_MAX
#line 838
    if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) {
#line 838

#line 838
        err = NC_ERANGE;
#line 838
    }
#line 838
#endif
#line 838

#line 838

#line 838
    *ip = (longlong) xx;
#line 838
#endif
#line 838
    return err;
#line 838
}
#line 838

static int
#line 839
ncx_get_short_ushort(const void *xp, ushort *ip)
#line 839
{
#line 839
    int err=NC_NOERR;
#line 839
    ix_short xx;
#line 839
    get_ix_short(xp, &xx);
#line 839

#line 839
#if IX_SHORT_MAX > USHORT_MAX
#line 839
    if (xx > USHORT_MAX) {
#line 839

#line 839
        err = NC_ERANGE;
#line 839
    }
#line 839
#endif
#line 839

#line 839
    if (xx < 0) {
#line 839

#line 839
        err = NC_ERANGE; /* because ip is unsigned */
#line 839
    }
#line 839
    *ip = (ushort) xx;
#line 839
    return err;
#line 839
}
#line 839

static int
#line 840
ncx_get_short_uchar(const void *xp, uchar *ip)
#line 840
{
#line 840
    int err=NC_NOERR;
#line 840
    ix_short xx;
#line 840
    get_ix_short(xp, &xx);
#line 840

#line 840
#if IX_SHORT_MAX > UCHAR_MAX
#line 840
    if (xx > UCHAR_MAX) {
#line 840

#line 840
        err = NC_ERANGE;
#line 840
    }
#line 840
#endif
#line 840

#line 840
    if (xx < 0) {
#line 840

#line 840
        err = NC_ERANGE; /* because ip is unsigned */
#line 840
    }
#line 840
    *ip = (uchar) xx;
#line 840
    return err;
#line 840
}
#line 840

static int
#line 841
ncx_get_short_uint(const void *xp, uint *ip)
#line 841
{
#line 841
    int err=NC_NOERR;
#line 841
    ix_short xx;
#line 841
    get_ix_short(xp, &xx);
#line 841

#line 841
#if IX_SHORT_MAX > UINT_MAX
#line 841
    if (xx > UINT_MAX) {
#line 841

#line 841
        err = NC_ERANGE;
#line 841
    }
#line 841
#endif
#line 841

#line 841
    if (xx < 0) {
#line 841

#line 841
        err = NC_ERANGE; /* because ip is unsigned */
#line 841
    }
#line 841
    *ip = (uint) xx;
#line 841
    return err;
#line 841
}
#line 841

static int
#line 842
ncx_get_short_ulonglong(const void *xp, ulonglong *ip)
#line 842
{
#line 842
    int err=NC_NOERR;
#line 842
    ix_short xx;
#line 842
    get_ix_short(xp, &xx);
#line 842

#line 842
#if IX_SHORT_MAX > ULONGLONG_MAX
#line 842
    if (xx > ULONGLONG_MAX) {
#line 842

#line 842
        err = NC_ERANGE;
#line 842
    }
#line 842
#endif
#line 842

#line 842
    if (xx < 0) {
#line 842

#line 842
        err = NC_ERANGE; /* because ip is unsigned */
#line 842
    }
#line 842
    *ip = (ulonglong) xx;
#line 842
    return err;
#line 842
}
#line 842

static int
#line 843
ncx_get_short_float(const void *xp, float *ip)
#line 843
{
#line 843
	ix_short xx;
#line 843
	get_ix_short(xp, &xx);
#line 843
	*ip = (float)xx;
#line 843
	return NC_NOERR;
#line 843
}
#line 843

static int
#line 844
ncx_get_short_double(const void *xp, double *ip)
#line 844
{
#line 844
	ix_short xx;
#line 844
	get_ix_short(xp, &xx);
#line 844
	*ip = (double)xx;
#line 844
	return NC_NOERR;
#line 844
}
#line 844


static int
ncx_put_short_schar(void *xp, const schar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	if (*ip & 0x80)
		*cp++ = 0xff;
	else
		*cp++ = 0;
	*cp = (uchar)*ip;
	return NC_NOERR;
}

static int
ncx_put_short_uchar(void *xp, const uchar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return NC_NOERR;
}

static int
#line 867
ncx_put_short_short(void *xp, const short *ip, void *fillp)
#line 867
{
#line 867
    int err=NC_NOERR;
#line 867
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
#line 867
    put_ix_short(xp, (const ix_short *)ip);
#line 867
#else
#line 867
    ix_short xx = NC_FILL_SHORT;
#line 867

#line 867
#if IX_SHORT_MAX < SHORT_MAX
#line 867
    if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) {
#line 867
        
#line 867
        err = NC_ERANGE;
#line 867
    } 
#line 867
#endif
#line 867
        xx = (ix_short)*ip;
#line 867

#line 867
    put_ix_short(xp, &xx);
#line 867
#endif
#line 867
    return err;
#line 867
}
#line 867

static int
#line 868
ncx_put_short_int(void *xp, const int *ip, void *fillp)
#line 868
{
#line 868
    int err=NC_NOERR;
#line 868
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
#line 868
    put_ix_short(xp, (const ix_short *)ip);
#line 868
#else
#line 868
    ix_short xx = NC_FILL_SHORT;
#line 868

#line 868
#if IX_SHORT_MAX < INT_MAX
#line 868
    if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) {
#line 868
        
#line 868
        err = NC_ERANGE;
#line 868
    } 
#line 868
#endif
#line 868
        xx = (ix_short)*ip;
#line 868

#line 868
    put_ix_short(xp, &xx);
#line 868
#endif
#line 868
    return err;
#line 868
}
#line 868

static int
#line 869
ncx_put_short_long(void *xp, const long *ip, void *fillp)
#line 869
{
#line 869
    int err=NC_NOERR;
#line 869
#if SIZEOF_IX_SHORT == SIZEOF_LONG && IX_SHORT_MAX == LONG_MAX
#line 869
    put_ix_short(xp, (const ix_short *)ip);
#line 869
#else
#line 869
    ix_short xx = NC_FILL_SHORT;
#line 869

#line 869
#if IX_SHORT_MAX < LONG_MAX
#line 869
    if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) {
#line 869
        
#line 869
        err = NC_ERANGE;
#line 869
    } 
#line 869
#endif
#line 869
        xx = (ix_short)*ip;
#line 869

#line 869
    put_ix_short(xp, &xx);
#line 869
#endif
#line 869
    return err;
#line 869
}
#line 869

static int
#line 870
ncx_put_short_longlong(void *xp, const longlong *ip, void *fillp)
#line 870
{
#line 870
    int err=NC_NOERR;
#line 870
#if SIZEOF_IX_SHORT == SIZEOF_LONGLONG && IX_SHORT_MAX == LONGLONG_MAX
#line 870
    put_ix_short(xp, (const ix_short *)ip);
#line 870
#else
#line 870
    ix_short xx = NC_FILL_SHORT;
#line 870

#line 870
#if IX_SHORT_MAX < LONGLONG_MAX
#line 870
    if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) {
#line 870
        
#line 870
        err = NC_ERANGE;
#line 870
    } 
#line 870
#endif
#line 870
        xx = (ix_short)*ip;
#line 870

#line 870
    put_ix_short(xp, &xx);
#line 870
#endif
#line 870
    return err;
#line 870
}
#line 870

static int
#line 871
ncx_put_short_ushort(void *xp, const ushort *ip, void *fillp)
#line 871
{
#line 871
    int err=NC_NOERR;
#line 871
    ix_short xx = NC_FILL_SHORT;
#line 871

#line 871
#if IX_SHORT_MAX < USHORT_MAX
#line 871
    if (*ip > IX_SHORT_MAX) {
#line 871
        
#line 871
        err = NC_ERANGE;
#line 871
    } 
#line 871
#endif
#line 871
        xx = (ix_short)*ip;
#line 871

#line 871
    put_ix_short(xp, &xx);
#line 871
    return err;
#line 871
}
#line 871

static int
#line 872
ncx_put_short_uint(void *xp, const uint *ip, void *fillp)
#line 872
{
#line 872
    int err=NC_NOERR;
#line 872
    ix_short xx = NC_FILL_SHORT;
#line 872

#line 872
#if IX_SHORT_MAX < UINT_MAX
#line 872
    if (*ip > IX_SHORT_MAX) {
#line 872
        
#line 872
        err = NC_ERANGE;
#line 872
    } 
#line 872
#endif
#line 872
        xx = (ix_short)*ip;
#line 872

#line 872
    put_ix_short(xp, &xx);
#line 872
    return err;
#line 872
}
#line 872

static int
#line 873
ncx_put_short_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 873
{
#line 873
    int err=NC_NOERR;
#line 873
    ix_short xx = NC_FILL_SHORT;
#line 873

#line 873
#if IX_SHORT_MAX < ULONGLONG_MAX
#line 873
    if (*ip > IX_SHORT_MAX) {
#line 873
        
#line 873
        err = NC_ERANGE;
#line 873
    } 
#line 873
#endif
#line 873
        xx = (ix_short)*ip;
#line 873

#line 873
    put_ix_short(xp, &xx);
#line 873
    return err;
#line 873
}
#line 873

static int
#line 874
ncx_put_short_float(void *xp, const float *ip, void *fillp)
#line 874
{
#line 874
    int err=NC_NOERR;
#line 874
    ix_short xx = NC_FILL_SHORT;
#line 874

#line 874
    if (*ip > (double)X_SHORT_MAX || *ip < (double)X_SHORT_MIN) {
#line 874
        
#line 874
        err = NC_ERANGE;
#line 874
    } 
#line 874
        xx = (ix_short)*ip;
#line 874

#line 874
    put_ix_short(xp, &xx);
#line 874
    return err;
#line 874
}
#line 874

static int
#line 875
ncx_put_short_double(void *xp, const double *ip, void *fillp)
#line 875
{
#line 875
    int err=NC_NOERR;
#line 875
    ix_short xx = NC_FILL_SHORT;
#line 875

#line 875
    if (*ip > X_SHORT_MAX || *ip < X_SHORT_MIN) {
#line 875
        
#line 875
        err = NC_ERANGE;
#line 875
    } 
#line 875
        xx = (ix_short)*ip;
#line 875

#line 875
    put_ix_short(xp, &xx);
#line 875
    return err;
#line 875
}
#line 875


/* external NC_USHORT -------------------------------------------------------*/

#if USHORT_MAX == X_USHORT_MAX
typedef unsigned short ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_USHORT
#define IX_USHORT_MAX USHORT_MAX
#elif UINT_MAX >= X_USHORT_MAX
typedef unsigned int ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_UINT
#define IX_USHORT_MAX UINT_MAX
#elif ULONG_MAX >= X_USHORT_MAX
typedef unsigned long ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_ULONG
#define IX_USHORT_MAX ULONG_MAX
#elif ULLONG_MAX >= X_USHORT_MAX
typedef unsigned long long ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_ULONGLONG
#define IX_USHORT_MAX ULLONG_MAX
#else
#error "ix_ushort implementation"
#endif

static void
get_ix_ushort(const void *xp, ix_ushort *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = (ix_ushort)(*cp++ << 8);
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if (*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip = (ix_ushort)(*ip | *cp);
}

static void
put_ix_ushort(void *xp, const ix_ushort *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (uchar)((*ip) >> 8);
	*cp   = (uchar)((*ip) & 0xff);
}

static int
#line 922
ncx_get_ushort_schar(const void *xp, schar *ip)
#line 922
{
#line 922
    int err=NC_NOERR;
#line 922
    ix_ushort xx;
#line 922
    get_ix_ushort(xp, &xx);
#line 922

#line 922
#if IX_USHORT_MAX > SCHAR_MAX
#line 922
    if (xx > SCHAR_MAX) {
#line 922

#line 922
        err = NC_ERANGE;
#line 922
    }
#line 922
#endif
#line 922

#line 922

#line 922
    *ip = (schar) xx;
#line 922
    return err;
#line 922
}
#line 922

static int
#line 923
ncx_get_ushort_short(const void *xp, short *ip)
#line 923
{
#line 923
    int err=NC_NOERR;
#line 923
    ix_ushort xx;
#line 923
    get_ix_ushort(xp, &xx);
#line 923

#line 923
#if IX_USHORT_MAX > SHORT_MAX
#line 923
    if (xx > SHORT_MAX) {
#line 923

#line 923
        err = NC_ERANGE;
#line 923
    }
#line 923
#endif
#line 923

#line 923

#line 923
    *ip = (short) xx;
#line 923
    return err;
#line 923
}
#line 923

static int
#line 924
ncx_get_ushort_int(const void *xp, int *ip)
#line 924
{
#line 924
    int err=NC_NOERR;
#line 924
    ix_ushort xx;
#line 924
    get_ix_ushort(xp, &xx);
#line 924

#line 924
#if IX_USHORT_MAX > INT_MAX
#line 924
    if (xx > INT_MAX) {
#line 924

#line 924
        err = NC_ERANGE;
#line 924
    }
#line 924
#endif
#line 924

#line 924

#line 924
    *ip = (int) xx;
#line 924
    return err;
#line 924
}
#line 924

static int
#line 925
ncx_get_ushort_long(const void *xp, long *ip)
#line 925
{
#line 925
    int err=NC_NOERR;
#line 925
    ix_ushort xx;
#line 925
    get_ix_ushort(xp, &xx);
#line 925

#line 925
#if IX_USHORT_MAX > LONG_MAX
#line 925
    if (xx > LONG_MAX) {
#line 925

#line 925
        err = NC_ERANGE;
#line 925
    }
#line 925
#endif
#line 925

#line 925

#line 925
    *ip = (long) xx;
#line 925
    return err;
#line 925
}
#line 925

static int
#line 926
ncx_get_ushort_longlong(const void *xp, longlong *ip)
#line 926
{
#line 926
    int err=NC_NOERR;
#line 926
    ix_ushort xx;
#line 926
    get_ix_ushort(xp, &xx);
#line 926

#line 926
#if IX_USHORT_MAX > LONGLONG_MAX
#line 926
    if (xx > LONGLONG_MAX) {
#line 926

#line 926
        err = NC_ERANGE;
#line 926
    }
#line 926
#endif
#line 926

#line 926

#line 926
    *ip = (longlong) xx;
#line 926
    return err;
#line 926
}
#line 926

static int
#line 927
ncx_get_ushort_ushort(const void *xp, ushort *ip)
#line 927
{
#line 927
    int err=NC_NOERR;
#line 927
#if SIZEOF_IX_USHORT == SIZEOF_USHORT && IX_USHORT_MAX == USHORT_MAX
#line 927
    get_ix_ushort(xp, (ix_ushort *)ip);
#line 927
#else
#line 927
    ix_ushort xx;
#line 927
    get_ix_ushort(xp, &xx);
#line 927

#line 927
#if IX_USHORT_MAX > USHORT_MAX
#line 927
    if (xx > USHORT_MAX) {
#line 927

#line 927
        err = NC_ERANGE;
#line 927
    }
#line 927
#endif
#line 927

#line 927

#line 927
    *ip = (ushort) xx;
#line 927
#endif
#line 927
    return err;
#line 927
}
#line 927

static int
#line 928
ncx_get_ushort_uchar(const void *xp, uchar *ip)
#line 928
{
#line 928
    int err=NC_NOERR;
#line 928
#if SIZEOF_IX_USHORT == SIZEOF_UCHAR && IX_USHORT_MAX == UCHAR_MAX
#line 928
    get_ix_ushort(xp, (ix_ushort *)ip);
#line 928
#else
#line 928
    ix_ushort xx;
#line 928
    get_ix_ushort(xp, &xx);
#line 928

#line 928
#if IX_USHORT_MAX > UCHAR_MAX
#line 928
    if (xx > UCHAR_MAX) {
#line 928

#line 928
        err = NC_ERANGE;
#line 928
    }
#line 928
#endif
#line 928

#line 928

#line 928
    *ip = (uchar) xx;
#line 928
#endif
#line 928
    return err;
#line 928
}
#line 928

static int
#line 929
ncx_get_ushort_uint(const void *xp, uint *ip)
#line 929
{
#line 929
    int err=NC_NOERR;
#line 929
#if SIZEOF_IX_USHORT == SIZEOF_UINT && IX_USHORT_MAX == UINT_MAX
#line 929
    get_ix_ushort(xp, (ix_ushort *)ip);
#line 929
#else
#line 929
    ix_ushort xx;
#line 929
    get_ix_ushort(xp, &xx);
#line 929

#line 929
#if IX_USHORT_MAX > UINT_MAX
#line 929
    if (xx > UINT_MAX) {
#line 929

#line 929
        err = NC_ERANGE;
#line 929
    }
#line 929
#endif
#line 929

#line 929

#line 929
    *ip = (uint) xx;
#line 929
#endif
#line 929
    return err;
#line 929
}
#line 929

static int
#line 930
ncx_get_ushort_ulonglong(const void *xp, ulonglong *ip)
#line 930
{
#line 930
    int err=NC_NOERR;
#line 930
#if SIZEOF_IX_USHORT == SIZEOF_ULONGLONG && IX_USHORT_MAX == ULONGLONG_MAX
#line 930
    get_ix_ushort(xp, (ix_ushort *)ip);
#line 930
#else
#line 930
    ix_ushort xx;
#line 930
    get_ix_ushort(xp, &xx);
#line 930

#line 930
#if IX_USHORT_MAX > ULONGLONG_MAX
#line 930
    if (xx > ULONGLONG_MAX) {
#line 930

#line 930
        err = NC_ERANGE;
#line 930
    }
#line 930
#endif
#line 930

#line 930

#line 930
    *ip = (ulonglong) xx;
#line 930
#endif
#line 930
    return err;
#line 930
}
#line 930

static int
#line 931
ncx_get_ushort_float(const void *xp, float *ip)
#line 931
{
#line 931
	ix_ushort xx;
#line 931
	get_ix_ushort(xp, &xx);
#line 931
	*ip = (float)xx;
#line 931
	return NC_NOERR;
#line 931
}
#line 931

static int
#line 932
ncx_get_ushort_double(const void *xp, double *ip)
#line 932
{
#line 932
	ix_ushort xx;
#line 932
	get_ix_ushort(xp, &xx);
#line 932
	*ip = (double)xx;
#line 932
	return NC_NOERR;
#line 932
}
#line 932


static int
ncx_put_ushort_schar(void *xp, const schar *ip, void *fillp)
{
    int err=NC_NOERR;
    uchar *cp;
    if (*ip < 0) {
#line 946
        err = NC_ERANGE;
    }

    cp = (uchar *) xp;
    if (*ip & 0x80)
        *cp++ = 0xff;
    else
        *cp++ = 0;
    *cp = (uchar)*ip;

    return err;
}

static int
ncx_put_ushort_uchar(void *xp, const uchar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return NC_NOERR;
}

static int
#line 968
ncx_put_ushort_short(void *xp, const short *ip, void *fillp)
#line 968
{
#line 968
    int err=NC_NOERR;
#line 968
    ix_ushort xx = NC_FILL_USHORT;
#line 968

#line 968
#if IX_USHORT_MAX < SHORT_MAX
#line 968
    if (*ip > IX_USHORT_MAX) {
#line 968
        
#line 968
        err = NC_ERANGE;
#line 968
    } 
#line 968
#endif
#line 968
    if (*ip < 0) {
#line 968
        
#line 968
        err = NC_ERANGE; /* because xp is unsigned */
#line 968
    } 
#line 968
        xx = (ix_ushort)*ip;
#line 968

#line 968
    put_ix_ushort(xp, &xx);
#line 968
    return err;
#line 968
}
#line 968

static int
#line 969
ncx_put_ushort_int(void *xp, const int *ip, void *fillp)
#line 969
{
#line 969
    int err=NC_NOERR;
#line 969
    ix_ushort xx = NC_FILL_USHORT;
#line 969

#line 969
#if IX_USHORT_MAX < INT_MAX
#line 969
    if (*ip > IX_USHORT_MAX) {
#line 969
        
#line 969
        err = NC_ERANGE;
#line 969
    } 
#line 969
#endif
#line 969
    if (*ip < 0) {
#line 969
        
#line 969
        err = NC_ERANGE; /* because xp is unsigned */
#line 969
    } 
#line 969
        xx = (ix_ushort)*ip;
#line 969

#line 969
    put_ix_ushort(xp, &xx);
#line 969
    return err;
#line 969
}
#line 969

static int
#line 970
ncx_put_ushort_long(void *xp, const long *ip, void *fillp)
#line 970
{
#line 970
    int err=NC_NOERR;
#line 970
    ix_ushort xx = NC_FILL_USHORT;
#line 970

#line 970
#if IX_USHORT_MAX < LONG_MAX
#line 970
    if (*ip > IX_USHORT_MAX) {
#line 970
        
#line 970
        err = NC_ERANGE;
#line 970
    } 
#line 970
#endif
#line 970
    if (*ip < 0) {
#line 970
        
#line 970
        err = NC_ERANGE; /* because xp is unsigned */
#line 970
    } 
#line 970
        xx = (ix_ushort)*ip;
#line 970

#line 970
    put_ix_ushort(xp, &xx);
#line 970
    return err;
#line 970
}
#line 970

static int
#line 971
ncx_put_ushort_longlong(void *xp, const longlong *ip, void *fillp)
#line 971
{
#line 971
    int err=NC_NOERR;
#line 971
    ix_ushort xx = NC_FILL_USHORT;
#line 971

#line 971
#if IX_USHORT_MAX < LONGLONG_MAX
#line 971
    if (*ip > IX_USHORT_MAX) {
#line 971
        
#line 971
        err = NC_ERANGE;
#line 971
    } 
#line 971
#endif
#line 971
    if (*ip < 0) {
#line 971
        
#line 971
        err = NC_ERANGE; /* because xp is unsigned */
#line 971
    } 
#line 971
        xx = (ix_ushort)*ip;
#line 971

#line 971
    put_ix_ushort(xp, &xx);
#line 971
    return err;
#line 971
}
#line 971

static int
#line 972
ncx_put_ushort_ushort(void *xp, const ushort *ip, void *fillp)
#line 972
{
#line 972
    int err=NC_NOERR;
#line 972
#if SIZEOF_IX_USHORT == SIZEOF_USHORT && IX_USHORT_MAX == USHORT_MAX
#line 972
    put_ix_ushort(xp, (const ix_ushort *)ip);
#line 972
#else
#line 972
    ix_ushort xx = NC_FILL_USHORT;
#line 972

#line 972
#if IX_USHORT_MAX < USHORT_MAX
#line 972
    if (*ip > IX_USHORT_MAX) {
#line 972
        
#line 972
        err = NC_ERANGE;
#line 972
    } 
#line 972
#endif
#line 972
        xx = (ix_ushort)*ip;
#line 972

#line 972
    put_ix_ushort(xp, &xx);
#line 972
#endif
#line 972
    return err;
#line 972
}
#line 972

static int
#line 973
ncx_put_ushort_uint(void *xp, const uint *ip, void *fillp)
#line 973
{
#line 973
    int err=NC_NOERR;
#line 973
#if SIZEOF_IX_USHORT == SIZEOF_UINT && IX_USHORT_MAX == UINT_MAX
#line 973
    put_ix_ushort(xp, (const ix_ushort *)ip);
#line 973
#else
#line 973
    ix_ushort xx = NC_FILL_USHORT;
#line 973

#line 973
#if IX_USHORT_MAX < UINT_MAX
#line 973
    if (*ip > IX_USHORT_MAX) {
#line 973
        
#line 973
        err = NC_ERANGE;
#line 973
    } 
#line 973
#endif
#line 973
        xx = (ix_ushort)*ip;
#line 973

#line 973
    put_ix_ushort(xp, &xx);
#line 973
#endif
#line 973
    return err;
#line 973
}
#line 973

static int
#line 974
ncx_put_ushort_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 974
{
#line 974
    int err=NC_NOERR;
#line 974
#if SIZEOF_IX_USHORT == SIZEOF_ULONGLONG && IX_USHORT_MAX == ULONGLONG_MAX
#line 974
    put_ix_ushort(xp, (const ix_ushort *)ip);
#line 974
#else
#line 974
    ix_ushort xx = NC_FILL_USHORT;
#line 974

#line 974
#if IX_USHORT_MAX < ULONGLONG_MAX
#line 974
    if (*ip > IX_USHORT_MAX) {
#line 974
        
#line 974
        err = NC_ERANGE;
#line 974
    } 
#line 974
#endif
#line 974
        xx = (ix_ushort)*ip;
#line 974

#line 974
    put_ix_ushort(xp, &xx);
#line 974
#endif
#line 974
    return err;
#line 974
}
#line 974

static int
#line 975
ncx_put_ushort_float(void *xp, const float *ip, void *fillp)
#line 975
{
#line 975
    int err=NC_NOERR;
#line 975
    ix_ushort xx = NC_FILL_USHORT;
#line 975

#line 975
    if (*ip > (double)X_USHORT_MAX || *ip < 0) {
#line 975
        
#line 975
        err = NC_ERANGE;
#line 975
    } 
#line 975
        xx = (ix_ushort)*ip;
#line 975

#line 975
    put_ix_ushort(xp, &xx);
#line 975
    return err;
#line 975
}
#line 975

static int
#line 976
ncx_put_ushort_double(void *xp, const double *ip, void *fillp)
#line 976
{
#line 976
    int err=NC_NOERR;
#line 976
    ix_ushort xx = NC_FILL_USHORT;
#line 976

#line 976
    if (*ip > X_USHORT_MAX || *ip < 0) {
#line 976
        
#line 976
        err = NC_ERANGE;
#line 976
    } 
#line 976
        xx = (ix_ushort)*ip;
#line 976

#line 976
    put_ix_ushort(xp, &xx);
#line 976
    return err;
#line 976
}
#line 976


/* external NC_INT ----------------------------------------------------------*/

#if SHORT_MAX == X_INT_MAX
typedef short ix_int;
#define SIZEOF_IX_INT SIZEOF_SHORT
#define IX_INT_MAX SHORT_MAX
#elif INT_MAX  >= X_INT_MAX
typedef int ix_int;
#define SIZEOF_IX_INT SIZEOF_INT
#define IX_INT_MAX INT_MAX
#elif LONG_MAX  >= X_INT_MAX
typedef long ix_int;
#define SIZEOF_IX_INT SIZEOF_LONG
#define IX_INT_MAX LONG_MAX
#else
#error "ix_int implementation"
#endif


static void
get_ix_int(const void *xp, ix_int *ip)
{
	const uchar *cp = (const uchar *) xp;

#if INT_MAX  >= X_INT_MAX
	*ip = (ix_int)((unsigned)(*cp++) << 24);
#else
	*ip = *cp++ << 24;
#endif
#if SIZEOF_IX_INT > X_SIZEOF_INT
	if (*ip & 0x80000000)
	{
		/* extern is negative */
		*ip |= (~(0xffffffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= (*cp++ << 16);
	*ip |= (*cp++ << 8);
	*ip |= *cp;
}

static void
put_ix_int(void *xp, const ix_int *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (uchar)( (*ip) >> 24);
	*cp++ = (uchar)(((*ip) & 0x00ff0000) >> 16);
	*cp++ = (uchar)(((*ip) & 0x0000ff00) >>  8);
	*cp   = (uchar)( (*ip) & 0x000000ff);
}

#if X_SIZEOF_INT != SIZEOF_INT
static int
#line 1031
ncx_get_int_int(const void *xp, int *ip)
#line 1031
{
#line 1031
    int err=NC_NOERR;
#line 1031
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
#line 1031
    get_ix_int(xp, (ix_int *)ip);
#line 1031
#else
#line 1031
    ix_int xx;
#line 1031
    get_ix_int(xp, &xx);
#line 1031

#line 1031
#if IX_INT_MAX > INT_MAX
#line 1031
    if (xx > INT_MAX || xx < INT_MIN) {
#line 1031

#line 1031
        err = NC_ERANGE;
#line 1031
    }
#line 1031
#endif
#line 1031

#line 1031

#line 1031
    *ip = (int) xx;
#line 1031
#endif
#line 1031
    return err;
#line 1031
}
#line 1031

#endif
static int
#line 1033
ncx_get_int_schar(const void *xp, schar *ip)
#line 1033
{
#line 1033
    int err=NC_NOERR;
#line 1033
    ix_int xx;
#line 1033
    get_ix_int(xp, &xx);
#line 1033

#line 1033
#if IX_INT_MAX > SCHAR_MAX
#line 1033
    if (xx > SCHAR_MAX || xx < SCHAR_MIN) {
#line 1033

#line 1033
        err = NC_ERANGE;
#line 1033
    }
#line 1033
#endif
#line 1033

#line 1033

#line 1033
    *ip = (schar) xx;
#line 1033
    return err;
#line 1033
}
#line 1033

static int
#line 1034
ncx_get_int_short(const void *xp, short *ip)
#line 1034
{
#line 1034
    int err=NC_NOERR;
#line 1034
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
#line 1034
    get_ix_int(xp, (ix_int *)ip);
#line 1034
#else
#line 1034
    ix_int xx;
#line 1034
    get_ix_int(xp, &xx);
#line 1034

#line 1034
#if IX_INT_MAX > SHORT_MAX
#line 1034
    if (xx > SHORT_MAX || xx < SHORT_MIN) {
#line 1034

#line 1034
        err = NC_ERANGE;
#line 1034
    }
#line 1034
#endif
#line 1034

#line 1034

#line 1034
    *ip = (short) xx;
#line 1034
#endif
#line 1034
    return err;
#line 1034
}
#line 1034

static int
#line 1035
ncx_get_int_long(const void *xp, long *ip)
#line 1035
{
#line 1035
    int err=NC_NOERR;
#line 1035
#if SIZEOF_IX_INT == SIZEOF_LONG && IX_INT_MAX == LONG_MAX
#line 1035
    get_ix_int(xp, (ix_int *)ip);
#line 1035
#else
#line 1035
    ix_int xx;
#line 1035
    get_ix_int(xp, &xx);
#line 1035

#line 1035
#if IX_INT_MAX > LONG_MAX
#line 1035
    if (xx > LONG_MAX || xx < LONG_MIN) {
#line 1035

#line 1035
        err = NC_ERANGE;
#line 1035
    }
#line 1035
#endif
#line 1035

#line 1035

#line 1035
    *ip = (long) xx;
#line 1035
#endif
#line 1035
    return err;
#line 1035
}
#line 1035

static int
#line 1036
ncx_get_int_longlong(const void *xp, longlong *ip)
#line 1036
{
#line 1036
    int err=NC_NOERR;
#line 1036
#if SIZEOF_IX_INT == SIZEOF_LONGLONG && IX_INT_MAX == LONGLONG_MAX
#line 1036
    get_ix_int(xp, (ix_int *)ip);
#line 1036
#else
#line 1036
    ix_int xx;
#line 1036
    get_ix_int(xp, &xx);
#line 1036

#line 1036
#if IX_INT_MAX > LONGLONG_MAX
#line 1036
    if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) {
#line 1036

#line 1036
        err = NC_ERANGE;
#line 1036
    }
#line 1036
#endif
#line 1036

#line 1036

#line 1036
    *ip = (longlong) xx;
#line 1036
#endif
#line 1036
    return err;
#line 1036
}
#line 1036

static int
#line 1037
ncx_get_int_ushort(const void *xp, ushort *ip)
#line 1037
{
#line 1037
    int err=NC_NOERR;
#line 1037
    ix_int xx;
#line 1037
    get_ix_int(xp, &xx);
#line 1037

#line 1037
#if IX_INT_MAX > USHORT_MAX
#line 1037
    if (xx > USHORT_MAX) {
#line 1037

#line 1037
        err = NC_ERANGE;
#line 1037
    }
#line 1037
#endif
#line 1037

#line 1037
    if (xx < 0) {
#line 1037

#line 1037
        err = NC_ERANGE; /* because ip is unsigned */
#line 1037
    }
#line 1037
    *ip = (ushort) xx;
#line 1037
    return err;
#line 1037
}
#line 1037

static int
#line 1038
ncx_get_int_uchar(const void *xp, uchar *ip)
#line 1038
{
#line 1038
    int err=NC_NOERR;
#line 1038
    ix_int xx;
#line 1038
    get_ix_int(xp, &xx);
#line 1038

#line 1038
#if IX_INT_MAX > UCHAR_MAX
#line 1038
    if (xx > UCHAR_MAX) {
#line 1038

#line 1038
        err = NC_ERANGE;
#line 1038
    }
#line 1038
#endif
#line 1038

#line 1038
    if (xx < 0) {
#line 1038

#line 1038
        err = NC_ERANGE; /* because ip is unsigned */
#line 1038
    }
#line 1038
    *ip = (uchar) xx;
#line 1038
    return err;
#line 1038
}
#line 1038

static int
#line 1039
ncx_get_int_uint(const void *xp, uint *ip)
#line 1039
{
#line 1039
    int err=NC_NOERR;
#line 1039
    ix_int xx;
#line 1039
    get_ix_int(xp, &xx);
#line 1039

#line 1039
#if IX_INT_MAX > UINT_MAX
#line 1039
    if (xx > UINT_MAX) {
#line 1039

#line 1039
        err = NC_ERANGE;
#line 1039
    }
#line 1039
#endif
#line 1039

#line 1039
    if (xx < 0) {
#line 1039

#line 1039
        err = NC_ERANGE; /* because ip is unsigned */
#line 1039
    }
#line 1039
    *ip = (uint) xx;
#line 1039
    return err;
#line 1039
}
#line 1039

static int
#line 1040
ncx_get_int_ulonglong(const void *xp, ulonglong *ip)
#line 1040
{
#line 1040
    int err=NC_NOERR;
#line 1040
    ix_int xx;
#line 1040
    get_ix_int(xp, &xx);
#line 1040

#line 1040
#if IX_INT_MAX > ULONGLONG_MAX
#line 1040
    if (xx > ULONGLONG_MAX) {
#line 1040

#line 1040
        err = NC_ERANGE;
#line 1040
    }
#line 1040
#endif
#line 1040

#line 1040
    if (xx < 0) {
#line 1040

#line 1040
        err = NC_ERANGE; /* because ip is unsigned */
#line 1040
    }
#line 1040
    *ip = (ulonglong) xx;
#line 1040
    return err;
#line 1040
}
#line 1040

static int
#line 1041
ncx_get_int_float(const void *xp, float *ip)
#line 1041
{
#line 1041
	ix_int xx;
#line 1041
	get_ix_int(xp, &xx);
#line 1041
	*ip = (float)xx;
#line 1041
	return NC_NOERR;
#line 1041
}
#line 1041

static int
#line 1042
ncx_get_int_double(const void *xp, double *ip)
#line 1042
{
#line 1042
	ix_int xx;
#line 1042
	get_ix_int(xp, &xx);
#line 1042
	*ip = (double)xx;
#line 1042
	return NC_NOERR;
#line 1042
}
#line 1042


static int
ncx_put_int_schar(void *xp, const schar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	if (*ip & 0x80)
	{
		*cp++ = 0xff;
		*cp++ = 0xff;
		*cp++ = 0xff;
	}
	else
	{
		*cp++ = 0x00;
		*cp++ = 0x00;
		*cp++ = 0x00;
	}
	*cp = (uchar)*ip;
	return NC_NOERR;
}

static int
ncx_put_int_uchar(void *xp, const uchar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return NC_NOERR;
}

#if X_SIZEOF_INT != SIZEOF_INT
static int
#line 1076
ncx_put_int_int(void *xp, const int *ip, void *fillp)
#line 1076
{
#line 1076
    int err=NC_NOERR;
#line 1076
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
#line 1076
    put_ix_int(xp, (const ix_int *)ip);
#line 1076
#else
#line 1076
    ix_int xx = NC_FILL_INT;
#line 1076

#line 1076
#if IX_INT_MAX < INT_MAX
#line 1076
    if (*ip > IX_INT_MAX || *ip < X_INT_MIN) {
#line 1076
        
#line 1076
        err = NC_ERANGE;
#line 1076
    } 
#line 1076
#endif
#line 1076
        xx = (ix_int)*ip;
#line 1076

#line 1076
    put_ix_int(xp, &xx);
#line 1076
#endif
#line 1076
    return err;
#line 1076
}
#line 1076

#endif
static int
#line 1078
ncx_put_int_short(void *xp, const short *ip, void *fillp)
#line 1078
{
#line 1078
    int err=NC_NOERR;
#line 1078
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
#line 1078
    put_ix_int(xp, (const ix_int *)ip);
#line 1078
#else
#line 1078
    ix_int xx = NC_FILL_INT;
#line 1078

#line 1078
#if IX_INT_MAX < SHORT_MAX
#line 1078
    if (*ip > IX_INT_MAX || *ip < X_INT_MIN) {
#line 1078
        
#line 1078
        err = NC_ERANGE;
#line 1078
    } 
#line 1078
#endif
#line 1078
        xx = (ix_int)*ip;
#line 1078

#line 1078
    put_ix_int(xp, &xx);
#line 1078
#endif
#line 1078
    return err;
#line 1078
}
#line 1078

static int
#line 1079
ncx_put_int_long(void *xp, const long *ip, void *fillp)
#line 1079
{
#line 1079
    int err=NC_NOERR;
#line 1079
#if SIZEOF_IX_INT == SIZEOF_LONG && IX_INT_MAX == LONG_MAX
#line 1079
    put_ix_int(xp, (const ix_int *)ip);
#line 1079
#else
#line 1079
    ix_int xx = NC_FILL_INT;
#line 1079

#line 1079
#if IX_INT_MAX < LONG_MAX
#line 1079
    if (*ip > IX_INT_MAX || *ip < X_INT_MIN) {
#line 1079
        
#line 1079
        err = NC_ERANGE;
#line 1079
    } 
#line 1079
#endif
#line 1079
        xx = (ix_int)*ip;
#line 1079

#line 1079
    put_ix_int(xp, &xx);
#line 1079
#endif
#line 1079
    return err;
#line 1079
}
#line 1079

static int
#line 1080
ncx_put_int_longlong(void *xp, const longlong *ip, void *fillp)
#line 1080
{
#line 1080
    int err=NC_NOERR;
#line 1080
#if SIZEOF_IX_INT == SIZEOF_LONGLONG && IX_INT_MAX == LONGLONG_MAX
#line 1080
    put_ix_int(xp, (const ix_int *)ip);
#line 1080
#else
#line 1080
    ix_int xx = NC_FILL_INT;
#line 1080

#line 1080
#if IX_INT_MAX < LONGLONG_MAX
#line 1080
    if (*ip > IX_INT_MAX || *ip < X_INT_MIN) {
#line 1080
        
#line 1080
        err = NC_ERANGE;
#line 1080
    } 
#line 1080
#endif
#line 1080
        xx = (ix_int)*ip;
#line 1080

#line 1080
    put_ix_int(xp, &xx);
#line 1080
#endif
#line 1080
    return err;
#line 1080
}
#line 1080

static int
#line 1081
ncx_put_int_ushort(void *xp, const ushort *ip, void *fillp)
#line 1081
{
#line 1081
    int err=NC_NOERR;
#line 1081
    ix_int xx = NC_FILL_INT;
#line 1081

#line 1081
#if IX_INT_MAX < USHORT_MAX
#line 1081
    if (*ip > IX_INT_MAX) {
#line 1081
        
#line 1081
        err = NC_ERANGE;
#line 1081
    } 
#line 1081
#endif
#line 1081
        xx = (ix_int)*ip;
#line 1081

#line 1081
    put_ix_int(xp, &xx);
#line 1081
    return err;
#line 1081
}
#line 1081

static int
#line 1082
ncx_put_int_uint(void *xp, const uint *ip, void *fillp)
#line 1082
{
#line 1082
    int err=NC_NOERR;
#line 1082
    ix_int xx = NC_FILL_INT;
#line 1082

#line 1082
#if IX_INT_MAX < UINT_MAX
#line 1082
    if (*ip > IX_INT_MAX) {
#line 1082
        
#line 1082
        err = NC_ERANGE;
#line 1082
    } 
#line 1082
#endif
#line 1082
        xx = (ix_int)*ip;
#line 1082

#line 1082
    put_ix_int(xp, &xx);
#line 1082
    return err;
#line 1082
}
#line 1082

static int
#line 1083
ncx_put_int_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 1083
{
#line 1083
    int err=NC_NOERR;
#line 1083
    ix_int xx = NC_FILL_INT;
#line 1083

#line 1083
#if IX_INT_MAX < ULONGLONG_MAX
#line 1083
    if (*ip > IX_INT_MAX) {
#line 1083
        
#line 1083
        err = NC_ERANGE;
#line 1083
    } 
#line 1083
#endif
#line 1083
        xx = (ix_int)*ip;
#line 1083

#line 1083
    put_ix_int(xp, &xx);
#line 1083
    return err;
#line 1083
}
#line 1083

static int
#line 1084
ncx_put_int_float(void *xp, const float *ip, void *fillp)
#line 1084
{
#line 1084
    int err=NC_NOERR;
#line 1084
    ix_int xx = NC_FILL_INT;
#line 1084

#line 1084
    if (*ip > (double)X_INT_MAX || *ip < (double)X_INT_MIN) {
#line 1084
        
#line 1084
        err = NC_ERANGE;
#line 1084
    } 
#line 1084
        xx = (ix_int)*ip;
#line 1084

#line 1084
    put_ix_int(xp, &xx);
#line 1084
    return err;
#line 1084
}
#line 1084

static int
#line 1085
ncx_put_int_double(void *xp, const double *ip, void *fillp)
#line 1085
{
#line 1085
    int err=NC_NOERR;
#line 1085
    ix_int xx = NC_FILL_INT;
#line 1085

#line 1085
    if (*ip > X_INT_MAX || *ip < X_INT_MIN) {
#line 1085
        
#line 1085
        err = NC_ERANGE;
#line 1085
    } 
#line 1085
        xx = (ix_int)*ip;
#line 1085

#line 1085
    put_ix_int(xp, &xx);
#line 1085
    return err;
#line 1085
}
#line 1085



/* external NC_UINT ---------------------------------------------------------*/

#if USHORT_MAX == X_UINT_MAX
typedef ushort ix_uint;
#define SIZEOF_IX_UINT SIZEOF_USHORT
#define IX_UINT_MAX USHORT_MAX
#elif UINT_MAX  >= X_UINT_MAX
typedef uint ix_uint;
#define SIZEOF_IX_UINT SIZEOF_UINT
#define IX_UINT_MAX UINT_MAX
#elif ULONG_MAX  >= X_UINT_MAX
typedef ulong ix_uint;
#define SIZEOF_IX_UINT SIZEOF_ULONG
#define IX_UINT_MAX ULONG_MAX
#else
#error "ix_uint implementation"
#endif


static void
get_ix_uint(const void *xp, ix_uint *ip)
{
	const uchar *cp = (const uchar *) xp;

	*ip = (ix_uint)(*cp++ << 24);
	*ip = (ix_uint)(*ip | (ix_uint)(*cp++ << 16));
	*ip = (ix_uint)(*ip | (ix_uint)(*cp++ << 8));
	*ip = (ix_uint)(*ip | *cp);
}

static void
put_ix_uint(void *xp, const ix_uint *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (uchar)((*ip) >> 24);
	*cp++ = (uchar)(((*ip) & 0x00ff0000) >> 16);
	*cp++ = (uchar)(((*ip) & 0x0000ff00) >>  8);
	*cp   = (uchar)( (*ip) & 0x000000ff);
}

#if X_SIZEOF_UINT != SIZEOF_UINT
static int
#line 1130
ncx_get_uint_uint(const void *xp, uint *ip)
#line 1130
{
#line 1130
    int err=NC_NOERR;
#line 1130
#if SIZEOF_IX_UINT == SIZEOF_UINT && IX_UINT_MAX == UINT_MAX
#line 1130
    get_ix_uint(xp, (ix_uint *)ip);
#line 1130
#else
#line 1130
    ix_uint xx;
#line 1130
    get_ix_uint(xp, &xx);
#line 1130

#line 1130
#if IX_UINT_MAX > UINT_MAX
#line 1130
    if (xx > UINT_MAX) {
#line 1130

#line 1130
        err = NC_ERANGE;
#line 1130
    }
#line 1130
#endif
#line 1130

#line 1130

#line 1130
    *ip = (uint) xx;
#line 1130
#endif
#line 1130
    return err;
#line 1130
}
#line 1130

#endif

static int
#line 1133
ncx_get_uint_schar(const void *xp, schar *ip)
#line 1133
{
#line 1133
    int err=NC_NOERR;
#line 1133
    ix_uint xx;
#line 1133
    get_ix_uint(xp, &xx);
#line 1133

#line 1133
#if IX_UINT_MAX > SCHAR_MAX
#line 1133
    if (xx > SCHAR_MAX) {
#line 1133

#line 1133
        err = NC_ERANGE;
#line 1133
    }
#line 1133
#endif
#line 1133

#line 1133

#line 1133
    *ip = (schar) xx;
#line 1133
    return err;
#line 1133
}
#line 1133

static int
#line 1134
ncx_get_uint_short(const void *xp, short *ip)
#line 1134
{
#line 1134
    int err=NC_NOERR;
#line 1134
    ix_uint xx;
#line 1134
    get_ix_uint(xp, &xx);
#line 1134

#line 1134
#if IX_UINT_MAX > SHORT_MAX
#line 1134
    if (xx > SHORT_MAX) {
#line 1134

#line 1134
        err = NC_ERANGE;
#line 1134
    }
#line 1134
#endif
#line 1134

#line 1134

#line 1134
    *ip = (short) xx;
#line 1134
    return err;
#line 1134
}
#line 1134

static int
#line 1135
ncx_get_uint_int(const void *xp, int *ip)
#line 1135
{
#line 1135
    int err=NC_NOERR;
#line 1135
    ix_uint xx;
#line 1135
    get_ix_uint(xp, &xx);
#line 1135

#line 1135
#if IX_UINT_MAX > INT_MAX
#line 1135
    if (xx > INT_MAX) {
#line 1135

#line 1135
        err = NC_ERANGE;
#line 1135
    }
#line 1135
#endif
#line 1135

#line 1135

#line 1135
    *ip = (int) xx;
#line 1135
    return err;
#line 1135
}
#line 1135

static int
#line 1136
ncx_get_uint_long(const void *xp, long *ip)
#line 1136
{
#line 1136
    int err=NC_NOERR;
#line 1136
    ix_uint xx;
#line 1136
    get_ix_uint(xp, &xx);
#line 1136

#line 1136
#if IX_UINT_MAX > LONG_MAX
#line 1136
    if (xx > LONG_MAX) {
#line 1136

#line 1136
        err = NC_ERANGE;
#line 1136
    }
#line 1136
#endif
#line 1136

#line 1136

#line 1136
    *ip = (long) xx;
#line 1136
    return err;
#line 1136
}
#line 1136

static int
#line 1137
ncx_get_uint_longlong(const void *xp, longlong *ip)
#line 1137
{
#line 1137
    int err=NC_NOERR;
#line 1137
    ix_uint xx;
#line 1137
    get_ix_uint(xp, &xx);
#line 1137

#line 1137
#if IX_UINT_MAX > LONGLONG_MAX
#line 1137
    if (xx > LONGLONG_MAX) {
#line 1137

#line 1137
        err = NC_ERANGE;
#line 1137
    }
#line 1137
#endif
#line 1137

#line 1137

#line 1137
    *ip = (longlong) xx;
#line 1137
    return err;
#line 1137
}
#line 1137

static int
#line 1138
ncx_get_uint_ushort(const void *xp, ushort *ip)
#line 1138
{
#line 1138
    int err=NC_NOERR;
#line 1138
#if SIZEOF_IX_UINT == SIZEOF_USHORT && IX_UINT_MAX == USHORT_MAX
#line 1138
    get_ix_uint(xp, (ix_uint *)ip);
#line 1138
#else
#line 1138
    ix_uint xx;
#line 1138
    get_ix_uint(xp, &xx);
#line 1138

#line 1138
#if IX_UINT_MAX > USHORT_MAX
#line 1138
    if (xx > USHORT_MAX) {
#line 1138

#line 1138
        err = NC_ERANGE;
#line 1138
    }
#line 1138
#endif
#line 1138

#line 1138

#line 1138
    *ip = (ushort) xx;
#line 1138
#endif
#line 1138
    return err;
#line 1138
}
#line 1138

static int
#line 1139
ncx_get_uint_uchar(const void *xp, uchar *ip)
#line 1139
{
#line 1139
    int err=NC_NOERR;
#line 1139
#if SIZEOF_IX_UINT == SIZEOF_UCHAR && IX_UINT_MAX == UCHAR_MAX
#line 1139
    get_ix_uint(xp, (ix_uint *)ip);
#line 1139
#else
#line 1139
    ix_uint xx;
#line 1139
    get_ix_uint(xp, &xx);
#line 1139

#line 1139
#if IX_UINT_MAX > UCHAR_MAX
#line 1139
    if (xx > UCHAR_MAX) {
#line 1139

#line 1139
        err = NC_ERANGE;
#line 1139
    }
#line 1139
#endif
#line 1139

#line 1139

#line 1139
    *ip = (uchar) xx;
#line 1139
#endif
#line 1139
    return err;
#line 1139
}
#line 1139

static int
#line 1140
ncx_get_uint_ulonglong(const void *xp, ulonglong *ip)
#line 1140
{
#line 1140
    int err=NC_NOERR;
#line 1140
#if SIZEOF_IX_UINT == SIZEOF_ULONGLONG && IX_UINT_MAX == ULONGLONG_MAX
#line 1140
    get_ix_uint(xp, (ix_uint *)ip);
#line 1140
#else
#line 1140
    ix_uint xx;
#line 1140
    get_ix_uint(xp, &xx);
#line 1140

#line 1140
#if IX_UINT_MAX > ULONGLONG_MAX
#line 1140
    if (xx > ULONGLONG_MAX) {
#line 1140

#line 1140
        err = NC_ERANGE;
#line 1140
    }
#line 1140
#endif
#line 1140

#line 1140

#line 1140
    *ip = (ulonglong) xx;
#line 1140
#endif
#line 1140
    return err;
#line 1140
}
#line 1140

static int
#line 1141
ncx_get_uint_float(const void *xp, float *ip)
#line 1141
{
#line 1141
	ix_uint xx;
#line 1141
	get_ix_uint(xp, &xx);
#line 1141
	*ip = (float)xx;
#line 1141
	return NC_NOERR;
#line 1141
}
#line 1141

static int
#line 1142
ncx_get_uint_double(const void *xp, double *ip)
#line 1142
{
#line 1142
	ix_uint xx;
#line 1142
	get_ix_uint(xp, &xx);
#line 1142
	*ip = (double)xx;
#line 1142
	return NC_NOERR;
#line 1142
}
#line 1142


static int
ncx_put_uint_schar(void *xp, const schar *ip, void *fillp)
{
    uchar *cp;
    if (*ip < 0) {
#line 1153

        return NC_ERANGE;
    }

    cp = (uchar *) xp;
    *cp++ = 0x00;
    *cp++ = 0x00;
    *cp++ = 0x00;
    *cp = (uchar)*ip;

    return NC_NOERR;
}

static int
ncx_put_uint_uchar(void *xp, const uchar *ip, void *fillp)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return NC_NOERR;
}

#if X_SIZEOF_UINT != SIZEOF_UINT
static int
#line 1178
ncx_put_uint_uint(void *xp, const uint *ip, void *fillp)
#line 1178
{
#line 1178
    int err=NC_NOERR;
#line 1178
#if SIZEOF_IX_UINT == SIZEOF_UINT && IX_UINT_MAX == UINT_MAX
#line 1178
    put_ix_uint(xp, (const ix_uint *)ip);
#line 1178
#else
#line 1178
    ix_uint xx = NC_FILL_UINT;
#line 1178

#line 1178
#if IX_UINT_MAX < UINT_MAX
#line 1178
    if (*ip > IX_UINT_MAX) {
#line 1178
        
#line 1178
        err = NC_ERANGE;
#line 1178
    } 
#line 1178
#endif
#line 1178
        xx = (ix_uint)*ip;
#line 1178

#line 1178
    put_ix_uint(xp, &xx);
#line 1178
#endif
#line 1178
    return err;
#line 1178
}
#line 1178

#endif

static int
#line 1181
ncx_put_uint_short(void *xp, const short *ip, void *fillp)
#line 1181
{
#line 1181
    int err=NC_NOERR;
#line 1181
    ix_uint xx = NC_FILL_UINT;
#line 1181

#line 1181
#if IX_UINT_MAX < SHORT_MAX
#line 1181
    if (*ip > IX_UINT_MAX) {
#line 1181
        
#line 1181
        err = NC_ERANGE;
#line 1181
    } 
#line 1181
#endif
#line 1181
    if (*ip < 0) {
#line 1181
        
#line 1181
        err = NC_ERANGE; /* because xp is unsigned */
#line 1181
    } 
#line 1181
        xx = (ix_uint)*ip;
#line 1181

#line 1181
    put_ix_uint(xp, &xx);
#line 1181
    return err;
#line 1181
}
#line 1181

static int
#line 1182
ncx_put_uint_int(void *xp, const int *ip, void *fillp)
#line 1182
{
#line 1182
    int err=NC_NOERR;
#line 1182
    ix_uint xx = NC_FILL_UINT;
#line 1182

#line 1182
#if IX_UINT_MAX < INT_MAX
#line 1182
    if (*ip > IX_UINT_MAX) {
#line 1182
        
#line 1182
        err = NC_ERANGE;
#line 1182
    } 
#line 1182
#endif
#line 1182
    if (*ip < 0) {
#line 1182
        
#line 1182
        err = NC_ERANGE; /* because xp is unsigned */
#line 1182
    } 
#line 1182
        xx = (ix_uint)*ip;
#line 1182

#line 1182
    put_ix_uint(xp, &xx);
#line 1182
    return err;
#line 1182
}
#line 1182

static int
#line 1183
ncx_put_uint_long(void *xp, const long *ip, void *fillp)
#line 1183
{
#line 1183
    int err=NC_NOERR;
#line 1183
    ix_uint xx = NC_FILL_UINT;
#line 1183

#line 1183
#if IX_UINT_MAX < LONG_MAX
#line 1183
    if (*ip > IX_UINT_MAX) {
#line 1183
        
#line 1183
        err = NC_ERANGE;
#line 1183
    } 
#line 1183
#endif
#line 1183
    if (*ip < 0) {
#line 1183
        
#line 1183
        err = NC_ERANGE; /* because xp is unsigned */
#line 1183
    } 
#line 1183
        xx = (ix_uint)*ip;
#line 1183

#line 1183
    put_ix_uint(xp, &xx);
#line 1183
    return err;
#line 1183
}
#line 1183

static int
#line 1184
ncx_put_uint_longlong(void *xp, const longlong *ip, void *fillp)
#line 1184
{
#line 1184
    int err=NC_NOERR;
#line 1184
    ix_uint xx = NC_FILL_UINT;
#line 1184

#line 1184
#if IX_UINT_MAX < LONGLONG_MAX
#line 1184
    if (*ip > IX_UINT_MAX) {
#line 1184
        
#line 1184
        err = NC_ERANGE;
#line 1184
    } 
#line 1184
#endif
#line 1184
    if (*ip < 0) {
#line 1184
        
#line 1184
        err = NC_ERANGE; /* because xp is unsigned */
#line 1184
    } 
#line 1184
        xx = (ix_uint)*ip;
#line 1184

#line 1184
    put_ix_uint(xp, &xx);
#line 1184
    return err;
#line 1184
}
#line 1184

static int
#line 1185
ncx_put_uint_ushort(void *xp, const ushort *ip, void *fillp)
#line 1185
{
#line 1185
    int err=NC_NOERR;
#line 1185
#if SIZEOF_IX_UINT == SIZEOF_USHORT && IX_UINT_MAX == USHORT_MAX
#line 1185
    put_ix_uint(xp, (const ix_uint *)ip);
#line 1185
#else
#line 1185
    ix_uint xx = NC_FILL_UINT;
#line 1185

#line 1185
#if IX_UINT_MAX < USHORT_MAX
#line 1185
    if (*ip > IX_UINT_MAX) {
#line 1185
        
#line 1185
        err = NC_ERANGE;
#line 1185
    } 
#line 1185
#endif
#line 1185
        xx = (ix_uint)*ip;
#line 1185

#line 1185
    put_ix_uint(xp, &xx);
#line 1185
#endif
#line 1185
    return err;
#line 1185
}
#line 1185

static int
#line 1186
ncx_put_uint_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 1186
{
#line 1186
    int err=NC_NOERR;
#line 1186
#if SIZEOF_IX_UINT == SIZEOF_ULONGLONG && IX_UINT_MAX == ULONGLONG_MAX
#line 1186
    put_ix_uint(xp, (const ix_uint *)ip);
#line 1186
#else
#line 1186
    ix_uint xx = NC_FILL_UINT;
#line 1186

#line 1186
#if IX_UINT_MAX < ULONGLONG_MAX
#line 1186
    if (*ip > IX_UINT_MAX) {
#line 1186
        
#line 1186
        err = NC_ERANGE;
#line 1186
    } 
#line 1186
#endif
#line 1186
        xx = (ix_uint)*ip;
#line 1186

#line 1186
    put_ix_uint(xp, &xx);
#line 1186
#endif
#line 1186
    return err;
#line 1186
}
#line 1186

static int
#line 1187
ncx_put_uint_float(void *xp, const float *ip, void *fillp)
#line 1187
{
#line 1187
    int err=NC_NOERR;
#line 1187
    ix_uint xx = NC_FILL_UINT;
#line 1187

#line 1187
    if (*ip > (double)X_UINT_MAX || *ip < 0) {
#line 1187
        
#line 1187
        err = NC_ERANGE;
#line 1187
    } 
#line 1187
        xx = (ix_uint)*ip;
#line 1187

#line 1187
    put_ix_uint(xp, &xx);
#line 1187
    return err;
#line 1187
}
#line 1187

static int
#line 1188
ncx_put_uint_double(void *xp, const double *ip, void *fillp)
#line 1188
{
#line 1188
    int err=NC_NOERR;
#line 1188
    ix_uint xx = NC_FILL_UINT;
#line 1188

#line 1188
    if (*ip > X_UINT_MAX || *ip < 0) {
#line 1188
        
#line 1188
        err = NC_ERANGE;
#line 1188
    } 
#line 1188
        xx = (ix_uint)*ip;
#line 1188

#line 1188
    put_ix_uint(xp, &xx);
#line 1188
    return err;
#line 1188
}
#line 1188



/* external NC_FLOAT --------------------------------------------------------*/

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)

inline static void
get_ix_float(const void *xp, float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, SIZEOF_FLOAT);
#else
	swap4b(ip, xp);
#endif
}

inline static void
put_ix_float(void *xp, const float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_FLOAT);
#else
	swap4b(xp, ip);
#endif
}

#elif defined(vax) && vax != 0

/* What IEEE single precision floating point looks like on a Vax */
struct	ieee_single {
	unsigned int	exp_hi       : 7;
	unsigned int	sign         : 1;
	unsigned int 	mant_hi      : 7;
	unsigned int	exp_lo       : 1;
	unsigned int	mant_lo_hi   : 8;
	unsigned int	mant_lo_lo   : 8;
};

/* Vax single precision floating point */
struct	vax_single {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
};

#define VAX_SNG_BIAS	0x81
#define IEEE_SNG_BIAS	0x7f

static struct sgl_limits {
	struct vax_single s;
	struct ieee_single ieee;
} max = {
	{ 0x7f, 0xff, 0x0, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0x1, 0x0, 0x0 }		/* Max IEEE */
};
static struct sgl_limits min = {
	{ 0x0, 0x0, 0x0, 0x0 },	/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }		/* Min IEEE */
};

#line 1302
static void
get_ix_float(const void *xp, float *ip)
{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 1305
		const struct ieee_single *const isp =
#line 1305
			 (const struct ieee_single *) xp;
#line 1305
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 1305

#line 1305
		switch(exp) {
#line 1305
		case 0 :
#line 1305
			/* ieee subnormal */
#line 1305
			if (isp->mant_hi == min.ieee.mant_hi
#line 1305
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 1305
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 1305
			{
#line 1305
				*vsp = min.s;
#line 1305
			}
#line 1305
			else
#line 1305
			{
#line 1305
				unsigned mantissa = (isp->mant_hi << 16)
#line 1305
					 | isp->mant_lo_hi << 8
#line 1305
					 | isp->mant_lo_lo;
#line 1305
				unsigned tmp = mantissa >> 20;
#line 1305
				if (tmp >= 4) {
#line 1305
					vsp->exp = 2;
#line 1305
				} else if (tmp >= 2) {
#line 1305
					vsp->exp = 1;
#line 1305
				} else {
#line 1305
					*vsp = min.s;
#line 1305
					break;
#line 1305
				} /* else */
#line 1305
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 1305
				tmp <<= 3 - vsp->exp;
#line 1305
				vsp->mantissa2 = tmp;
#line 1305
				vsp->mantissa1 = (tmp >> 16);
#line 1305
			}
#line 1305
			break;
#line 1305
		case 0xfe :
#line 1305
		case 0xff :
#line 1305
			*vsp = max.s;
#line 1305
			break;
#line 1305
		default :
#line 1305
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 1305
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 1305
			vsp->mantissa1 = isp->mant_hi;
#line 1305
		}
#line 1305

#line 1305
		vsp->sign = isp->sign;
#line 1305

}

#line 1359

static void
put_ix_float(void *xp, const float *ip)
{
		const struct vax_single *const vsp =
#line 1363
			 (const struct vax_single *)ip;
#line 1363
		struct ieee_single *const isp = (struct ieee_single *) xp;
#line 1363

#line 1363
		switch(vsp->exp){
#line 1363
		case 0 :
#line 1363
			/* all vax float with zero exponent map to zero */
#line 1363
			*isp = min.ieee;
#line 1363
			break;
#line 1363
		case 2 :
#line 1363
		case 1 :
#line 1363
		{
#line 1363
			/* These will map to subnormals */
#line 1363
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 1363
					 | vsp->mantissa2;
#line 1363
			mantissa >>= 3 - vsp->exp;
#line 1363
			mantissa += (1 << (20 + vsp->exp));
#line 1363
			isp->mant_lo_lo = mantissa;
#line 1363
			isp->mant_lo_hi = mantissa >> 8;
#line 1363
			isp->mant_hi = mantissa >> 16;
#line 1363
			isp->exp_lo = 0;
#line 1363
			isp->exp_hi = 0;
#line 1363
		}
#line 1363
			break;
#line 1363
		case 0xff : /* max.s.exp */
#line 1363
			if (vsp->mantissa2 == max.s.mantissa2 &&
#line 1363
			    vsp->mantissa1 == max.s.mantissa1)
#line 1363
			{
#line 1363
				/* map largest vax float to ieee infinity */
#line 1363
				*isp = max.ieee;
#line 1363
				break;
#line 1363
			} /* else, fall thru */
#line 1363
		default :
#line 1363
		{
#line 1363
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 1363
			isp->exp_hi = exp >> 1;
#line 1363
			isp->exp_lo = exp;
#line 1363
			isp->mant_lo_lo = vsp->mantissa2;
#line 1363
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 1363
			isp->mant_hi = vsp->mantissa1;
#line 1363
		}
#line 1363
		}
#line 1363

#line 1363
		isp->sign = vsp->sign;
#line 1363

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

/*
 * Return the number of bytes until the next "word" boundary
 * N.B. This is based on the very weird YMP address structure,
 * which puts the address within a word in the leftmost 3 bits
 * of the address.
 */
static size_t
word_align(const void *vp)
{
	const size_t rem = ((size_t)vp >> (64 - 3)) & 0x7;
	return (rem != 0);
}

struct ieee_single_hi {
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
	unsigned int	pad	:32;
};
typedef struct ieee_single_hi ieee_single_hi;

struct ieee_single_lo {
	unsigned int	pad	:32;
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
};
typedef struct ieee_single_lo ieee_single_lo;

static const int ieee_single_bias = 0x7f;

struct ieee_double {
	unsigned int	sign	: 1;
	unsigned int	 exp	:11;
	unsigned int	mant	:52;
};
typedef struct ieee_double ieee_double;

static const int ieee_double_bias = 0x3ff;

#if defined(NO_IEEE_FLOAT)

struct cray_single {
	unsigned int	sign	: 1;
	unsigned int	 exp	:15;
	unsigned int	mant	:48;
};
typedef struct cray_single cray_single;

static const int cs_ieis_bias = 0x4000 - 0x7f;

static const int cs_id_bias = 0x4000 - 0x3ff;

#line 1498

static void
get_ix_float(const void *xp, float *ip)
{

	if (word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1506

#line 1506
		if (isp->exp == 0)
#line 1506
		{
#line 1506
			/* ieee subnormal */
#line 1506
			*ip = (double)isp->mant;
#line 1506
			if (isp->mant != 0)
#line 1506
			{
#line 1506
				csp->exp -= (ieee_single_bias + 22);
#line 1506
			}
#line 1506
		}
#line 1506
		else
#line 1506
		{
#line 1506
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1506
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1506
			csp->mant |= (1 << (48 - 1));
#line 1506
		}
#line 1506
		csp->sign = isp->sign;
#line 1506

#line 1506

	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1511

#line 1511
		if (isp->exp == 0)
#line 1511
		{
#line 1511
			/* ieee subnormal */
#line 1511
			*ip = (double)isp->mant;
#line 1511
			if (isp->mant != 0)
#line 1511
			{
#line 1511
				csp->exp -= (ieee_single_bias + 22);
#line 1511
			}
#line 1511
		}
#line 1511
		else
#line 1511
		{
#line 1511
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1511
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1511
			csp->mant |= (1 << (48 - 1));
#line 1511
		}
#line 1511
		csp->sign = isp->sign;
#line 1511

#line 1511

	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	if (word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1521
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1521

#line 1521
	isp->sign = csp->sign;
#line 1521

#line 1521
	if (ieee_exp >= 0xff)
#line 1521
	{
#line 1521
		/* NC_ERANGE => ieee Inf */
#line 1521
		isp->exp = 0xff;
#line 1521
		isp->mant = 0x0;
#line 1521
	}
#line 1521
	else if (ieee_exp > 0)
#line 1521
	{
#line 1521
		/* normal ieee representation */
#line 1521
		isp->exp  = ieee_exp;
#line 1521
		/* assumes cray rep is in normal form */
#line 1521
		assert(csp->mant & 0x800000000000);
#line 1521
		isp->mant = (((csp->mant << 1) &
#line 1521
				0xffffffffffff) >> (48 - 23));
#line 1521
	}
#line 1521
	else if (ieee_exp > -23)
#line 1521
	{
#line 1521
		/* ieee subnormal, right shift */
#line 1521
		const int rshift = (48 - 23 - ieee_exp);
#line 1521

#line 1521
		isp->mant = csp->mant >> rshift;
#line 1521

#line 1521
#if 0
#line 1521
		if (csp->mant & (1 << (rshift -1)))
#line 1521
		{
#line 1521
			/* round up */
#line 1521
			isp->mant++;
#line 1521
		}
#line 1521
#endif
#line 1521

#line 1521
		isp->exp  = 0;
#line 1521
	}
#line 1521
	else
#line 1521
	{
#line 1521
		/* smaller than ieee can represent */
#line 1521
		isp->exp = 0;
#line 1521
		isp->mant = 0;
#line 1521
	}
#line 1521

	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1526
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1526

#line 1526
	isp->sign = csp->sign;
#line 1526

#line 1526
	if (ieee_exp >= 0xff)
#line 1526
	{
#line 1526
		/* NC_ERANGE => ieee Inf */
#line 1526
		isp->exp = 0xff;
#line 1526
		isp->mant = 0x0;
#line 1526
	}
#line 1526
	else if (ieee_exp > 0)
#line 1526
	{
#line 1526
		/* normal ieee representation */
#line 1526
		isp->exp  = ieee_exp;
#line 1526
		/* assumes cray rep is in normal form */
#line 1526
		assert(csp->mant & 0x800000000000);
#line 1526
		isp->mant = (((csp->mant << 1) &
#line 1526
				0xffffffffffff) >> (48 - 23));
#line 1526
	}
#line 1526
	else if (ieee_exp > -23)
#line 1526
	{
#line 1526
		/* ieee subnormal, right shift */
#line 1526
		const int rshift = (48 - 23 - ieee_exp);
#line 1526

#line 1526
		isp->mant = csp->mant >> rshift;
#line 1526

#line 1526
#if 0
#line 1526
		if (csp->mant & (1 << (rshift -1)))
#line 1526
		{
#line 1526
			/* round up */
#line 1526
			isp->mant++;
#line 1526
		}
#line 1526
#endif
#line 1526

#line 1526
		isp->exp  = 0;
#line 1526
	}
#line 1526
	else
#line 1526
	{
#line 1526
		/* smaller than ieee can represent */
#line 1526
		isp->exp = 0;
#line 1526
		isp->mant = 0;
#line 1526
	}
#line 1526

	}
}

#else
	/* IEEE Cray with only doubles */
static void
get_ix_float(const void *xp, float *ip)
{

	ieee_double *idp = (ieee_double *) ip;

	if (word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		if (isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		if (isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	const ieee_double *idp = (const ieee_double *) ip;
	if (word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
		if (idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
		if (idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
}
#endif

#else
#error "ix_float implementation"
#endif

#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
static int
ncx_get_float_float(const void *xp, float *ip, void *fillp)
{
	/* TODO */
	get_ix_float(xp, ip);
	return NC_NOERR;
}
#endif

#define ix_float float

static int
#line 1613
ncx_get_float_schar(const void *xp, schar *ip)
#line 1613
{
#line 1613
	ix_float xx;
#line 1613
	get_ix_float(xp, &xx);
#line 1613
	if (xx > (double)SCHAR_MAX || xx < (double)SCHAR_MIN) {
#line 1613
            
#line 1613
            return NC_ERANGE;
#line 1613
        }
#line 1613
	*ip = (schar)xx;
#line 1613
	return NC_NOERR;
#line 1613
}
#line 1613

static int
#line 1614
ncx_get_float_short(const void *xp, short *ip)
#line 1614
{
#line 1614
	ix_float xx;
#line 1614
	get_ix_float(xp, &xx);
#line 1614
	if (xx > (double)SHORT_MAX || xx < (double)SHORT_MIN) {
#line 1614
            
#line 1614
            return NC_ERANGE;
#line 1614
        }
#line 1614
	*ip = (short)xx;
#line 1614
	return NC_NOERR;
#line 1614
}
#line 1614

static int
#line 1615
ncx_get_float_int(const void *xp, int *ip)
#line 1615
{
#line 1615
	ix_float xx;
#line 1615
	get_ix_float(xp, &xx);
#line 1615
	if (xx > (double)INT_MAX || xx < (double)INT_MIN) {
#line 1615
            
#line 1615
            return NC_ERANGE;
#line 1615
        }
#line 1615
	*ip = (int)xx;
#line 1615
	return NC_NOERR;
#line 1615
}
#line 1615

static int
#line 1616
ncx_get_float_long(const void *xp, long *ip)
#line 1616
{
#line 1616
	ix_float xx;
#line 1616
	get_ix_float(xp, &xx);
#line 1616
	if (xx > (double)LONG_MAX || xx < (double)LONG_MIN) {
#line 1616
            
#line 1616
            return NC_ERANGE;
#line 1616
        }
#line 1616
	*ip = (long)xx;
#line 1616
	return NC_NOERR;
#line 1616
}
#line 1616

static int
#line 1617
ncx_get_float_double(const void *xp, double *ip)
#line 1617
{
#line 1617
	ix_float xx;
#line 1617
	get_ix_float(xp, &xx);
#line 1617
	*ip = (double)xx;
#line 1617
	return NC_NOERR;
#line 1617
}
#line 1617

static int
#line 1618
ncx_get_float_longlong(const void *xp, longlong *ip)
#line 1618
{
#line 1618
	ix_float xx;
#line 1618
	get_ix_float(xp, &xx);
#line 1618
	if (xx == LONGLONG_MAX)      *ip = LONGLONG_MAX;
#line 1618
	else if (xx == LONGLONG_MIN) *ip = LONGLONG_MIN;
#line 1618
	else if (xx > (double)LONGLONG_MAX || xx < (double)LONGLONG_MIN) {
#line 1618
            
#line 1618
            return NC_ERANGE;
#line 1618
        }
#line 1618
	else *ip = (longlong)xx;
#line 1618
	return NC_NOERR;
#line 1618
}
#line 1618

static int
#line 1619
ncx_get_float_uchar(const void *xp, uchar *ip)
#line 1619
{
#line 1619
	ix_float xx;
#line 1619
	get_ix_float(xp, &xx);
#line 1619
	if (xx > (double)UCHAR_MAX || xx < 0) {
#line 1619
            
#line 1619
            return NC_ERANGE;
#line 1619
        }
#line 1619
	*ip = (uchar)xx;
#line 1619
	return NC_NOERR;
#line 1619
}
#line 1619

static int
#line 1620
ncx_get_float_ushort(const void *xp, ushort *ip)
#line 1620
{
#line 1620
	ix_float xx;
#line 1620
	get_ix_float(xp, &xx);
#line 1620
	if (xx > (double)USHORT_MAX || xx < 0) {
#line 1620
            
#line 1620
            return NC_ERANGE;
#line 1620
        }
#line 1620
	*ip = (ushort)xx;
#line 1620
	return NC_NOERR;
#line 1620
}
#line 1620

static int
#line 1621
ncx_get_float_uint(const void *xp, uint *ip)
#line 1621
{
#line 1621
	ix_float xx;
#line 1621
	get_ix_float(xp, &xx);
#line 1621
	if (xx > (double)UINT_MAX || xx < 0) {
#line 1621
            
#line 1621
            return NC_ERANGE;
#line 1621
        }
#line 1621
	*ip = (uint)xx;
#line 1621
	return NC_NOERR;
#line 1621
}
#line 1621

static int
#line 1622
ncx_get_float_ulonglong(const void *xp, ulonglong *ip)
#line 1622
{
#line 1622
	ix_float xx;
#line 1622
	get_ix_float(xp, &xx);
#line 1622
	if (xx == ULONGLONG_MAX)      *ip = ULONGLONG_MAX;
#line 1622
	else if (xx > (double)ULONGLONG_MAX || xx < 0) {
#line 1622
            
#line 1622
            return NC_ERANGE;
#line 1622
        }
#line 1622
	else *ip = (ulonglong)xx;
#line 1622
	return NC_NOERR;
#line 1622
}
#line 1622


#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
static int
ncx_put_float_float(void *xp, const float *ip, void *fillp)
{
    int err=NC_NOERR;
    float *_ip=ip;
#ifdef NO_IEEE_FLOAT
    
    if (*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN) {
        
        
        err = NC_ERANGE;
    }
#endif
    put_ix_float(xp, _ip);
    return err;
}
#endif

static int
#line 1643
ncx_put_float_schar(void *xp, const schar *ip, void *fillp)
#line 1643
{
#line 1643
    int err=NC_NOERR;
#line 1643
    ix_float xx = NC_FILL_FLOAT;
#line 1643

#line 1643
    
#line 1643
        xx = (ix_float)*ip;
#line 1643

#line 1643
    put_ix_float(xp, &xx);
#line 1643
    return err;
#line 1643
}
#line 1643

static int
#line 1644
ncx_put_float_short(void *xp, const short *ip, void *fillp)
#line 1644
{
#line 1644
    int err=NC_NOERR;
#line 1644
    ix_float xx = NC_FILL_FLOAT;
#line 1644

#line 1644
    
#line 1644
        xx = (ix_float)*ip;
#line 1644

#line 1644
    put_ix_float(xp, &xx);
#line 1644
    return err;
#line 1644
}
#line 1644

static int
#line 1645
ncx_put_float_int(void *xp, const int *ip, void *fillp)
#line 1645
{
#line 1645
    int err=NC_NOERR;
#line 1645
    ix_float xx = NC_FILL_FLOAT;
#line 1645

#line 1645
    
#line 1645
        xx = (ix_float)*ip;
#line 1645

#line 1645
    put_ix_float(xp, &xx);
#line 1645
    return err;
#line 1645
}
#line 1645

static int
#line 1646
ncx_put_float_long(void *xp, const long *ip, void *fillp)
#line 1646
{
#line 1646
    int err=NC_NOERR;
#line 1646
    ix_float xx = NC_FILL_FLOAT;
#line 1646

#line 1646
    
#line 1646
        xx = (ix_float)*ip;
#line 1646

#line 1646
    put_ix_float(xp, &xx);
#line 1646
    return err;
#line 1646
}
#line 1646

static int
#line 1647
ncx_put_float_double(void *xp, const double *ip, void *fillp)
#line 1647
{
#line 1647
    int err=NC_NOERR;
#line 1647
    ix_float xx = NC_FILL_FLOAT;
#line 1647

#line 1647
    if (*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN) {
#line 1647
        
#line 1647
        err = NC_ERANGE;
#line 1647
    } 
#line 1647
        xx = (ix_float)*ip;
#line 1647

#line 1647
    put_ix_float(xp, &xx);
#line 1647
    return err;
#line 1647
}
#line 1647

static int
#line 1648
ncx_put_float_longlong(void *xp, const longlong *ip, void *fillp)
#line 1648
{
#line 1648
    int err=NC_NOERR;
#line 1648
    ix_float xx = NC_FILL_FLOAT;
#line 1648

#line 1648
    
#line 1648
        xx = (ix_float)*ip;
#line 1648

#line 1648
    put_ix_float(xp, &xx);
#line 1648
    return err;
#line 1648
}
#line 1648

static int
#line 1649
ncx_put_float_uchar(void *xp, const uchar *ip, void *fillp)
#line 1649
{
#line 1649
    int err=NC_NOERR;
#line 1649
    ix_float xx = NC_FILL_FLOAT;
#line 1649

#line 1649
    
#line 1649
        xx = (ix_float)*ip;
#line 1649

#line 1649
    put_ix_float(xp, &xx);
#line 1649
    return err;
#line 1649
}
#line 1649

static int
#line 1650
ncx_put_float_ushort(void *xp, const ushort *ip, void *fillp)
#line 1650
{
#line 1650
    int err=NC_NOERR;
#line 1650
    ix_float xx = NC_FILL_FLOAT;
#line 1650

#line 1650
    
#line 1650
        xx = (ix_float)*ip;
#line 1650

#line 1650
    put_ix_float(xp, &xx);
#line 1650
    return err;
#line 1650
}
#line 1650

static int
#line 1651
ncx_put_float_uint(void *xp, const uint *ip, void *fillp)
#line 1651
{
#line 1651
    int err=NC_NOERR;
#line 1651
    ix_float xx = NC_FILL_FLOAT;
#line 1651

#line 1651
    
#line 1651
        xx = (ix_float)*ip;
#line 1651

#line 1651
    put_ix_float(xp, &xx);
#line 1651
    return err;
#line 1651
}
#line 1651

static int
#line 1652
ncx_put_float_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 1652
{
#line 1652
    int err=NC_NOERR;
#line 1652
    ix_float xx = NC_FILL_FLOAT;
#line 1652

#line 1652
    
#line 1652
        xx = (ix_float)*ip;
#line 1652

#line 1652
    put_ix_float(xp, &xx);
#line 1652
    return err;
#line 1652
}
#line 1652



/* external NC_DOUBLE -------------------------------------------------------*/

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE  && !defined(NO_IEEE_FLOAT)

static void
get_ix_double(const void *xp, double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, SIZEOF_DOUBLE);
#else
	swap8b(ip, xp);
#endif
}

static void
put_ix_double(void *xp, const double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_DOUBLE);
#else
	swap8b(xp, ip);
#endif
}

#elif defined(vax) && vax != 0

/* What IEEE double precision floating point looks like on a Vax */
struct	ieee_double {
	unsigned int	exp_hi   : 7;
	unsigned int	sign     : 1;
	unsigned int 	mant_6   : 4;
	unsigned int	exp_lo   : 4;
	unsigned int	mant_5   : 8;
	unsigned int	mant_4   : 8;

	unsigned int	mant_lo  : 32;
};

/* Vax double precision floating point */
struct  vax_double {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
	unsigned int	mantissa3 : 16;
	unsigned int	mantissa4 : 16;
};

#define VAX_DBL_BIAS	0x81
#define IEEE_DBL_BIAS	0x3ff
#define MASK(nbits)	((1 << nbits) - 1)

static const struct dbl_limits {
	struct	vax_double d;
	struct	ieee_double ieee;
} dbl_limits[2] = {
	{{ 0x7f, 0xff, 0x0, 0xffff, 0xffff, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0}}, /* Max IEEE */
	{{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},		/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}, /* Min IEEE */
};


#line 1766
static void
get_ix_double(const void *xp, double *ip)
{
	struct vax_double *const vdp =
#line 1769
			 (struct vax_double *)ip;
#line 1769
	const struct ieee_double *const idp =
#line 1769
			 (const struct ieee_double *) xp;
#line 1769
	{
#line 1769
		const struct dbl_limits *lim;
#line 1769
		int ii;
#line 1769
		for (ii = 0, lim = dbl_limits;
#line 1769
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 1769
			ii++, lim++)
#line 1769
		{
#line 1769
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 1769
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 1769
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 1769
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 1769
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 1769
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 1769
				)
#line 1769
			{
#line 1769
				*vdp = lim->d;
#line 1769
				goto doneit;
#line 1769
			}
#line 1769
		}
#line 1769
	}
#line 1769
	{
#line 1769
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 1769
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 1769
	}
#line 1769
	{
#line 1769
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 1769
				 | (idp->mant_5 << 8)
#line 1769
				 | idp->mant_4);
#line 1769
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 1769
		vdp->mantissa1 = (mant_hi >> 13);
#line 1769
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 1769
				| (mant_lo >> 29);
#line 1769
		vdp->mantissa3 = (mant_lo >> 13);
#line 1769
		vdp->mantissa4 = (mant_lo << 3);
#line 1769
	}
#line 1769
	doneit:
#line 1769
		vdp->sign = idp->sign;
#line 1769

}


#line 1839
static void
put_ix_double(void *xp, const double *ip)
{
	const struct vax_double *const vdp =
#line 1842
			(const struct vax_double *)ip;
#line 1842
	struct ieee_double *const idp =
#line 1842
			 (struct ieee_double *) xp;
#line 1842

#line 1842
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 1842
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 1842
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 1842
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 1842
		(vdp->exp == dbl_limits[0].d.exp))
#line 1842
	{
#line 1842
		*idp = dbl_limits[0].ieee;
#line 1842
		goto shipit;
#line 1842
	}
#line 1842
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 1842
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 1842
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 1842
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 1842
		(vdp->exp == dbl_limits[1].d.exp))
#line 1842
	{
#line 1842
		*idp = dbl_limits[1].ieee;
#line 1842
		goto shipit;
#line 1842
	}
#line 1842

#line 1842
	{
#line 1842
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 1842

#line 1842
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 1842
			(vdp->mantissa3 << 13) |
#line 1842
			((vdp->mantissa4 >> 3) & MASK(13));
#line 1842

#line 1842
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 1842
				 | (vdp->mantissa2 >> 3);
#line 1842

#line 1842
		if ((vdp->mantissa4 & 7) > 4)
#line 1842
		{
#line 1842
			/* round up */
#line 1842
			mant_lo++;
#line 1842
			if (mant_lo == 0)
#line 1842
			{
#line 1842
				mant_hi++;
#line 1842
				if (mant_hi > 0xffffff)
#line 1842
				{
#line 1842
					mant_hi = 0;
#line 1842
					exp++;
#line 1842
				}
#line 1842
			}
#line 1842
		}
#line 1842

#line 1842
		idp->mant_lo = SWAP4(mant_lo);
#line 1842
		idp->mant_6 = mant_hi >> 16;
#line 1842
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 1842
		idp->mant_4 = mant_hi;
#line 1842
		idp->exp_hi = exp >> 4;
#line 1842
		idp->exp_lo = exp;
#line 1842
	}
#line 1842

#line 1842
	shipit:
#line 1842
		idp->sign = vdp->sign;
#line 1842

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

static void
get_ix_double(const void *xp, double *ip)
{
	const ieee_double *idp = (const ieee_double *) xp;
	cray_single *csp = (cray_single *) ip;

	if (idp->exp == 0)
	{
		/* ieee subnormal */
		*ip = (double)idp->mant;
		if (idp->mant != 0)
		{
			csp->exp -= (ieee_double_bias + 51);
		}
	}
	else
	{
		csp->exp  = idp->exp + cs_id_bias + 1;
		csp->mant = idp->mant >> (52 - 48 + 1);
		csp->mant |= (1 << (48 - 1));
	}
	csp->sign = idp->sign;
}

static void
put_ix_double(void *xp, const double *ip)
{
	ieee_double *idp = (ieee_double *) xp;
	const cray_single *csp = (const cray_single *) ip;

	int ieee_exp = csp->exp - cs_id_bias -1;

	idp->sign = csp->sign;

	if (ieee_exp >= 0x7ff)
	{
		/* NC_ERANGE => ieee Inf */
		idp->exp = 0x7ff;
		idp->mant = 0x0;
	}
	else if (ieee_exp > 0)
	{
		/* normal ieee representation */
		idp->exp  = ieee_exp;
		/* assumes cray rep is in normal form */
		assert(csp->mant & 0x800000000000);
		idp->mant = (((csp->mant << 1) &
				0xffffffffffff) << (52 - 48));
	}
	else if (ieee_exp >= (-(52 -48)))
	{
		/* ieee subnormal, left shift */
		const int lshift = (52 - 48) + ieee_exp;
		idp->mant = csp->mant << lshift;
		idp->exp  = 0;
	}
	else if (ieee_exp >= -52)
	{
		/* ieee subnormal, right shift */
		const int rshift = (- (52 - 48) - ieee_exp);

		idp->mant = csp->mant >> rshift;

#if 0
		if (csp->mant & (1 << (rshift -1)))
		{
			/* round up */
			idp->mant++;
		}
#endif

		idp->exp  = 0;
	}
	else
	{
		/* smaller than ieee can represent */
		idp->exp = 0;
		idp->mant = 0;
	}
}
#else
#error "ix_double implementation"
#endif

#define ix_double double

static int
#line 1934
ncx_get_double_schar(const void *xp, schar *ip)
#line 1934
{
#line 1934
	ix_double xx;
#line 1934
	get_ix_double(xp, &xx);
#line 1934
	if (xx > (double)SCHAR_MAX || xx < (double)SCHAR_MIN) {
#line 1934
            
#line 1934
            return NC_ERANGE;
#line 1934
        }
#line 1934
	*ip = (schar)xx;
#line 1934
	return NC_NOERR;
#line 1934
}
#line 1934

static int
#line 1935
ncx_get_double_short(const void *xp, short *ip)
#line 1935
{
#line 1935
	ix_double xx;
#line 1935
	get_ix_double(xp, &xx);
#line 1935
	if (xx > (double)SHORT_MAX || xx < (double)SHORT_MIN) {
#line 1935
            
#line 1935
            return NC_ERANGE;
#line 1935
        }
#line 1935
	*ip = (short)xx;
#line 1935
	return NC_NOERR;
#line 1935
}
#line 1935

static int
#line 1936
ncx_get_double_int(const void *xp, int *ip)
#line 1936
{
#line 1936
	ix_double xx;
#line 1936
	get_ix_double(xp, &xx);
#line 1936
	if (xx > (double)INT_MAX || xx < (double)INT_MIN) {
#line 1936
            
#line 1936
            return NC_ERANGE;
#line 1936
        }
#line 1936
	*ip = (int)xx;
#line 1936
	return NC_NOERR;
#line 1936
}
#line 1936

static int
#line 1937
ncx_get_double_long(const void *xp, long *ip)
#line 1937
{
#line 1937
	ix_double xx;
#line 1937
	get_ix_double(xp, &xx);
#line 1937
	if (xx > (double)LONG_MAX || xx < (double)LONG_MIN) {
#line 1937
            
#line 1937
            return NC_ERANGE;
#line 1937
        }
#line 1937
	*ip = (long)xx;
#line 1937
	return NC_NOERR;
#line 1937
}
#line 1937

static int
#line 1938
ncx_get_double_longlong(const void *xp, longlong *ip)
#line 1938
{
#line 1938
	ix_double xx;
#line 1938
	get_ix_double(xp, &xx);
#line 1938
	if (xx == LONGLONG_MAX)      *ip = LONGLONG_MAX;
#line 1938
	else if (xx == LONGLONG_MIN) *ip = LONGLONG_MIN;
#line 1938
	else if (xx > (double)LONGLONG_MAX || xx < (double)LONGLONG_MIN) {
#line 1938
            
#line 1938
            return NC_ERANGE;
#line 1938
        }
#line 1938
	else *ip = (longlong)xx;
#line 1938
	return NC_NOERR;
#line 1938
}
#line 1938

static int
#line 1939
ncx_get_double_uchar(const void *xp, uchar *ip)
#line 1939
{
#line 1939
	ix_double xx;
#line 1939
	get_ix_double(xp, &xx);
#line 1939
	if (xx > (double)UCHAR_MAX || xx < 0) {
#line 1939
            
#line 1939
            return NC_ERANGE;
#line 1939
        }
#line 1939
	*ip = (uchar)xx;
#line 1939
	return NC_NOERR;
#line 1939
}
#line 1939

static int
#line 1940
ncx_get_double_ushort(const void *xp, ushort *ip)
#line 1940
{
#line 1940
	ix_double xx;
#line 1940
	get_ix_double(xp, &xx);
#line 1940
	if (xx > (double)USHORT_MAX || xx < 0) {
#line 1940
            
#line 1940
            return NC_ERANGE;
#line 1940
        }
#line 1940
	*ip = (ushort)xx;
#line 1940
	return NC_NOERR;
#line 1940
}
#line 1940

static int
#line 1941
ncx_get_double_uint(const void *xp, uint *ip)
#line 1941
{
#line 1941
	ix_double xx;
#line 1941
	get_ix_double(xp, &xx);
#line 1941
	if (xx > (double)UINT_MAX || xx < 0) {
#line 1941
            
#line 1941
            return NC_ERANGE;
#line 1941
        }
#line 1941
	*ip = (uint)xx;
#line 1941
	return NC_NOERR;
#line 1941
}
#line 1941

static int
#line 1942
ncx_get_double_ulonglong(const void *xp, ulonglong *ip)
#line 1942
{
#line 1942
	ix_double xx;
#line 1942
	get_ix_double(xp, &xx);
#line 1942
	if (xx == ULONGLONG_MAX)      *ip = ULONGLONG_MAX;
#line 1942
	else if (xx > (double)ULONGLONG_MAX || xx < 0) {
#line 1942
            
#line 1942
            return NC_ERANGE;
#line 1942
        }
#line 1942
	else *ip = (ulonglong)xx;
#line 1942
	return NC_NOERR;
#line 1942
}
#line 1942


static int
ncx_get_double_float(const void *xp, float *ip)
{
    double xx;
    get_ix_double(xp, &xx);
    if (xx > FLT_MAX) {
        *ip = FLT_MAX;
        return NC_ERANGE;
    }
    if (xx < (-FLT_MAX)) {
        *ip = (-FLT_MAX);
        return NC_ERANGE;
    }
    *ip = (float) xx;
    return NC_NOERR;
}

#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
static int
ncx_get_double_double(const void *xp, double *ip, void *fillp)
{
	/* TODO */
	get_ix_double(xp, ip);
	return NC_NOERR;
}
#endif

static int
#line 1971
ncx_put_double_schar(void *xp, const schar *ip, void *fillp)
#line 1971
{
#line 1971
    int err=NC_NOERR;
#line 1971
    ix_double xx = NC_FILL_DOUBLE;
#line 1971

#line 1971
    
#line 1971
        xx = (ix_double)*ip;
#line 1971

#line 1971
    put_ix_double(xp, &xx);
#line 1971
    return err;
#line 1971
}
#line 1971

static int
#line 1972
ncx_put_double_uchar(void *xp, const uchar *ip, void *fillp)
#line 1972
{
#line 1972
    int err=NC_NOERR;
#line 1972
    ix_double xx = NC_FILL_DOUBLE;
#line 1972

#line 1972
    
#line 1972
        xx = (ix_double)*ip;
#line 1972

#line 1972
    put_ix_double(xp, &xx);
#line 1972
    return err;
#line 1972
}
#line 1972

static int
#line 1973
ncx_put_double_short(void *xp, const short *ip, void *fillp)
#line 1973
{
#line 1973
    int err=NC_NOERR;
#line 1973
    ix_double xx = NC_FILL_DOUBLE;
#line 1973

#line 1973
    
#line 1973
        xx = (ix_double)*ip;
#line 1973

#line 1973
    put_ix_double(xp, &xx);
#line 1973
    return err;
#line 1973
}
#line 1973

static int
#line 1974
ncx_put_double_ushort(void *xp, const ushort *ip, void *fillp)
#line 1974
{
#line 1974
    int err=NC_NOERR;
#line 1974
    ix_double xx = NC_FILL_DOUBLE;
#line 1974

#line 1974
    
#line 1974
        xx = (ix_double)*ip;
#line 1974

#line 1974
    put_ix_double(xp, &xx);
#line 1974
    return err;
#line 1974
}
#line 1974

static int
#line 1975
ncx_put_double_int(void *xp, const int *ip, void *fillp)
#line 1975
{
#line 1975
    int err=NC_NOERR;
#line 1975
    ix_double xx = NC_FILL_DOUBLE;
#line 1975

#line 1975
    
#line 1975
        xx = (ix_double)*ip;
#line 1975

#line 1975
    put_ix_double(xp, &xx);
#line 1975
    return err;
#line 1975
}
#line 1975

static int
#line 1976
ncx_put_double_long(void *xp, const long *ip, void *fillp)
#line 1976
{
#line 1976
    int err=NC_NOERR;
#line 1976
    ix_double xx = NC_FILL_DOUBLE;
#line 1976

#line 1976
    
#line 1976
        xx = (ix_double)*ip;
#line 1976

#line 1976
    put_ix_double(xp, &xx);
#line 1976
    return err;
#line 1976
}
#line 1976

static int
#line 1977
ncx_put_double_uint(void *xp, const uint *ip, void *fillp)
#line 1977
{
#line 1977
    int err=NC_NOERR;
#line 1977
    ix_double xx = NC_FILL_DOUBLE;
#line 1977

#line 1977
    
#line 1977
        xx = (ix_double)*ip;
#line 1977

#line 1977
    put_ix_double(xp, &xx);
#line 1977
    return err;
#line 1977
}
#line 1977

static int
#line 1978
ncx_put_double_longlong(void *xp, const longlong *ip, void *fillp)
#line 1978
{
#line 1978
    int err=NC_NOERR;
#line 1978
    ix_double xx = NC_FILL_DOUBLE;
#line 1978

#line 1978
    
#line 1978
        xx = (ix_double)*ip;
#line 1978

#line 1978
    put_ix_double(xp, &xx);
#line 1978
    return err;
#line 1978
}
#line 1978

static int
#line 1979
ncx_put_double_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 1979
{
#line 1979
    int err=NC_NOERR;
#line 1979
    ix_double xx = NC_FILL_DOUBLE;
#line 1979

#line 1979
    
#line 1979
        xx = (ix_double)*ip;
#line 1979

#line 1979
    put_ix_double(xp, &xx);
#line 1979
    return err;
#line 1979
}
#line 1979


static int
ncx_put_double_float(void *xp, const float *ip, void *fillp)
{
    int err=NC_NOERR;
    double xx = NC_FILL_DOUBLE;
#if 1	/* TODO: figure this out (if condition below will never be true)*/
    if ((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN) {
        
        err = NC_ERANGE;
    } 
#endif
        xx = (double) *ip;

    put_ix_double(xp, &xx);
    return err;
}

#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
static int
ncx_put_double_double(void *xp, const double *ip, void *fillp)
{
    int err=NC_NOERR;
    double *_ip = ip;
#ifdef NO_IEEE_FLOAT
    
    if (*ip > X_DOUBLE_MAX || *ip < X_DOUBLE_MIN) {
        
        
        err = NC_ERANGE;
    }
#endif
    put_ix_double(xp, _ip);
    return err;
}
#endif


/* external NC_INT64 --------------------------------------------------------*/

#if SHORT_MAX == X_INT64_MAX
typedef short ix_int64;
#define SIZEOF_IX_INT64 SIZEOF_SHORT
#define IX_INT64_MAX SHORT_MAX
#elif LONG_LONG_MAX  >= X_INT64_MAX
typedef longlong ix_int64;
#define SIZEOF_IX_INT64 SIZEOF_LONGLONG
#define IX_INT64_MAX LONG_LONG_MAX
#elif LONG_MAX  >= X_INT64_MAX
typedef long ix_int64;
#define SIZEOF_IX_INT64 SIZEOF_LONG
#define IX_INT64_MAX LONG_MAX
#else
#error "ix_int64 implementation"
#endif


static void
get_ix_int64(const void *xp, ix_int64 *ip)
{
    const uchar *cp = (const uchar *) xp;

    *ip  = ((ix_int64)(*cp++) << 56);
    *ip |= ((ix_int64)(*cp++) << 48);
    *ip |= ((ix_int64)(*cp++) << 40);
    *ip |= ((ix_int64)(*cp++) << 32);
    *ip |= ((ix_int64)(*cp++) << 24);
    *ip |= ((ix_int64)(*cp++) << 16);
    *ip |= ((ix_int64)(*cp++) <<  8);
    *ip |=  (ix_int64)*cp;
}

static void
put_ix_int64(void *xp, const ix_int64 *ip)
{
    uchar *cp = (uchar *) xp;

    *cp++ = (uchar)((*ip) >> 56);
    *cp++ = (uchar)(((*ip) & 0x00ff000000000000LL) >> 48);
    *cp++ = (uchar)(((*ip) & 0x0000ff0000000000LL) >> 40);
    *cp++ = (uchar)(((*ip) & 0x000000ff00000000LL) >> 32);
    *cp++ = (uchar)(((*ip) & 0x00000000ff000000LL) >> 24);
    *cp++ = (uchar)(((*ip) & 0x0000000000ff0000LL) >> 16);
    *cp++ = (uchar)(((*ip) & 0x000000000000ff00LL) >>  8);
    *cp   = (uchar)( (*ip) & 0x00000000000000ffLL);
}

#if X_SIZEOF_INT64 != SIZEOF_LONGLONG
static int
#line 2068
ncx_get_longlong_longlong(const void *xp, longlong *ip)
#line 2068
{
#line 2068
    int err=NC_NOERR;
#line 2068
#if SIZEOF_IX_INT64 == SIZEOF_LONGLONG && IX_INT64_MAX == LONGLONG_MAX
#line 2068
    get_ix_int64(xp, (ix_int64 *)ip);
#line 2068
#else
#line 2068
    ix_int64 xx;
#line 2068
    get_ix_int64(xp, &xx);
#line 2068

#line 2068
#if IX_INT64_MAX > LONGLONG_MAX
#line 2068
    if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) {
#line 2068

#line 2068
        err = NC_ERANGE;
#line 2068
    }
#line 2068
#endif
#line 2068

#line 2068

#line 2068
    *ip = (longlong) xx;
#line 2068
#endif
#line 2068
    return err;
#line 2068
}
#line 2068

#endif
static int
#line 2070
ncx_get_longlong_schar(const void *xp, schar *ip)
#line 2070
{
#line 2070
    int err=NC_NOERR;
#line 2070
    ix_int64 xx;
#line 2070
    get_ix_int64(xp, &xx);
#line 2070

#line 2070
#if IX_INT64_MAX > SCHAR_MAX
#line 2070
    if (xx > SCHAR_MAX || xx < SCHAR_MIN) {
#line 2070

#line 2070
        err = NC_ERANGE;
#line 2070
    }
#line 2070
#endif
#line 2070

#line 2070

#line 2070
    *ip = (schar) xx;
#line 2070
    return err;
#line 2070
}
#line 2070

static int
#line 2071
ncx_get_longlong_short(const void *xp, short *ip)
#line 2071
{
#line 2071
    int err=NC_NOERR;
#line 2071
#if SIZEOF_IX_INT64 == SIZEOF_SHORT && IX_INT64_MAX == SHORT_MAX
#line 2071
    get_ix_int64(xp, (ix_int64 *)ip);
#line 2071
#else
#line 2071
    ix_int64 xx;
#line 2071
    get_ix_int64(xp, &xx);
#line 2071

#line 2071
#if IX_INT64_MAX > SHORT_MAX
#line 2071
    if (xx > SHORT_MAX || xx < SHORT_MIN) {
#line 2071

#line 2071
        err = NC_ERANGE;
#line 2071
    }
#line 2071
#endif
#line 2071

#line 2071

#line 2071
    *ip = (short) xx;
#line 2071
#endif
#line 2071
    return err;
#line 2071
}
#line 2071

static int
#line 2072
ncx_get_longlong_int(const void *xp, int *ip)
#line 2072
{
#line 2072
    int err=NC_NOERR;
#line 2072
#if SIZEOF_IX_INT64 == SIZEOF_INT && IX_INT64_MAX == INT_MAX
#line 2072
    get_ix_int64(xp, (ix_int64 *)ip);
#line 2072
#else
#line 2072
    ix_int64 xx;
#line 2072
    get_ix_int64(xp, &xx);
#line 2072

#line 2072
#if IX_INT64_MAX > INT_MAX
#line 2072
    if (xx > INT_MAX || xx < INT_MIN) {
#line 2072

#line 2072
        err = NC_ERANGE;
#line 2072
    }
#line 2072
#endif
#line 2072

#line 2072

#line 2072
    *ip = (int) xx;
#line 2072
#endif
#line 2072
    return err;
#line 2072
}
#line 2072

static int
#line 2073
ncx_get_longlong_long(const void *xp, long *ip)
#line 2073
{
#line 2073
    int err=NC_NOERR;
#line 2073
#if SIZEOF_IX_INT64 == SIZEOF_LONG && IX_INT64_MAX == LONG_MAX
#line 2073
    get_ix_int64(xp, (ix_int64 *)ip);
#line 2073
#else
#line 2073
    ix_int64 xx;
#line 2073
    get_ix_int64(xp, &xx);
#line 2073

#line 2073
#if IX_INT64_MAX > LONG_MAX
#line 2073
    if (xx > LONG_MAX || xx < LONG_MIN) {
#line 2073

#line 2073
        err = NC_ERANGE;
#line 2073
    }
#line 2073
#endif
#line 2073

#line 2073

#line 2073
    *ip = (long) xx;
#line 2073
#endif
#line 2073
    return err;
#line 2073
}
#line 2073

static int
#line 2074
ncx_get_longlong_ushort(const void *xp, ushort *ip)
#line 2074
{
#line 2074
    int err=NC_NOERR;
#line 2074
    ix_int64 xx;
#line 2074
    get_ix_int64(xp, &xx);
#line 2074

#line 2074
#if IX_INT64_MAX > USHORT_MAX
#line 2074
    if (xx > USHORT_MAX) {
#line 2074

#line 2074
        err = NC_ERANGE;
#line 2074
    }
#line 2074
#endif
#line 2074

#line 2074
    if (xx < 0) {
#line 2074

#line 2074
        err = NC_ERANGE; /* because ip is unsigned */
#line 2074
    }
#line 2074
    *ip = (ushort) xx;
#line 2074
    return err;
#line 2074
}
#line 2074

static int
#line 2075
ncx_get_longlong_uchar(const void *xp, uchar *ip)
#line 2075
{
#line 2075
    int err=NC_NOERR;
#line 2075
    ix_int64 xx;
#line 2075
    get_ix_int64(xp, &xx);
#line 2075

#line 2075
#if IX_INT64_MAX > UCHAR_MAX
#line 2075
    if (xx > UCHAR_MAX) {
#line 2075

#line 2075
        err = NC_ERANGE;
#line 2075
    }
#line 2075
#endif
#line 2075

#line 2075
    if (xx < 0) {
#line 2075

#line 2075
        err = NC_ERANGE; /* because ip is unsigned */
#line 2075
    }
#line 2075
    *ip = (uchar) xx;
#line 2075
    return err;
#line 2075
}
#line 2075

static int
#line 2076
ncx_get_longlong_uint(const void *xp, uint *ip)
#line 2076
{
#line 2076
    int err=NC_NOERR;
#line 2076
    ix_int64 xx;
#line 2076
    get_ix_int64(xp, &xx);
#line 2076

#line 2076
#if IX_INT64_MAX > UINT_MAX
#line 2076
    if (xx > UINT_MAX) {
#line 2076

#line 2076
        err = NC_ERANGE;
#line 2076
    }
#line 2076
#endif
#line 2076

#line 2076
    if (xx < 0) {
#line 2076

#line 2076
        err = NC_ERANGE; /* because ip is unsigned */
#line 2076
    }
#line 2076
    *ip = (uint) xx;
#line 2076
    return err;
#line 2076
}
#line 2076

static int
#line 2077
ncx_get_longlong_ulonglong(const void *xp, ulonglong *ip)
#line 2077
{
#line 2077
    int err=NC_NOERR;
#line 2077
    ix_int64 xx;
#line 2077
    get_ix_int64(xp, &xx);
#line 2077

#line 2077
#if IX_INT64_MAX > ULONGLONG_MAX
#line 2077
    if (xx > ULONGLONG_MAX) {
#line 2077

#line 2077
        err = NC_ERANGE;
#line 2077
    }
#line 2077
#endif
#line 2077

#line 2077
    if (xx < 0) {
#line 2077

#line 2077
        err = NC_ERANGE; /* because ip is unsigned */
#line 2077
    }
#line 2077
    *ip = (ulonglong) xx;
#line 2077
    return err;
#line 2077
}
#line 2077

static int
#line 2078
ncx_get_longlong_float(const void *xp, float *ip)
#line 2078
{
#line 2078
	ix_int64 xx;
#line 2078
	get_ix_int64(xp, &xx);
#line 2078
	*ip = (float)xx;
#line 2078
	return NC_NOERR;
#line 2078
}
#line 2078

static int
#line 2079
ncx_get_longlong_double(const void *xp, double *ip)
#line 2079
{
#line 2079
	ix_int64 xx;
#line 2079
	get_ix_int64(xp, &xx);
#line 2079
	*ip = (double)xx;
#line 2079
	return NC_NOERR;
#line 2079
}
#line 2079


#if X_SIZEOF_INT64 != SIZEOF_LONGLONG
static int
#line 2082
ncx_put_longlong_longlong(void *xp, const longlong *ip, void *fillp)
#line 2082
{
#line 2082
    int err=NC_NOERR;
#line 2082
#if SIZEOF_IX_INT64 == SIZEOF_LONGLONG && IX_INT64_MAX == LONGLONG_MAX
#line 2082
    put_ix_int64(xp, (const ix_int64 *)ip);
#line 2082
#else
#line 2082
    ix_int64 xx = NC_FILL_INT64;
#line 2082

#line 2082
#if IX_INT64_MAX < LONGLONG_MAX
#line 2082
    if (*ip > IX_INT64_MAX || *ip < X_INT64_MIN) {
#line 2082
        
#line 2082
        err = NC_ERANGE;
#line 2082
    } 
#line 2082
#endif
#line 2082
        xx = (ix_int64)*ip;
#line 2082

#line 2082
    put_ix_int64(xp, &xx);
#line 2082
#endif
#line 2082
    return err;
#line 2082
}
#line 2082

#endif
static int
#line 2084
ncx_put_longlong_schar(void *xp, const schar *ip, void *fillp)
#line 2084
{
#line 2084
    int err=NC_NOERR;
#line 2084
    ix_int64 xx = NC_FILL_INT64;
#line 2084

#line 2084
#if IX_INT64_MAX < SCHAR_MAX
#line 2084
    if (*ip > IX_INT64_MAX || *ip < X_INT64_MIN) {
#line 2084
        
#line 2084
        err = NC_ERANGE;
#line 2084
    } 
#line 2084
#endif
#line 2084
        xx = (ix_int64)*ip;
#line 2084

#line 2084
    put_ix_int64(xp, &xx);
#line 2084
    return err;
#line 2084
}
#line 2084

static int
#line 2085
ncx_put_longlong_short(void *xp, const short *ip, void *fillp)
#line 2085
{
#line 2085
    int err=NC_NOERR;
#line 2085
#if SIZEOF_IX_INT64 == SIZEOF_SHORT && IX_INT64_MAX == SHORT_MAX
#line 2085
    put_ix_int64(xp, (const ix_int64 *)ip);
#line 2085
#else
#line 2085
    ix_int64 xx = NC_FILL_INT64;
#line 2085

#line 2085
#if IX_INT64_MAX < SHORT_MAX
#line 2085
    if (*ip > IX_INT64_MAX || *ip < X_INT64_MIN) {
#line 2085
        
#line 2085
        err = NC_ERANGE;
#line 2085
    } 
#line 2085
#endif
#line 2085
        xx = (ix_int64)*ip;
#line 2085

#line 2085
    put_ix_int64(xp, &xx);
#line 2085
#endif
#line 2085
    return err;
#line 2085
}
#line 2085

static int
#line 2086
ncx_put_longlong_int(void *xp, const int *ip, void *fillp)
#line 2086
{
#line 2086
    int err=NC_NOERR;
#line 2086
#if SIZEOF_IX_INT64 == SIZEOF_INT && IX_INT64_MAX == INT_MAX
#line 2086
    put_ix_int64(xp, (const ix_int64 *)ip);
#line 2086
#else
#line 2086
    ix_int64 xx = NC_FILL_INT64;
#line 2086

#line 2086
#if IX_INT64_MAX < INT_MAX
#line 2086
    if (*ip > IX_INT64_MAX || *ip < X_INT64_MIN) {
#line 2086
        
#line 2086
        err = NC_ERANGE;
#line 2086
    } 
#line 2086
#endif
#line 2086
        xx = (ix_int64)*ip;
#line 2086

#line 2086
    put_ix_int64(xp, &xx);
#line 2086
#endif
#line 2086
    return err;
#line 2086
}
#line 2086

static int
#line 2087
ncx_put_longlong_long(void *xp, const long *ip, void *fillp)
#line 2087
{
#line 2087
    int err=NC_NOERR;
#line 2087
#if SIZEOF_IX_INT64 == SIZEOF_LONG && IX_INT64_MAX == LONG_MAX
#line 2087
    put_ix_int64(xp, (const ix_int64 *)ip);
#line 2087
#else
#line 2087
    ix_int64 xx = NC_FILL_INT64;
#line 2087

#line 2087
#if IX_INT64_MAX < LONG_MAX
#line 2087
    if (*ip > IX_INT64_MAX || *ip < X_INT64_MIN) {
#line 2087
        
#line 2087
        err = NC_ERANGE;
#line 2087
    } 
#line 2087
#endif
#line 2087
        xx = (ix_int64)*ip;
#line 2087

#line 2087
    put_ix_int64(xp, &xx);
#line 2087
#endif
#line 2087
    return err;
#line 2087
}
#line 2087

static int
#line 2088
ncx_put_longlong_ushort(void *xp, const ushort *ip, void *fillp)
#line 2088
{
#line 2088
    int err=NC_NOERR;
#line 2088
    ix_int64 xx = NC_FILL_INT64;
#line 2088

#line 2088
#if IX_INT64_MAX < USHORT_MAX
#line 2088
    if (*ip > IX_INT64_MAX) {
#line 2088
        
#line 2088
        err = NC_ERANGE;
#line 2088
    } 
#line 2088
#endif
#line 2088
        xx = (ix_int64)*ip;
#line 2088

#line 2088
    put_ix_int64(xp, &xx);
#line 2088
    return err;
#line 2088
}
#line 2088

static int
#line 2089
ncx_put_longlong_uchar(void *xp, const uchar *ip, void *fillp)
#line 2089
{
#line 2089
    int err=NC_NOERR;
#line 2089
    ix_int64 xx = NC_FILL_INT64;
#line 2089

#line 2089
#if IX_INT64_MAX < UCHAR_MAX
#line 2089
    if (*ip > IX_INT64_MAX) {
#line 2089
        
#line 2089
        err = NC_ERANGE;
#line 2089
    } 
#line 2089
#endif
#line 2089
        xx = (ix_int64)*ip;
#line 2089

#line 2089
    put_ix_int64(xp, &xx);
#line 2089
    return err;
#line 2089
}
#line 2089

static int
#line 2090
ncx_put_longlong_uint(void *xp, const uint *ip, void *fillp)
#line 2090
{
#line 2090
    int err=NC_NOERR;
#line 2090
    ix_int64 xx = NC_FILL_INT64;
#line 2090

#line 2090
#if IX_INT64_MAX < UINT_MAX
#line 2090
    if (*ip > IX_INT64_MAX) {
#line 2090
        
#line 2090
        err = NC_ERANGE;
#line 2090
    } 
#line 2090
#endif
#line 2090
        xx = (ix_int64)*ip;
#line 2090

#line 2090
    put_ix_int64(xp, &xx);
#line 2090
    return err;
#line 2090
}
#line 2090

static int
#line 2091
ncx_put_longlong_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 2091
{
#line 2091
    int err=NC_NOERR;
#line 2091
    ix_int64 xx = NC_FILL_INT64;
#line 2091

#line 2091
#if IX_INT64_MAX < ULONGLONG_MAX
#line 2091
    if (*ip > IX_INT64_MAX) {
#line 2091
        
#line 2091
        err = NC_ERANGE;
#line 2091
    } 
#line 2091
#endif
#line 2091
        xx = (ix_int64)*ip;
#line 2091

#line 2091
    put_ix_int64(xp, &xx);
#line 2091
    return err;
#line 2091
}
#line 2091

static int
#line 2092
ncx_put_longlong_float(void *xp, const float *ip, void *fillp)
#line 2092
{
#line 2092
    int err=NC_NOERR;
#line 2092
    ix_int64 xx = NC_FILL_INT64;
#line 2092

#line 2092
    if (*ip > (double)X_INT64_MAX || *ip < (double)X_INT64_MIN) {
#line 2092
        
#line 2092
        err = NC_ERANGE;
#line 2092
    } 
#line 2092
        xx = (ix_int64)*ip;
#line 2092

#line 2092
    put_ix_int64(xp, &xx);
#line 2092
    return err;
#line 2092
}
#line 2092

static int
#line 2093
ncx_put_longlong_double(void *xp, const double *ip, void *fillp)
#line 2093
{
#line 2093
    int err=NC_NOERR;
#line 2093
    ix_int64 xx = NC_FILL_INT64;
#line 2093

#line 2093
    if (*ip > X_INT64_MAX || *ip < X_INT64_MIN) {
#line 2093
        
#line 2093
        err = NC_ERANGE;
#line 2093
    } 
#line 2093
        xx = (ix_int64)*ip;
#line 2093

#line 2093
    put_ix_int64(xp, &xx);
#line 2093
    return err;
#line 2093
}
#line 2093



/* external NC_UINT64 -------------------------------------------------------*/

#if USHORT_MAX == X_UINT64_MAX
typedef ushort ix_uint64;
#define SIZEOF_IX_UINT64 SIZEOF_USHORT
#define IX_UINT64_MAX USHORT_MAX
#elif ULONG_LONG_MAX  >= X_UINT64_MAX
typedef ulonglong ix_uint64;
#define SIZEOF_IX_UINT64 SIZEOF_ULONGLONG
#define IX_UINT64_MAX ULONG_LONG_MAX
#elif ULONG_MAX  >= X_UINT64_MAX
typedef ulong ix_uint64;
#define SIZEOF_IX_UINT64 SIZEOF_ULONG
#define IX_UINT64_MAX ULONG_MAX
#else
#error "ix_uint64 implementation"
#endif


static void
get_ix_uint64(const void *xp, ix_uint64 *ip)
{
    const uchar *cp = (const uchar *) xp;

    *ip  = ((ix_uint64)(*cp++) << 56);
    *ip |= ((ix_uint64)(*cp++) << 48);
    *ip |= ((ix_uint64)(*cp++) << 40);
    *ip |= ((ix_uint64)(*cp++) << 32);
    *ip |= ((ix_uint64)(*cp++) << 24);
    *ip |= ((ix_uint64)(*cp++) << 16);
    *ip |= ((ix_uint64)(*cp++) <<  8);
    *ip |=  (ix_uint64)*cp;
}

static void
put_ix_uint64(void *xp, const ix_uint64 *ip)
{
    uchar *cp = (uchar *) xp;

    *cp++ = (uchar)((*ip) >> 56);
    *cp++ = (uchar)(((*ip) & 0x00ff000000000000ULL) >> 48);
    *cp++ = (uchar)(((*ip) & 0x0000ff0000000000ULL) >> 40);
    *cp++ = (uchar)(((*ip) & 0x000000ff00000000ULL) >> 32);
    *cp++ = (uchar)(((*ip) & 0x00000000ff000000ULL) >> 24);
    *cp++ = (uchar)(((*ip) & 0x0000000000ff0000ULL) >> 16);
    *cp++ = (uchar)(((*ip) & 0x000000000000ff00ULL) >>  8);
    *cp   = (uchar)( (*ip) & 0x00000000000000ffULL);
}

#if X_SIZEOF_UINT64 != SIZEOF_ULONGLONG
static int
#line 2146
ncx_get_ulonglong_ulonglong(const void *xp, ulonglong *ip)
#line 2146
{
#line 2146
    int err=NC_NOERR;
#line 2146
#if SIZEOF_IX_UINT64 == SIZEOF_ULONGLONG && IX_UINT64_MAX == ULONGLONG_MAX
#line 2146
    get_ix_uint64(xp, (ix_uint64 *)ip);
#line 2146
#else
#line 2146
    ix_uint64 xx;
#line 2146
    get_ix_uint64(xp, &xx);
#line 2146

#line 2146
#if IX_UINT64_MAX > ULONGLONG_MAX
#line 2146
    if (xx > ULONGLONG_MAX) {
#line 2146

#line 2146
        err = NC_ERANGE;
#line 2146
    }
#line 2146
#endif
#line 2146

#line 2146

#line 2146
    *ip = (ulonglong) xx;
#line 2146
#endif
#line 2146
    return err;
#line 2146
}
#line 2146

#endif
static int
#line 2148
ncx_get_ulonglong_schar(const void *xp, schar *ip)
#line 2148
{
#line 2148
    int err=NC_NOERR;
#line 2148
    ix_uint64 xx;
#line 2148
    get_ix_uint64(xp, &xx);
#line 2148

#line 2148
#if IX_UINT64_MAX > SCHAR_MAX
#line 2148
    if (xx > SCHAR_MAX) {
#line 2148

#line 2148
        err = NC_ERANGE;
#line 2148
    }
#line 2148
#endif
#line 2148

#line 2148

#line 2148
    *ip = (schar) xx;
#line 2148
    return err;
#line 2148
}
#line 2148

static int
#line 2149
ncx_get_ulonglong_short(const void *xp, short *ip)
#line 2149
{
#line 2149
    int err=NC_NOERR;
#line 2149
    ix_uint64 xx;
#line 2149
    get_ix_uint64(xp, &xx);
#line 2149

#line 2149
#if IX_UINT64_MAX > SHORT_MAX
#line 2149
    if (xx > SHORT_MAX) {
#line 2149

#line 2149
        err = NC_ERANGE;
#line 2149
    }
#line 2149
#endif
#line 2149

#line 2149

#line 2149
    *ip = (short) xx;
#line 2149
    return err;
#line 2149
}
#line 2149

static int
#line 2150
ncx_get_ulonglong_int(const void *xp, int *ip)
#line 2150
{
#line 2150
    int err=NC_NOERR;
#line 2150
    ix_uint64 xx;
#line 2150
    get_ix_uint64(xp, &xx);
#line 2150

#line 2150
#if IX_UINT64_MAX > INT_MAX
#line 2150
    if (xx > INT_MAX) {
#line 2150

#line 2150
        err = NC_ERANGE;
#line 2150
    }
#line 2150
#endif
#line 2150

#line 2150

#line 2150
    *ip = (int) xx;
#line 2150
    return err;
#line 2150
}
#line 2150

static int
#line 2151
ncx_get_ulonglong_long(const void *xp, long *ip)
#line 2151
{
#line 2151
    int err=NC_NOERR;
#line 2151
    ix_uint64 xx;
#line 2151
    get_ix_uint64(xp, &xx);
#line 2151

#line 2151
#if IX_UINT64_MAX > LONG_MAX
#line 2151
    if (xx > LONG_MAX) {
#line 2151

#line 2151
        err = NC_ERANGE;
#line 2151
    }
#line 2151
#endif
#line 2151

#line 2151

#line 2151
    *ip = (long) xx;
#line 2151
    return err;
#line 2151
}
#line 2151

static int
#line 2152
ncx_get_ulonglong_longlong(const void *xp, longlong *ip)
#line 2152
{
#line 2152
    int err=NC_NOERR;
#line 2152
    ix_uint64 xx;
#line 2152
    get_ix_uint64(xp, &xx);
#line 2152

#line 2152
#if IX_UINT64_MAX > LONGLONG_MAX
#line 2152
    if (xx > LONGLONG_MAX) {
#line 2152

#line 2152
        err = NC_ERANGE;
#line 2152
    }
#line 2152
#endif
#line 2152

#line 2152

#line 2152
    *ip = (longlong) xx;
#line 2152
    return err;
#line 2152
}
#line 2152

static int
#line 2153
ncx_get_ulonglong_ushort(const void *xp, ushort *ip)
#line 2153
{
#line 2153
    int err=NC_NOERR;
#line 2153
#if SIZEOF_IX_UINT64 == SIZEOF_USHORT && IX_UINT64_MAX == USHORT_MAX
#line 2153
    get_ix_uint64(xp, (ix_uint64 *)ip);
#line 2153
#else
#line 2153
    ix_uint64 xx;
#line 2153
    get_ix_uint64(xp, &xx);
#line 2153

#line 2153
#if IX_UINT64_MAX > USHORT_MAX
#line 2153
    if (xx > USHORT_MAX) {
#line 2153

#line 2153
        err = NC_ERANGE;
#line 2153
    }
#line 2153
#endif
#line 2153

#line 2153

#line 2153
    *ip = (ushort) xx;
#line 2153
#endif
#line 2153
    return err;
#line 2153
}
#line 2153

static int
#line 2154
ncx_get_ulonglong_uchar(const void *xp, uchar *ip)
#line 2154
{
#line 2154
    int err=NC_NOERR;
#line 2154
#if SIZEOF_IX_UINT64 == SIZEOF_UCHAR && IX_UINT64_MAX == UCHAR_MAX
#line 2154
    get_ix_uint64(xp, (ix_uint64 *)ip);
#line 2154
#else
#line 2154
    ix_uint64 xx;
#line 2154
    get_ix_uint64(xp, &xx);
#line 2154

#line 2154
#if IX_UINT64_MAX > UCHAR_MAX
#line 2154
    if (xx > UCHAR_MAX) {
#line 2154

#line 2154
        err = NC_ERANGE;
#line 2154
    }
#line 2154
#endif
#line 2154

#line 2154

#line 2154
    *ip = (uchar) xx;
#line 2154
#endif
#line 2154
    return err;
#line 2154
}
#line 2154

static int
#line 2155
ncx_get_ulonglong_uint(const void *xp, uint *ip)
#line 2155
{
#line 2155
    int err=NC_NOERR;
#line 2155
#if SIZEOF_IX_UINT64 == SIZEOF_UINT && IX_UINT64_MAX == UINT_MAX
#line 2155
    get_ix_uint64(xp, (ix_uint64 *)ip);
#line 2155
#else
#line 2155
    ix_uint64 xx;
#line 2155
    get_ix_uint64(xp, &xx);
#line 2155

#line 2155
#if IX_UINT64_MAX > UINT_MAX
#line 2155
    if (xx > UINT_MAX) {
#line 2155

#line 2155
        err = NC_ERANGE;
#line 2155
    }
#line 2155
#endif
#line 2155

#line 2155

#line 2155
    *ip = (uint) xx;
#line 2155
#endif
#line 2155
    return err;
#line 2155
}
#line 2155

static int
#line 2156
ncx_get_ulonglong_float(const void *xp, float *ip)
#line 2156
{
#line 2156
	ix_uint64 xx;
#line 2156
	get_ix_uint64(xp, &xx);
#line 2156
	*ip = (float)xx;
#line 2156
	return NC_NOERR;
#line 2156
}
#line 2156

static int
#line 2157
ncx_get_ulonglong_double(const void *xp, double *ip)
#line 2157
{
#line 2157
	ix_uint64 xx;
#line 2157
	get_ix_uint64(xp, &xx);
#line 2157
	*ip = (double)xx;
#line 2157
	return NC_NOERR;
#line 2157
}
#line 2157


#if X_SIZEOF_UINT64 != SIZEOF_ULONGLONG
static int
#line 2160
ncx_put_ulonglong_ulonglong(void *xp, const ulonglong *ip, void *fillp)
#line 2160
{
#line 2160
    int err=NC_NOERR;
#line 2160
#if SIZEOF_IX_UINT64 == SIZEOF_ULONGLONG && IX_UINT64_MAX == ULONGLONG_MAX
#line 2160
    put_ix_uint64(xp, (const ix_uint64 *)ip);
#line 2160
#else
#line 2160
    ix_uint64 xx = NC_FILL_UINT64;
#line 2160

#line 2160
#if IX_UINT64_MAX < ULONGLONG_MAX
#line 2160
    if (*ip > IX_UINT64_MAX) {
#line 2160
        
#line 2160
        err = NC_ERANGE;
#line 2160
    } 
#line 2160
#endif
#line 2160
        xx = (ix_uint64)*ip;
#line 2160

#line 2160
    put_ix_uint64(xp, &xx);
#line 2160
#endif
#line 2160
    return err;
#line 2160
}
#line 2160

#endif
static int
#line 2162
ncx_put_ulonglong_schar(void *xp, const schar *ip, void *fillp)
#line 2162
{
#line 2162
    int err=NC_NOERR;
#line 2162
    ix_uint64 xx = NC_FILL_UINT64;
#line 2162

#line 2162
#if IX_UINT64_MAX < SCHAR_MAX
#line 2162
    if (*ip > IX_UINT64_MAX) {
#line 2162
        
#line 2162
        err = NC_ERANGE;
#line 2162
    } 
#line 2162
#endif
#line 2162
    if (*ip < 0) {
#line 2162
        
#line 2162
        err = NC_ERANGE; /* because xp is unsigned */
#line 2162
    } 
#line 2162
        xx = (ix_uint64)*ip;
#line 2162

#line 2162
    put_ix_uint64(xp, &xx);
#line 2162
    return err;
#line 2162
}
#line 2162

static int
#line 2163
ncx_put_ulonglong_short(void *xp, const short *ip, void *fillp)
#line 2163
{
#line 2163
    int err=NC_NOERR;
#line 2163
    ix_uint64 xx = NC_FILL_UINT64;
#line 2163

#line 2163
#if IX_UINT64_MAX < SHORT_MAX
#line 2163
    if (*ip > IX_UINT64_MAX) {
#line 2163
        
#line 2163
        err = NC_ERANGE;
#line 2163
    } 
#line 2163
#endif
#line 2163
    if (*ip < 0) {
#line 2163
        
#line 2163
        err = NC_ERANGE; /* because xp is unsigned */
#line 2163
    } 
#line 2163
        xx = (ix_uint64)*ip;
#line 2163

#line 2163
    put_ix_uint64(xp, &xx);
#line 2163
    return err;
#line 2163
}
#line 2163

static int
#line 2164
ncx_put_ulonglong_int(void *xp, const int *ip, void *fillp)
#line 2164
{
#line 2164
    int err=NC_NOERR;
#line 2164
    ix_uint64 xx = NC_FILL_UINT64;
#line 2164

#line 2164
#if IX_UINT64_MAX < INT_MAX
#line 2164
    if (*ip > IX_UINT64_MAX) {
#line 2164
        
#line 2164
        err = NC_ERANGE;
#line 2164
    } 
#line 2164
#endif
#line 2164
    if (*ip < 0) {
#line 2164
        
#line 2164
        err = NC_ERANGE; /* because xp is unsigned */
#line 2164
    } 
#line 2164
        xx = (ix_uint64)*ip;
#line 2164

#line 2164
    put_ix_uint64(xp, &xx);
#line 2164
    return err;
#line 2164
}
#line 2164

static int
#line 2165
ncx_put_ulonglong_long(void *xp, const long *ip, void *fillp)
#line 2165
{
#line 2165
    int err=NC_NOERR;
#line 2165
    ix_uint64 xx = NC_FILL_UINT64;
#line 2165

#line 2165
#if IX_UINT64_MAX < LONG_MAX
#line 2165
    if (*ip > IX_UINT64_MAX) {
#line 2165
        
#line 2165
        err = NC_ERANGE;
#line 2165
    } 
#line 2165
#endif
#line 2165
    if (*ip < 0) {
#line 2165
        
#line 2165
        err = NC_ERANGE; /* because xp is unsigned */
#line 2165
    } 
#line 2165
        xx = (ix_uint64)*ip;
#line 2165

#line 2165
    put_ix_uint64(xp, &xx);
#line 2165
    return err;
#line 2165
}
#line 2165

static int
#line 2166
ncx_put_ulonglong_longlong(void *xp, const longlong *ip, void *fillp)
#line 2166
{
#line 2166
    int err=NC_NOERR;
#line 2166
    ix_uint64 xx = NC_FILL_UINT64;
#line 2166

#line 2166
#if IX_UINT64_MAX < LONGLONG_MAX
#line 2166
    if (*ip > IX_UINT64_MAX) {
#line 2166
        
#line 2166
        err = NC_ERANGE;
#line 2166
    } 
#line 2166
#endif
#line 2166
    if (*ip < 0) {
#line 2166
        
#line 2166
        err = NC_ERANGE; /* because xp is unsigned */
#line 2166
    } 
#line 2166
        xx = (ix_uint64)*ip;
#line 2166

#line 2166
    put_ix_uint64(xp, &xx);
#line 2166
    return err;
#line 2166
}
#line 2166

static int
#line 2167
ncx_put_ulonglong_uchar(void *xp, const uchar *ip, void *fillp)
#line 2167
{
#line 2167
    int err=NC_NOERR;
#line 2167
#if SIZEOF_IX_UINT64 == SIZEOF_UCHAR && IX_UINT64_MAX == UCHAR_MAX
#line 2167
    put_ix_uint64(xp, (const ix_uint64 *)ip);
#line 2167
#else
#line 2167
    ix_uint64 xx = NC_FILL_UINT64;
#line 2167

#line 2167
#if IX_UINT64_MAX < UCHAR_MAX
#line 2167
    if (*ip > IX_UINT64_MAX) {
#line 2167
        
#line 2167
        err = NC_ERANGE;
#line 2167
    } 
#line 2167
#endif
#line 2167
        xx = (ix_uint64)*ip;
#line 2167

#line 2167
    put_ix_uint64(xp, &xx);
#line 2167
#endif
#line 2167
    return err;
#line 2167
}
#line 2167

static int
#line 2168
ncx_put_ulonglong_ushort(void *xp, const ushort *ip, void *fillp)
#line 2168
{
#line 2168
    int err=NC_NOERR;
#line 2168
#if SIZEOF_IX_UINT64 == SIZEOF_USHORT && IX_UINT64_MAX == USHORT_MAX
#line 2168
    put_ix_uint64(xp, (const ix_uint64 *)ip);
#line 2168
#else
#line 2168
    ix_uint64 xx = NC_FILL_UINT64;
#line 2168

#line 2168
#if IX_UINT64_MAX < USHORT_MAX
#line 2168
    if (*ip > IX_UINT64_MAX) {
#line 2168
        
#line 2168
        err = NC_ERANGE;
#line 2168
    } 
#line 2168
#endif
#line 2168
        xx = (ix_uint64)*ip;
#line 2168

#line 2168
    put_ix_uint64(xp, &xx);
#line 2168
#endif
#line 2168
    return err;
#line 2168
}
#line 2168

static int
#line 2169
ncx_put_ulonglong_uint(void *xp, const uint *ip, void *fillp)
#line 2169
{
#line 2169
    int err=NC_NOERR;
#line 2169
#if SIZEOF_IX_UINT64 == SIZEOF_UINT && IX_UINT64_MAX == UINT_MAX
#line 2169
    put_ix_uint64(xp, (const ix_uint64 *)ip);
#line 2169
#else
#line 2169
    ix_uint64 xx = NC_FILL_UINT64;
#line 2169

#line 2169
#if IX_UINT64_MAX < UINT_MAX
#line 2169
    if (*ip > IX_UINT64_MAX) {
#line 2169
        
#line 2169
        err = NC_ERANGE;
#line 2169
    } 
#line 2169
#endif
#line 2169
        xx = (ix_uint64)*ip;
#line 2169

#line 2169
    put_ix_uint64(xp, &xx);
#line 2169
#endif
#line 2169
    return err;
#line 2169
}
#line 2169

static int
#line 2170
ncx_put_ulonglong_float(void *xp, const float *ip, void *fillp)
#line 2170
{
#line 2170
    int err=NC_NOERR;
#line 2170
    ix_uint64 xx = NC_FILL_UINT64;
#line 2170

#line 2170
    if (*ip > (double)X_UINT64_MAX || *ip < 0) {
#line 2170
        
#line 2170
        err = NC_ERANGE;
#line 2170
    } 
#line 2170
        xx = (ix_uint64)*ip;
#line 2170

#line 2170
    put_ix_uint64(xp, &xx);
#line 2170
    return err;
#line 2170
}
#line 2170

static int
#line 2171
ncx_put_ulonglong_double(void *xp, const double *ip, void *fillp)
#line 2171
{
#line 2171
    int err=NC_NOERR;
#line 2171
    ix_uint64 xx = NC_FILL_UINT64;
#line 2171

#line 2171
    if (*ip > X_UINT64_MAX || *ip < 0) {
#line 2171
        
#line 2171
        err = NC_ERANGE;
#line 2171
    } 
#line 2171
        xx = (ix_uint64)*ip;
#line 2171

#line 2171
    put_ix_uint64(xp, &xx);
#line 2171
    return err;
#line 2171
}
#line 2171



/* x_size_t */

#if SIZEOF_SIZE_T < X_SIZEOF_SIZE_T
#error "x_size_t implementation"
/* netcdf requires size_t which can hold a values from 0 to 2^32 -1 */
#endif

int
ncx_put_size_t(void **xpp, const size_t *ulp)
{
	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;
	assert(*ulp <= X_SIZE_MAX);

	*cp++ = (uchar)((*ulp) >> 24);
	*cp++ = (uchar)(((*ulp) & 0x00ff0000) >> 16);
	*cp++ = (uchar)(((*ulp) & 0x0000ff00) >>  8);
	*cp   = (uchar)((*ulp) & 0x000000ff);

	*xpp = (void *)((char *)(*xpp) + X_SIZEOF_SIZE_T);
	return NC_NOERR;
}

int
ncx_get_size_t(const void **xpp,  size_t *ulp)
{
	/* similar to get_ix_int */
	const uchar *cp = (const uchar *) *xpp;

	*ulp  = (unsigned)(*cp++) << 24;
	*ulp |= (*cp++ << 16);
	*ulp |= (*cp++ << 8);
	*ulp |= *cp;

	*xpp = (const void *)((const char *)(*xpp) + X_SIZEOF_SIZE_T);
	return NC_NOERR;
}

/* x_off_t */

int
ncx_put_off_t(void **xpp, const off_t *lp, size_t sizeof_off_t)
{
	/* No negative offsets stored in netcdf */
	if (*lp < 0) {
	  /* Assume this is an overflow of a 32-bit int... */
	  return NC_ERANGE;
	}

	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;

	if (sizeof_off_t == 4) {
		*cp++ = (uchar) ((*lp)               >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
	} else {
#if SIZEOF_OFF_T == 4
/* Write a 64-bit offset on a system with only a 32-bit offset */
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;

		*cp++ = (uchar)(((*lp) & 0xff000000) >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
#else
		*cp++ = (uchar) ((*lp)                          >> 56);
		*cp++ = (uchar)(((*lp) & 0x00ff000000000000LL) >> 48);
		*cp++ = (uchar)(((*lp) & 0x0000ff0000000000LL) >> 40);
		*cp++ = (uchar)(((*lp) & 0x000000ff00000000LL) >> 32);
		*cp++ = (uchar)(((*lp) & 0x00000000ff000000LL) >> 24);
		*cp++ = (uchar)(((*lp) & 0x0000000000ff0000LL) >> 16);
		*cp++ = (uchar)(((*lp) & 0x000000000000ff00LL) >>  8);
		*cp   = (uchar)( (*lp) & 0x00000000000000ffLL);
#endif
	}
	*xpp = (void *)((char *)(*xpp) + sizeof_off_t);
	return NC_NOERR;
}

int
ncx_get_off_t(const void **xpp, off_t *lp, size_t sizeof_off_t)
{
	/* similar to get_ix_int() */
	const uchar *cp = (const uchar *) *xpp;
	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

 	if (sizeof_off_t == 4) {
		*lp =  (off_t)(*cp++ << 24);
		*lp |= (off_t)(*cp++ << 16);
		*lp |= (off_t)(*cp++ <<  8);
		*lp |= (off_t)*cp;
	} else {
#if SIZEOF_OFF_T == 4
/* Read a 64-bit offset on a system with only a 32-bit offset */
/* If the offset overflows, set an error code and return */
		*lp =  ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |= ((off_t)(*cp++));
/*
 * lp now contains the upper 32-bits of the 64-bit offset.  if lp is
 * not zero, then the dataset is larger than can be represented
 * on this system.  Set an error code and return.
 */
		if (*lp != 0) {
		  return NC_ERANGE;
		}

		*lp  = ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;

		if (*lp < 0) {
		  /*
		   * If this fails, then the offset is >2^31, but less
		   * than 2^32 which is not allowed, but is not caught
		   * by the previous check
		   */
		  return NC_ERANGE;
		}
#else
		*lp =  ((off_t)(*cp++) << 56);
		*lp |= ((off_t)(*cp++) << 48);
		*lp |= ((off_t)(*cp++) << 40);
		*lp |= ((off_t)(*cp++) << 32);
		*lp |= ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;
#endif
	}
	*xpp = (const void *)((const char *)(*xpp) + sizeof_off_t);
	return NC_NOERR;
}

/*----< ncx_get_uint32() >------------------------------------------*/
int
ncx_get_uint32(const void **xpp, uint *ip)
{
#ifdef WORDS_BIGENDIAN
    /* use memcpy instead of assignment to avoid BUS_ADRALN alignment error on
     * some system, such as HPUX */
    (void) memcpy(ip, *xpp, SIZEOF_UINT);
#else
    const uchar *cp = (const uchar *) *xpp;

    *ip = (uint)(*cp++ << 24);
    *ip = (uint)(*ip | (uint)(*cp++ << 16));
    *ip = (uint)(*ip | (uint)(*cp++ <<  8));
    *ip = (uint)(*ip | *cp);
#endif
    /* advance *xpp 4 bytes */
    *xpp = (void *)((const char *)(*xpp) + 4);

    return NC_NOERR;
}

/*----< ncx_get_uint64() >------------------------------------------*/
int
ncx_get_uint64(const void **xpp, unsigned long long *ullp)
{
#ifdef WORDS_BIGENDIAN
    /* use memcpy instead of assignment to avoid BUS_ADRALN alignment error on
     * some system, such as HPUX */
    (void) memcpy(ullp, *xpp, SIZEOF_UINT64);
#else
    const uchar *cp = (const uchar *) *xpp;

    /* below is the same as calling swap8b(ullp, *xpp) */
    *ullp = (unsigned long long)(*cp++) << 56;
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) << 48);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) << 40);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) << 32);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) << 24);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) << 16);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp++) <<  8);
    *ullp = (unsigned long long)(*ullp | (unsigned long long)(*cp));
#endif
    /* advance *xpp 8 bytes */
    *xpp = (void *)((const char *)(*xpp) + 8);

    return NC_NOERR;
}

/*---< ncx_put_uint32() >-------------------------------------------*/
/* copy the contents of ip (an unsigned 32-bit integer) to xpp in Big Endian
 * form and advance *xpp 4 bytes
 */
int
ncx_put_uint32(void **xpp, const unsigned int ip)
{
#ifdef WORDS_BIGENDIAN
    /* use memcpy instead of assignment to avoid BUS_ADRALN alignment error on
     * some system, such as HPUX */
    (void) memcpy(*xpp, &ip, X_SIZEOF_UINT);
#else
    /* bitwise shifts below are to produce an integer in Big Endian */
    uchar *cp = (uchar *) *xpp;
    *cp++ = (uchar)((ip & 0xff000000) >> 24);
    *cp++ = (uchar)((ip & 0x00ff0000) >> 16);
    *cp++ = (uchar)((ip & 0x0000ff00) >>  8);
    *cp   = (uchar)( ip & 0x000000ff);
#endif
    /* advance *xpp 4 bytes */
    *xpp  = (void *)((char *)(*xpp) + 4);

    return NC_NOERR;
}

/*---< ncx_put_uint64() >-------------------------------------------*/
/* copy the contents of ip (an unsigned 64-bit integer) to xpp in Big Endian
 * form and advance *xpp 8 bytes
 */
int
ncx_put_uint64(void **xpp, const unsigned long long ip)
{
#ifdef WORDS_BIGENDIAN
    /* use memcpy instead of assignment to avoid BUS_ADRALN alignment error on
     * some system, such as HPUX */
    (void) memcpy(*xpp, &ip, X_SIZEOF_UINT64);
#else
    uchar *cp = (uchar *) *xpp;
    /* below is the same as calling swap8b(*xpp, &ip) */
    *cp++ = (uchar) (ip                         >> 56);
    *cp++ = (uchar)((ip & 0x00ff000000000000LL) >> 48);
    *cp++ = (uchar)((ip & 0x0000ff0000000000LL) >> 40);
    *cp++ = (uchar)((ip & 0x000000ff00000000LL) >> 32);
    *cp++ = (uchar)((ip & 0x00000000ff000000LL) >> 24);
    *cp++ = (uchar)((ip & 0x0000000000ff0000LL) >> 16);
    *cp++ = (uchar)((ip & 0x000000000000ff00LL) >>  8);
    *cp   = (uchar) (ip & 0x00000000000000ffLL);
#endif
    /* advance *xpp 8 bytes */
    *xpp  = (void *)((char *)(*xpp) + 8);

    return NC_NOERR;
}


/*
 * Aggregate numeric conversion functions.
 */
#line 2427

#line 2826

#line 2832

/* schar ---------------------------------------------------------------------*/

#line 2836
int
ncx_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, (size_t)nelems);
#line 2839
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2839
	return NC_NOERR;
#line 2839

}
int
#line 2841
ncx_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2841
{
#line 2841
    int status = NC_NOERR;
#line 2841
    schar *xp = (schar *)(*xpp);
#line 2841

#line 2841
    while (nelems-- != 0) {
#line 2841
        
#line 2841
        if (*xp < 0) {
#line 2841
            
#line 2841
            status = NC_ERANGE; /* because tp is unsigned */
#line 2841
            
#line 2841
        }
#line 2841
        *tp++ = (uchar) (signed) (*xp++);  /* type cast from schar to uchar */
#line 2841
    }
#line 2841

#line 2841
    *xpp = (const void *)xp;
#line 2841
    return status;
#line 2841
}
#line 2841

int
#line 2842
ncx_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2842
{
#line 2842
    int status = NC_NOERR;
#line 2842
    schar *xp = (schar *)(*xpp);
#line 2842

#line 2842
    while (nelems-- != 0) {
#line 2842
        
#line 2842
        *tp++ = (short)  (*xp++);  /* type cast from schar to short */
#line 2842
    }
#line 2842

#line 2842
    *xpp = (const void *)xp;
#line 2842
    return status;
#line 2842
}
#line 2842

int
#line 2843
ncx_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2843
{
#line 2843
    int status = NC_NOERR;
#line 2843
    schar *xp = (schar *)(*xpp);
#line 2843

#line 2843
    while (nelems-- != 0) {
#line 2843
        
#line 2843
        *tp++ = (int)  (*xp++);  /* type cast from schar to int */
#line 2843
    }
#line 2843

#line 2843
    *xpp = (const void *)xp;
#line 2843
    return status;
#line 2843
}
#line 2843

int
#line 2844
ncx_getn_schar_long(const void **xpp, size_t nelems, long *tp)
#line 2844
{
#line 2844
    int status = NC_NOERR;
#line 2844
    schar *xp = (schar *)(*xpp);
#line 2844

#line 2844
    while (nelems-- != 0) {
#line 2844
        
#line 2844
        *tp++ = (long)  (*xp++);  /* type cast from schar to long */
#line 2844
    }
#line 2844

#line 2844
    *xpp = (const void *)xp;
#line 2844
    return status;
#line 2844
}
#line 2844

int
#line 2845
ncx_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2845
{
#line 2845
    int status = NC_NOERR;
#line 2845
    schar *xp = (schar *)(*xpp);
#line 2845

#line 2845
    while (nelems-- != 0) {
#line 2845
        
#line 2845
        *tp++ = (float)  (*xp++);  /* type cast from schar to float */
#line 2845
    }
#line 2845

#line 2845
    *xpp = (const void *)xp;
#line 2845
    return status;
#line 2845
}
#line 2845

int
#line 2846
ncx_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2846
{
#line 2846
    int status = NC_NOERR;
#line 2846
    schar *xp = (schar *)(*xpp);
#line 2846

#line 2846
    while (nelems-- != 0) {
#line 2846
        
#line 2846
        *tp++ = (double)  (*xp++);  /* type cast from schar to double */
#line 2846
    }
#line 2846

#line 2846
    *xpp = (const void *)xp;
#line 2846
    return status;
#line 2846
}
#line 2846

int
#line 2847
ncx_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2847
{
#line 2847
    int status = NC_NOERR;
#line 2847
    schar *xp = (schar *)(*xpp);
#line 2847

#line 2847
    while (nelems-- != 0) {
#line 2847
        
#line 2847
        *tp++ = (longlong)  (*xp++);  /* type cast from schar to longlong */
#line 2847
    }
#line 2847

#line 2847
    *xpp = (const void *)xp;
#line 2847
    return status;
#line 2847
}
#line 2847

int
#line 2848
ncx_getn_schar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2848
{
#line 2848
    int status = NC_NOERR;
#line 2848
    schar *xp = (schar *)(*xpp);
#line 2848

#line 2848
    while (nelems-- != 0) {
#line 2848
        
#line 2848
        if (*xp < 0) {
#line 2848
            
#line 2848
            status = NC_ERANGE; /* because tp is unsigned */
#line 2848
            
#line 2848
        }
#line 2848
        *tp++ = (ushort) (signed) (*xp++);  /* type cast from schar to ushort */
#line 2848
    }
#line 2848

#line 2848
    *xpp = (const void *)xp;
#line 2848
    return status;
#line 2848
}
#line 2848

int
#line 2849
ncx_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2849
{
#line 2849
    int status = NC_NOERR;
#line 2849
    schar *xp = (schar *)(*xpp);
#line 2849

#line 2849
    while (nelems-- != 0) {
#line 2849
        
#line 2849
        if (*xp < 0) {
#line 2849
            
#line 2849
            status = NC_ERANGE; /* because tp is unsigned */
#line 2849
            
#line 2849
        }
#line 2849
        *tp++ = (uint) (signed) (*xp++);  /* type cast from schar to uint */
#line 2849
    }
#line 2849

#line 2849
    *xpp = (const void *)xp;
#line 2849
    return status;
#line 2849
}
#line 2849

int
#line 2850
ncx_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2850
{
#line 2850
    int status = NC_NOERR;
#line 2850
    schar *xp = (schar *)(*xpp);
#line 2850

#line 2850
    while (nelems-- != 0) {
#line 2850
        
#line 2850
        if (*xp < 0) {
#line 2850
            
#line 2850
            status = NC_ERANGE; /* because tp is unsigned */
#line 2850
            
#line 2850
        }
#line 2850
        *tp++ = (ulonglong) (signed) (*xp++);  /* type cast from schar to ulonglong */
#line 2850
    }
#line 2850

#line 2850
    *xpp = (const void *)xp;
#line 2850
    return status;
#line 2850
}
#line 2850


#line 2853
int
ncx_pad_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2856

#line 2856
	if (rndup)
#line 2856
		rndup = X_ALIGN - rndup;
#line 2856

#line 2856
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 2856
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2856

#line 2856
	return NC_NOERR;
#line 2856

}
int
#line 2858
ncx_pad_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2858
{
#line 2858
    int status = NC_NOERR;
#line 2858
    size_t rndup = nelems % X_ALIGN;
#line 2858
    schar *xp = (schar *) *xpp;
#line 2858

#line 2858
    if (rndup)
#line 2858
        rndup = X_ALIGN - rndup;
#line 2858

#line 2858
    while (nelems-- != 0) {
#line 2858
        
#line 2858
        if (*xp < 0) {
#line 2858
            
#line 2858
            status = NC_ERANGE; /* because tp is unsigned */
#line 2858
            
#line 2858
        }
#line 2858
        *tp++ = (uchar) (signed) (*xp++);  /* type cast from schar to uchar */
#line 2858
    }
#line 2858

#line 2858
    *xpp = (void *)(xp + rndup);
#line 2858
    return status;
#line 2858
}
#line 2858

int
#line 2859
ncx_pad_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2859
{
#line 2859
    int status = NC_NOERR;
#line 2859
    size_t rndup = nelems % X_ALIGN;
#line 2859
    schar *xp = (schar *) *xpp;
#line 2859

#line 2859
    if (rndup)
#line 2859
        rndup = X_ALIGN - rndup;
#line 2859

#line 2859
    while (nelems-- != 0) {
#line 2859
        
#line 2859
        *tp++ = (short)  (*xp++);  /* type cast from schar to short */
#line 2859
    }
#line 2859

#line 2859
    *xpp = (void *)(xp + rndup);
#line 2859
    return status;
#line 2859
}
#line 2859

int
#line 2860
ncx_pad_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2860
{
#line 2860
    int status = NC_NOERR;
#line 2860
    size_t rndup = nelems % X_ALIGN;
#line 2860
    schar *xp = (schar *) *xpp;
#line 2860

#line 2860
    if (rndup)
#line 2860
        rndup = X_ALIGN - rndup;
#line 2860

#line 2860
    while (nelems-- != 0) {
#line 2860
        
#line 2860
        *tp++ = (int)  (*xp++);  /* type cast from schar to int */
#line 2860
    }
#line 2860

#line 2860
    *xpp = (void *)(xp + rndup);
#line 2860
    return status;
#line 2860
}
#line 2860

int
#line 2861
ncx_pad_getn_schar_long(const void **xpp, size_t nelems, long *tp)
#line 2861
{
#line 2861
    int status = NC_NOERR;
#line 2861
    size_t rndup = nelems % X_ALIGN;
#line 2861
    schar *xp = (schar *) *xpp;
#line 2861

#line 2861
    if (rndup)
#line 2861
        rndup = X_ALIGN - rndup;
#line 2861

#line 2861
    while (nelems-- != 0) {
#line 2861
        
#line 2861
        *tp++ = (long)  (*xp++);  /* type cast from schar to long */
#line 2861
    }
#line 2861

#line 2861
    *xpp = (void *)(xp + rndup);
#line 2861
    return status;
#line 2861
}
#line 2861

int
#line 2862
ncx_pad_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2862
{
#line 2862
    int status = NC_NOERR;
#line 2862
    size_t rndup = nelems % X_ALIGN;
#line 2862
    schar *xp = (schar *) *xpp;
#line 2862

#line 2862
    if (rndup)
#line 2862
        rndup = X_ALIGN - rndup;
#line 2862

#line 2862
    while (nelems-- != 0) {
#line 2862
        
#line 2862
        *tp++ = (float)  (*xp++);  /* type cast from schar to float */
#line 2862
    }
#line 2862

#line 2862
    *xpp = (void *)(xp + rndup);
#line 2862
    return status;
#line 2862
}
#line 2862

int
#line 2863
ncx_pad_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2863
{
#line 2863
    int status = NC_NOERR;
#line 2863
    size_t rndup = nelems % X_ALIGN;
#line 2863
    schar *xp = (schar *) *xpp;
#line 2863

#line 2863
    if (rndup)
#line 2863
        rndup = X_ALIGN - rndup;
#line 2863

#line 2863
    while (nelems-- != 0) {
#line 2863
        
#line 2863
        *tp++ = (double)  (*xp++);  /* type cast from schar to double */
#line 2863
    }
#line 2863

#line 2863
    *xpp = (void *)(xp + rndup);
#line 2863
    return status;
#line 2863
}
#line 2863

int
#line 2864
ncx_pad_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2864
{
#line 2864
    int status = NC_NOERR;
#line 2864
    size_t rndup = nelems % X_ALIGN;
#line 2864
    schar *xp = (schar *) *xpp;
#line 2864

#line 2864
    if (rndup)
#line 2864
        rndup = X_ALIGN - rndup;
#line 2864

#line 2864
    while (nelems-- != 0) {
#line 2864
        
#line 2864
        *tp++ = (longlong)  (*xp++);  /* type cast from schar to longlong */
#line 2864
    }
#line 2864

#line 2864
    *xpp = (void *)(xp + rndup);
#line 2864
    return status;
#line 2864
}
#line 2864

int
#line 2865
ncx_pad_getn_schar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2865
{
#line 2865
    int status = NC_NOERR;
#line 2865
    size_t rndup = nelems % X_ALIGN;
#line 2865
    schar *xp = (schar *) *xpp;
#line 2865

#line 2865
    if (rndup)
#line 2865
        rndup = X_ALIGN - rndup;
#line 2865

#line 2865
    while (nelems-- != 0) {
#line 2865
        
#line 2865
        if (*xp < 0) {
#line 2865
            
#line 2865
            status = NC_ERANGE; /* because tp is unsigned */
#line 2865
            
#line 2865
        }
#line 2865
        *tp++ = (ushort) (signed) (*xp++);  /* type cast from schar to ushort */
#line 2865
    }
#line 2865

#line 2865
    *xpp = (void *)(xp + rndup);
#line 2865
    return status;
#line 2865
}
#line 2865

int
#line 2866
ncx_pad_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2866
{
#line 2866
    int status = NC_NOERR;
#line 2866
    size_t rndup = nelems % X_ALIGN;
#line 2866
    schar *xp = (schar *) *xpp;
#line 2866

#line 2866
    if (rndup)
#line 2866
        rndup = X_ALIGN - rndup;
#line 2866

#line 2866
    while (nelems-- != 0) {
#line 2866
        
#line 2866
        if (*xp < 0) {
#line 2866
            
#line 2866
            status = NC_ERANGE; /* because tp is unsigned */
#line 2866
            
#line 2866
        }
#line 2866
        *tp++ = (uint) (signed) (*xp++);  /* type cast from schar to uint */
#line 2866
    }
#line 2866

#line 2866
    *xpp = (void *)(xp + rndup);
#line 2866
    return status;
#line 2866
}
#line 2866

int
#line 2867
ncx_pad_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2867
{
#line 2867
    int status = NC_NOERR;
#line 2867
    size_t rndup = nelems % X_ALIGN;
#line 2867
    schar *xp = (schar *) *xpp;
#line 2867

#line 2867
    if (rndup)
#line 2867
        rndup = X_ALIGN - rndup;
#line 2867

#line 2867
    while (nelems-- != 0) {
#line 2867
        
#line 2867
        if (*xp < 0) {
#line 2867
            
#line 2867
            status = NC_ERANGE; /* because tp is unsigned */
#line 2867
            
#line 2867
        }
#line 2867
        *tp++ = (ulonglong) (signed) (*xp++);  /* type cast from schar to ulonglong */
#line 2867
    }
#line 2867

#line 2867
    *xpp = (void *)(xp + rndup);
#line 2867
    return status;
#line 2867
}
#line 2867


#line 2870
int
ncx_putn_schar_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
{
		(void) memcpy(*xpp, tp, (size_t)nelems);
#line 2873
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2873

#line 2873
	return NC_NOERR;
#line 2873

}
int
#line 2875
ncx_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 2875
{
#line 2875
    int status = NC_NOERR;
#line 2875
    schar *xp = (schar *) *xpp;
#line 2875

#line 2875
    while (nelems-- != 0) {
#line 2875
        if (*tp > (uchar)X_SCHAR_MAX ) {
#line 2875
            
#line 2875
            status = NC_ERANGE;
#line 2875
            
#line 2875
        }
#line 2875
        *xp++ = (schar)  *tp++; /* type cast from uchar to schar */
#line 2875
    }
#line 2875

#line 2875
    *xpp = (void *)xp;
#line 2875
    return status;
#line 2875
}
#line 2875

int
#line 2876
ncx_putn_schar_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 2876
{
#line 2876
    int status = NC_NOERR;
#line 2876
    schar *xp = (schar *) *xpp;
#line 2876

#line 2876
    while (nelems-- != 0) {
#line 2876
        if (*tp > (short)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2876
            
#line 2876
            status = NC_ERANGE;
#line 2876
            
#line 2876
        }
#line 2876
        *xp++ = (schar)  *tp++; /* type cast from short to schar */
#line 2876
    }
#line 2876

#line 2876
    *xpp = (void *)xp;
#line 2876
    return status;
#line 2876
}
#line 2876

int
#line 2877
ncx_putn_schar_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 2877
{
#line 2877
    int status = NC_NOERR;
#line 2877
    schar *xp = (schar *) *xpp;
#line 2877

#line 2877
    while (nelems-- != 0) {
#line 2877
        if (*tp > (int)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2877
            
#line 2877
            status = NC_ERANGE;
#line 2877
            
#line 2877
        }
#line 2877
        *xp++ = (schar)  *tp++; /* type cast from int to schar */
#line 2877
    }
#line 2877

#line 2877
    *xpp = (void *)xp;
#line 2877
    return status;
#line 2877
}
#line 2877

int
#line 2878
ncx_putn_schar_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 2878
{
#line 2878
    int status = NC_NOERR;
#line 2878
    schar *xp = (schar *) *xpp;
#line 2878

#line 2878
    while (nelems-- != 0) {
#line 2878
        if (*tp > (long)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2878
            
#line 2878
            status = NC_ERANGE;
#line 2878
            
#line 2878
        }
#line 2878
        *xp++ = (schar)  *tp++; /* type cast from long to schar */
#line 2878
    }
#line 2878

#line 2878
    *xpp = (void *)xp;
#line 2878
    return status;
#line 2878
}
#line 2878

int
#line 2879
ncx_putn_schar_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 2879
{
#line 2879
    int status = NC_NOERR;
#line 2879
    schar *xp = (schar *) *xpp;
#line 2879

#line 2879
    while (nelems-- != 0) {
#line 2879
        if (*tp > (float)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2879
            
#line 2879
            status = NC_ERANGE;
#line 2879
            
#line 2879
        }
#line 2879
        *xp++ = (schar)  *tp++; /* type cast from float to schar */
#line 2879
    }
#line 2879

#line 2879
    *xpp = (void *)xp;
#line 2879
    return status;
#line 2879
}
#line 2879

int
#line 2880
ncx_putn_schar_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 2880
{
#line 2880
    int status = NC_NOERR;
#line 2880
    schar *xp = (schar *) *xpp;
#line 2880

#line 2880
    while (nelems-- != 0) {
#line 2880
        if (*tp > (double)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2880
            
#line 2880
            status = NC_ERANGE;
#line 2880
            
#line 2880
        }
#line 2880
        *xp++ = (schar)  *tp++; /* type cast from double to schar */
#line 2880
    }
#line 2880

#line 2880
    *xpp = (void *)xp;
#line 2880
    return status;
#line 2880
}
#line 2880

int
#line 2881
ncx_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 2881
{
#line 2881
    int status = NC_NOERR;
#line 2881
    schar *xp = (schar *) *xpp;
#line 2881

#line 2881
    while (nelems-- != 0) {
#line 2881
        if (*tp > (longlong)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2881
            
#line 2881
            status = NC_ERANGE;
#line 2881
            
#line 2881
        }
#line 2881
        *xp++ = (schar)  *tp++; /* type cast from longlong to schar */
#line 2881
    }
#line 2881

#line 2881
    *xpp = (void *)xp;
#line 2881
    return status;
#line 2881
}
#line 2881

int
#line 2882
ncx_putn_schar_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 2882
{
#line 2882
    int status = NC_NOERR;
#line 2882
    schar *xp = (schar *) *xpp;
#line 2882

#line 2882
    while (nelems-- != 0) {
#line 2882
        if (*tp > (ushort)X_SCHAR_MAX ) {
#line 2882
            
#line 2882
            status = NC_ERANGE;
#line 2882
            
#line 2882
        }
#line 2882
        *xp++ = (schar)  *tp++; /* type cast from ushort to schar */
#line 2882
    }
#line 2882

#line 2882
    *xpp = (void *)xp;
#line 2882
    return status;
#line 2882
}
#line 2882

int
#line 2883
ncx_putn_schar_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 2883
{
#line 2883
    int status = NC_NOERR;
#line 2883
    schar *xp = (schar *) *xpp;
#line 2883

#line 2883
    while (nelems-- != 0) {
#line 2883
        if (*tp > (uint)X_SCHAR_MAX ) {
#line 2883
            
#line 2883
            status = NC_ERANGE;
#line 2883
            
#line 2883
        }
#line 2883
        *xp++ = (schar)  *tp++; /* type cast from uint to schar */
#line 2883
    }
#line 2883

#line 2883
    *xpp = (void *)xp;
#line 2883
    return status;
#line 2883
}
#line 2883

int
#line 2884
ncx_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 2884
{
#line 2884
    int status = NC_NOERR;
#line 2884
    schar *xp = (schar *) *xpp;
#line 2884

#line 2884
    while (nelems-- != 0) {
#line 2884
        if (*tp > (ulonglong)X_SCHAR_MAX ) {
#line 2884
            
#line 2884
            status = NC_ERANGE;
#line 2884
            
#line 2884
        }
#line 2884
        *xp++ = (schar)  *tp++; /* type cast from ulonglong to schar */
#line 2884
    }
#line 2884

#line 2884
    *xpp = (void *)xp;
#line 2884
    return status;
#line 2884
}
#line 2884


#line 2887
int
ncx_pad_putn_schar_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2890

#line 2890
	if (rndup)
#line 2890
		rndup = X_ALIGN - rndup;
#line 2890

#line 2890
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 2890
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2890

#line 2890
	if (rndup)
#line 2890
	{
#line 2890
		(void) memcpy(*xpp, nada, (size_t)rndup);
#line 2890
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2890
	}
#line 2890

#line 2890
	return NC_NOERR;
#line 2890

}
int
#line 2892
ncx_pad_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 2892
{
#line 2892
    int status = NC_NOERR;
#line 2892
    size_t rndup = nelems % X_ALIGN;
#line 2892
    schar *xp = (schar *) *xpp;
#line 2892

#line 2892
    if (rndup) rndup = X_ALIGN - rndup;
#line 2892

#line 2892
    while (nelems-- != 0) {
#line 2892
        if (*tp > (uchar)X_SCHAR_MAX ) {
#line 2892
            
#line 2892
            status = NC_ERANGE;
#line 2892
            
#line 2892
        }
#line 2892
        *xp++ = (schar)  *tp++; /* type cast from uchar to schar */
#line 2892
    }
#line 2892

#line 2892

#line 2892
    if (rndup) {
#line 2892
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2892
        xp += rndup;
#line 2892
    }
#line 2892

#line 2892
    *xpp = (void *)xp;
#line 2892
    return status;
#line 2892
}
#line 2892

int
#line 2893
ncx_pad_putn_schar_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 2893
{
#line 2893
    int status = NC_NOERR;
#line 2893
    size_t rndup = nelems % X_ALIGN;
#line 2893
    schar *xp = (schar *) *xpp;
#line 2893

#line 2893
    if (rndup) rndup = X_ALIGN - rndup;
#line 2893

#line 2893
    while (nelems-- != 0) {
#line 2893
        if (*tp > (short)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2893
            
#line 2893
            status = NC_ERANGE;
#line 2893
            
#line 2893
        }
#line 2893
        *xp++ = (schar)  *tp++; /* type cast from short to schar */
#line 2893
    }
#line 2893

#line 2893

#line 2893
    if (rndup) {
#line 2893
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2893
        xp += rndup;
#line 2893
    }
#line 2893

#line 2893
    *xpp = (void *)xp;
#line 2893
    return status;
#line 2893
}
#line 2893

int
#line 2894
ncx_pad_putn_schar_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 2894
{
#line 2894
    int status = NC_NOERR;
#line 2894
    size_t rndup = nelems % X_ALIGN;
#line 2894
    schar *xp = (schar *) *xpp;
#line 2894

#line 2894
    if (rndup) rndup = X_ALIGN - rndup;
#line 2894

#line 2894
    while (nelems-- != 0) {
#line 2894
        if (*tp > (int)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2894
            
#line 2894
            status = NC_ERANGE;
#line 2894
            
#line 2894
        }
#line 2894
        *xp++ = (schar)  *tp++; /* type cast from int to schar */
#line 2894
    }
#line 2894

#line 2894

#line 2894
    if (rndup) {
#line 2894
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2894
        xp += rndup;
#line 2894
    }
#line 2894

#line 2894
    *xpp = (void *)xp;
#line 2894
    return status;
#line 2894
}
#line 2894

int
#line 2895
ncx_pad_putn_schar_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 2895
{
#line 2895
    int status = NC_NOERR;
#line 2895
    size_t rndup = nelems % X_ALIGN;
#line 2895
    schar *xp = (schar *) *xpp;
#line 2895

#line 2895
    if (rndup) rndup = X_ALIGN - rndup;
#line 2895

#line 2895
    while (nelems-- != 0) {
#line 2895
        if (*tp > (long)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2895
            
#line 2895
            status = NC_ERANGE;
#line 2895
            
#line 2895
        }
#line 2895
        *xp++ = (schar)  *tp++; /* type cast from long to schar */
#line 2895
    }
#line 2895

#line 2895

#line 2895
    if (rndup) {
#line 2895
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2895
        xp += rndup;
#line 2895
    }
#line 2895

#line 2895
    *xpp = (void *)xp;
#line 2895
    return status;
#line 2895
}
#line 2895

int
#line 2896
ncx_pad_putn_schar_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 2896
{
#line 2896
    int status = NC_NOERR;
#line 2896
    size_t rndup = nelems % X_ALIGN;
#line 2896
    schar *xp = (schar *) *xpp;
#line 2896

#line 2896
    if (rndup) rndup = X_ALIGN - rndup;
#line 2896

#line 2896
    while (nelems-- != 0) {
#line 2896
        if (*tp > (float)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2896
            
#line 2896
            status = NC_ERANGE;
#line 2896
            
#line 2896
        }
#line 2896
        *xp++ = (schar)  *tp++; /* type cast from float to schar */
#line 2896
    }
#line 2896

#line 2896

#line 2896
    if (rndup) {
#line 2896
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2896
        xp += rndup;
#line 2896
    }
#line 2896

#line 2896
    *xpp = (void *)xp;
#line 2896
    return status;
#line 2896
}
#line 2896

int
#line 2897
ncx_pad_putn_schar_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 2897
{
#line 2897
    int status = NC_NOERR;
#line 2897
    size_t rndup = nelems % X_ALIGN;
#line 2897
    schar *xp = (schar *) *xpp;
#line 2897

#line 2897
    if (rndup) rndup = X_ALIGN - rndup;
#line 2897

#line 2897
    while (nelems-- != 0) {
#line 2897
        if (*tp > (double)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2897
            
#line 2897
            status = NC_ERANGE;
#line 2897
            
#line 2897
        }
#line 2897
        *xp++ = (schar)  *tp++; /* type cast from double to schar */
#line 2897
    }
#line 2897

#line 2897

#line 2897
    if (rndup) {
#line 2897
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2897
        xp += rndup;
#line 2897
    }
#line 2897

#line 2897
    *xpp = (void *)xp;
#line 2897
    return status;
#line 2897
}
#line 2897

int
#line 2898
ncx_pad_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 2898
{
#line 2898
    int status = NC_NOERR;
#line 2898
    size_t rndup = nelems % X_ALIGN;
#line 2898
    schar *xp = (schar *) *xpp;
#line 2898

#line 2898
    if (rndup) rndup = X_ALIGN - rndup;
#line 2898

#line 2898
    while (nelems-- != 0) {
#line 2898
        if (*tp > (longlong)X_SCHAR_MAX || *tp < X_SCHAR_MIN) {
#line 2898
            
#line 2898
            status = NC_ERANGE;
#line 2898
            
#line 2898
        }
#line 2898
        *xp++ = (schar)  *tp++; /* type cast from longlong to schar */
#line 2898
    }
#line 2898

#line 2898

#line 2898
    if (rndup) {
#line 2898
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2898
        xp += rndup;
#line 2898
    }
#line 2898

#line 2898
    *xpp = (void *)xp;
#line 2898
    return status;
#line 2898
}
#line 2898

int
#line 2899
ncx_pad_putn_schar_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 2899
{
#line 2899
    int status = NC_NOERR;
#line 2899
    size_t rndup = nelems % X_ALIGN;
#line 2899
    schar *xp = (schar *) *xpp;
#line 2899

#line 2899
    if (rndup) rndup = X_ALIGN - rndup;
#line 2899

#line 2899
    while (nelems-- != 0) {
#line 2899
        if (*tp > (ushort)X_SCHAR_MAX ) {
#line 2899
            
#line 2899
            status = NC_ERANGE;
#line 2899
            
#line 2899
        }
#line 2899
        *xp++ = (schar)  *tp++; /* type cast from ushort to schar */
#line 2899
    }
#line 2899

#line 2899

#line 2899
    if (rndup) {
#line 2899
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2899
        xp += rndup;
#line 2899
    }
#line 2899

#line 2899
    *xpp = (void *)xp;
#line 2899
    return status;
#line 2899
}
#line 2899

int
#line 2900
ncx_pad_putn_schar_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 2900
{
#line 2900
    int status = NC_NOERR;
#line 2900
    size_t rndup = nelems % X_ALIGN;
#line 2900
    schar *xp = (schar *) *xpp;
#line 2900

#line 2900
    if (rndup) rndup = X_ALIGN - rndup;
#line 2900

#line 2900
    while (nelems-- != 0) {
#line 2900
        if (*tp > (uint)X_SCHAR_MAX ) {
#line 2900
            
#line 2900
            status = NC_ERANGE;
#line 2900
            
#line 2900
        }
#line 2900
        *xp++ = (schar)  *tp++; /* type cast from uint to schar */
#line 2900
    }
#line 2900

#line 2900

#line 2900
    if (rndup) {
#line 2900
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2900
        xp += rndup;
#line 2900
    }
#line 2900

#line 2900
    *xpp = (void *)xp;
#line 2900
    return status;
#line 2900
}
#line 2900

int
#line 2901
ncx_pad_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 2901
{
#line 2901
    int status = NC_NOERR;
#line 2901
    size_t rndup = nelems % X_ALIGN;
#line 2901
    schar *xp = (schar *) *xpp;
#line 2901

#line 2901
    if (rndup) rndup = X_ALIGN - rndup;
#line 2901

#line 2901
    while (nelems-- != 0) {
#line 2901
        if (*tp > (ulonglong)X_SCHAR_MAX ) {
#line 2901
            
#line 2901
            status = NC_ERANGE;
#line 2901
            
#line 2901
        }
#line 2901
        *xp++ = (schar)  *tp++; /* type cast from ulonglong to schar */
#line 2901
    }
#line 2901

#line 2901

#line 2901
    if (rndup) {
#line 2901
        (void) memcpy(xp, nada, (size_t)rndup);
#line 2901
        xp += rndup;
#line 2901
    }
#line 2901

#line 2901
    *xpp = (void *)xp;
#line 2901
    return status;
#line 2901
}
#line 2901



/* uchar ---------------------------------------------------------------------*/
#line 2907
int
ncx_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
    int status = NC_NOERR;
    uchar *xp = (uchar *)(*xpp);

    while (nelems-- != 0) {
        if (*xp > SCHAR_MAX) {
            *tp = NC_FILL_BYTE;
       	    status = NC_ERANGE;
            
        }
	*tp++ = (schar) *xp++; /* type cast from uchar to schar */
    }

    *xpp = (const void *)xp;
    return status;
}
#line 2926
int
ncx_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, (size_t)nelems);
#line 2929
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2929
	return NC_NOERR;
#line 2929

}
int
#line 2931
ncx_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2931
{
#line 2931
    int status = NC_NOERR;
#line 2931
    uchar *xp = (uchar *)(*xpp);
#line 2931

#line 2931
    while (nelems-- != 0) {
#line 2931
        
#line 2931
        *tp++ = (short)  (*xp++);  /* type cast from uchar to short */
#line 2931
    }
#line 2931

#line 2931
    *xpp = (const void *)xp;
#line 2931
    return status;
#line 2931
}
#line 2931

int
#line 2932
ncx_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2932
{
#line 2932
    int status = NC_NOERR;
#line 2932
    uchar *xp = (uchar *)(*xpp);
#line 2932

#line 2932
    while (nelems-- != 0) {
#line 2932
        
#line 2932
        *tp++ = (int)  (*xp++);  /* type cast from uchar to int */
#line 2932
    }
#line 2932

#line 2932
    *xpp = (const void *)xp;
#line 2932
    return status;
#line 2932
}
#line 2932

int
#line 2933
ncx_getn_uchar_long(const void **xpp, size_t nelems, long *tp)
#line 2933
{
#line 2933
    int status = NC_NOERR;
#line 2933
    uchar *xp = (uchar *)(*xpp);
#line 2933

#line 2933
    while (nelems-- != 0) {
#line 2933
        
#line 2933
        *tp++ = (long)  (*xp++);  /* type cast from uchar to long */
#line 2933
    }
#line 2933

#line 2933
    *xpp = (const void *)xp;
#line 2933
    return status;
#line 2933
}
#line 2933

int
#line 2934
ncx_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2934
{
#line 2934
    int status = NC_NOERR;
#line 2934
    uchar *xp = (uchar *)(*xpp);
#line 2934

#line 2934
    while (nelems-- != 0) {
#line 2934
        
#line 2934
        *tp++ = (float)  (*xp++);  /* type cast from uchar to float */
#line 2934
    }
#line 2934

#line 2934
    *xpp = (const void *)xp;
#line 2934
    return status;
#line 2934
}
#line 2934

int
#line 2935
ncx_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2935
{
#line 2935
    int status = NC_NOERR;
#line 2935
    uchar *xp = (uchar *)(*xpp);
#line 2935

#line 2935
    while (nelems-- != 0) {
#line 2935
        
#line 2935
        *tp++ = (double)  (*xp++);  /* type cast from uchar to double */
#line 2935
    }
#line 2935

#line 2935
    *xpp = (const void *)xp;
#line 2935
    return status;
#line 2935
}
#line 2935

int
#line 2936
ncx_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2936
{
#line 2936
    int status = NC_NOERR;
#line 2936
    uchar *xp = (uchar *)(*xpp);
#line 2936

#line 2936
    while (nelems-- != 0) {
#line 2936
        
#line 2936
        *tp++ = (longlong)  (*xp++);  /* type cast from uchar to longlong */
#line 2936
    }
#line 2936

#line 2936
    *xpp = (const void *)xp;
#line 2936
    return status;
#line 2936
}
#line 2936

int
#line 2937
ncx_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2937
{
#line 2937
    int status = NC_NOERR;
#line 2937
    uchar *xp = (uchar *)(*xpp);
#line 2937

#line 2937
    while (nelems-- != 0) {
#line 2937
        
#line 2937
        *tp++ = (ushort)  (*xp++);  /* type cast from uchar to ushort */
#line 2937
    }
#line 2937

#line 2937
    *xpp = (const void *)xp;
#line 2937
    return status;
#line 2937
}
#line 2937

int
#line 2938
ncx_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2938
{
#line 2938
    int status = NC_NOERR;
#line 2938
    uchar *xp = (uchar *)(*xpp);
#line 2938

#line 2938
    while (nelems-- != 0) {
#line 2938
        
#line 2938
        *tp++ = (uint)  (*xp++);  /* type cast from uchar to uint */
#line 2938
    }
#line 2938

#line 2938
    *xpp = (const void *)xp;
#line 2938
    return status;
#line 2938
}
#line 2938

int
#line 2939
ncx_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2939
{
#line 2939
    int status = NC_NOERR;
#line 2939
    uchar *xp = (uchar *)(*xpp);
#line 2939

#line 2939
    while (nelems-- != 0) {
#line 2939
        
#line 2939
        *tp++ = (ulonglong)  (*xp++);  /* type cast from uchar to ulonglong */
#line 2939
    }
#line 2939

#line 2939
    *xpp = (const void *)xp;
#line 2939
    return status;
#line 2939
}
#line 2939


#line 2942
int
ncx_pad_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
    int status = NC_NOERR;
    size_t rndup = nelems % X_ALIGN;
    uchar *xp = (uchar *) *xpp;

    if (rndup) rndup = X_ALIGN - rndup;

    while (nelems-- != 0) {
        if (*xp > SCHAR_MAX) {
            *tp = NC_FILL_BYTE;
            status = NC_ERANGE;
            
        }
        *tp++ = (schar) *xp++; /* type cast from uchar to schar */
    }

    *xpp = (void *)(xp + rndup);
    return status;
}
#line 2964
int
ncx_pad_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2967

#line 2967
	if (rndup)
#line 2967
		rndup = X_ALIGN - rndup;
#line 2967

#line 2967
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 2967
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2967

#line 2967
	return NC_NOERR;
#line 2967

}
int
#line 2969
ncx_pad_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2969
{
#line 2969
    int status = NC_NOERR;
#line 2969
    size_t rndup = nelems % X_ALIGN;
#line 2969
    uchar *xp = (uchar *) *xpp;
#line 2969

#line 2969
    if (rndup)
#line 2969
        rndup = X_ALIGN - rndup;
#line 2969

#line 2969
    while (nelems-- != 0) {
#line 2969
        
#line 2969
        *tp++ = (short)  (*xp++);  /* type cast from uchar to short */
#line 2969
    }
#line 2969

#line 2969
    *xpp = (void *)(xp + rndup);
#line 2969
    return status;
#line 2969
}
#line 2969

int
#line 2970
ncx_pad_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2970
{
#line 2970
    int status = NC_NOERR;
#line 2970
    size_t rndup = nelems % X_ALIGN;
#line 2970
    uchar *xp = (uchar *) *xpp;
#line 2970

#line 2970
    if (rndup)
#line 2970
        rndup = X_ALIGN - rndup;
#line 2970

#line 2970
    while (nelems-- != 0) {
#line 2970
        
#line 2970
        *tp++ = (int)  (*xp++);  /* type cast from uchar to int */
#line 2970
    }
#line 2970

#line 2970
    *xpp = (void *)(xp + rndup);
#line 2970
    return status;
#line 2970
}
#line 2970

int
#line 2971
ncx_pad_getn_uchar_long(const void **xpp, size_t nelems, long *tp)
#line 2971
{
#line 2971
    int status = NC_NOERR;
#line 2971
    size_t rndup = nelems % X_ALIGN;
#line 2971
    uchar *xp = (uchar *) *xpp;
#line 2971

#line 2971
    if (rndup)
#line 2971
        rndup = X_ALIGN - rndup;
#line 2971

#line 2971
    while (nelems-- != 0) {
#line 2971
        
#line 2971
        *tp++ = (long)  (*xp++);  /* type cast from uchar to long */
#line 2971
    }
#line 2971

#line 2971
    *xpp = (void *)(xp + rndup);
#line 2971
    return status;
#line 2971
}
#line 2971

int
#line 2972
ncx_pad_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2972
{
#line 2972
    int status = NC_NOERR;
#line 2972
    size_t rndup = nelems % X_ALIGN;
#line 2972
    uchar *xp = (uchar *) *xpp;
#line 2972

#line 2972
    if (rndup)
#line 2972
        rndup = X_ALIGN - rndup;
#line 2972

#line 2972
    while (nelems-- != 0) {
#line 2972
        
#line 2972
        *tp++ = (float)  (*xp++);  /* type cast from uchar to float */
#line 2972
    }
#line 2972

#line 2972
    *xpp = (void *)(xp + rndup);
#line 2972
    return status;
#line 2972
}
#line 2972

int
#line 2973
ncx_pad_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2973
{
#line 2973
    int status = NC_NOERR;
#line 2973
    size_t rndup = nelems % X_ALIGN;
#line 2973
    uchar *xp = (uchar *) *xpp;
#line 2973

#line 2973
    if (rndup)
#line 2973
        rndup = X_ALIGN - rndup;
#line 2973

#line 2973
    while (nelems-- != 0) {
#line 2973
        
#line 2973
        *tp++ = (double)  (*xp++);  /* type cast from uchar to double */
#line 2973
    }
#line 2973

#line 2973
    *xpp = (void *)(xp + rndup);
#line 2973
    return status;
#line 2973
}
#line 2973

int
#line 2974
ncx_pad_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2974
{
#line 2974
    int status = NC_NOERR;
#line 2974
    size_t rndup = nelems % X_ALIGN;
#line 2974
    uchar *xp = (uchar *) *xpp;
#line 2974

#line 2974
    if (rndup)
#line 2974
        rndup = X_ALIGN - rndup;
#line 2974

#line 2974
    while (nelems-- != 0) {
#line 2974
        
#line 2974
        *tp++ = (longlong)  (*xp++);  /* type cast from uchar to longlong */
#line 2974
    }
#line 2974

#line 2974
    *xpp = (void *)(xp + rndup);
#line 2974
    return status;
#line 2974
}
#line 2974

int
#line 2975
ncx_pad_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2975
{
#line 2975
    int status = NC_NOERR;
#line 2975
    size_t rndup = nelems % X_ALIGN;
#line 2975
    uchar *xp = (uchar *) *xpp;
#line 2975

#line 2975
    if (rndup)
#line 2975
        rndup = X_ALIGN - rndup;
#line 2975

#line 2975
    while (nelems-- != 0) {
#line 2975
        
#line 2975
        *tp++ = (ushort)  (*xp++);  /* type cast from uchar to ushort */
#line 2975
    }
#line 2975

#line 2975
    *xpp = (void *)(xp + rndup);
#line 2975
    return status;
#line 2975
}
#line 2975

int
#line 2976
ncx_pad_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2976
{
#line 2976
    int status = NC_NOERR;
#line 2976
    size_t rndup = nelems % X_ALIGN;
#line 2976
    uchar *xp = (uchar *) *xpp;
#line 2976

#line 2976
    if (rndup)
#line 2976
        rndup = X_ALIGN - rndup;
#line 2976

#line 2976
    while (nelems-- != 0) {
#line 2976
        
#line 2976
        *tp++ = (uint)  (*xp++);  /* type cast from uchar to uint */
#line 2976
    }
#line 2976

#line 2976
    *xpp = (void *)(xp + rndup);
#line 2976
    return status;
#line 2976
}
#line 2976

int
#line 2977
ncx_pad_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2977
{
#line 2977
    int status = NC_NOERR;
#line 2977
    size_t rndup = nelems % X_ALIGN;
#line 2977
    uchar *xp = (uchar *) *xpp;
#line 2977

#line 2977
    if (rndup)
#line 2977
        rndup = X_ALIGN - rndup;
#line 2977

#line 2977
    while (nelems-- != 0) {
#line 2977
        
#line 2977
        *tp++ = (ulonglong)  (*xp++);  /* type cast from uchar to ulonglong */
#line 2977
    }
#line 2977

#line 2977
    *xpp = (void *)(xp + rndup);
#line 2977
    return status;
#line 2977
}
#line 2977


#line 2980
int
ncx_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
{
    int status = NC_NOERR;
    uchar *xp = (uchar *) *xpp;

    while (nelems-- != 0) {
        if (*tp < 0) {
            
            status = NC_ERANGE;
            
        }
        *xp++ = (uchar) (signed) *tp++; /* type cast from schar to uchar */
    }

    *xpp = (void *)xp;
    return status;
}
#line 2999
int
ncx_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
{
		(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3002
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3002

#line 3002
	return NC_NOERR;
#line 3002

}
int
#line 3004
ncx_putn_uchar_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3004
{
#line 3004
    int status = NC_NOERR;
#line 3004
    uchar *xp = (uchar *) *xpp;
#line 3004

#line 3004
    while (nelems-- != 0) {
#line 3004
        if (*tp > (short)X_UCHAR_MAX || *tp < 0) {
#line 3004
            
#line 3004
            status = NC_ERANGE;
#line 3004
            
#line 3004
        }
#line 3004
        *xp++ = (uchar) (signed) *tp++; /* type cast from short to uchar */
#line 3004
    }
#line 3004

#line 3004
    *xpp = (void *)xp;
#line 3004
    return status;
#line 3004
}
#line 3004

int
#line 3005
ncx_putn_uchar_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3005
{
#line 3005
    int status = NC_NOERR;
#line 3005
    uchar *xp = (uchar *) *xpp;
#line 3005

#line 3005
    while (nelems-- != 0) {
#line 3005
        if (*tp > (int)X_UCHAR_MAX || *tp < 0) {
#line 3005
            
#line 3005
            status = NC_ERANGE;
#line 3005
            
#line 3005
        }
#line 3005
        *xp++ = (uchar) (signed) *tp++; /* type cast from int to uchar */
#line 3005
    }
#line 3005

#line 3005
    *xpp = (void *)xp;
#line 3005
    return status;
#line 3005
}
#line 3005

int
#line 3006
ncx_putn_uchar_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3006
{
#line 3006
    int status = NC_NOERR;
#line 3006
    uchar *xp = (uchar *) *xpp;
#line 3006

#line 3006
    while (nelems-- != 0) {
#line 3006
        if (*tp > (long)X_UCHAR_MAX || *tp < 0) {
#line 3006
            
#line 3006
            status = NC_ERANGE;
#line 3006
            
#line 3006
        }
#line 3006
        *xp++ = (uchar) (signed) *tp++; /* type cast from long to uchar */
#line 3006
    }
#line 3006

#line 3006
    *xpp = (void *)xp;
#line 3006
    return status;
#line 3006
}
#line 3006

int
#line 3007
ncx_putn_uchar_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3007
{
#line 3007
    int status = NC_NOERR;
#line 3007
    uchar *xp = (uchar *) *xpp;
#line 3007

#line 3007
    while (nelems-- != 0) {
#line 3007
        if (*tp > (float)X_UCHAR_MAX || *tp < 0) {
#line 3007
            
#line 3007
            status = NC_ERANGE;
#line 3007
            
#line 3007
        }
#line 3007
        *xp++ = (uchar) (signed) *tp++; /* type cast from float to uchar */
#line 3007
    }
#line 3007

#line 3007
    *xpp = (void *)xp;
#line 3007
    return status;
#line 3007
}
#line 3007

int
#line 3008
ncx_putn_uchar_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3008
{
#line 3008
    int status = NC_NOERR;
#line 3008
    uchar *xp = (uchar *) *xpp;
#line 3008

#line 3008
    while (nelems-- != 0) {
#line 3008
        if (*tp > (double)X_UCHAR_MAX || *tp < 0) {
#line 3008
            
#line 3008
            status = NC_ERANGE;
#line 3008
            
#line 3008
        }
#line 3008
        *xp++ = (uchar) (signed) *tp++; /* type cast from double to uchar */
#line 3008
    }
#line 3008

#line 3008
    *xpp = (void *)xp;
#line 3008
    return status;
#line 3008
}
#line 3008

int
#line 3009
ncx_putn_uchar_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3009
{
#line 3009
    int status = NC_NOERR;
#line 3009
    uchar *xp = (uchar *) *xpp;
#line 3009

#line 3009
    while (nelems-- != 0) {
#line 3009
        if (*tp > (longlong)X_UCHAR_MAX || *tp < 0) {
#line 3009
            
#line 3009
            status = NC_ERANGE;
#line 3009
            
#line 3009
        }
#line 3009
        *xp++ = (uchar) (signed) *tp++; /* type cast from longlong to uchar */
#line 3009
    }
#line 3009

#line 3009
    *xpp = (void *)xp;
#line 3009
    return status;
#line 3009
}
#line 3009

int
#line 3010
ncx_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3010
{
#line 3010
    int status = NC_NOERR;
#line 3010
    uchar *xp = (uchar *) *xpp;
#line 3010

#line 3010
    while (nelems-- != 0) {
#line 3010
        if (*tp > (ushort)X_UCHAR_MAX ) {
#line 3010
            
#line 3010
            status = NC_ERANGE;
#line 3010
            
#line 3010
        }
#line 3010
        *xp++ = (uchar)  *tp++; /* type cast from ushort to uchar */
#line 3010
    }
#line 3010

#line 3010
    *xpp = (void *)xp;
#line 3010
    return status;
#line 3010
}
#line 3010

int
#line 3011
ncx_putn_uchar_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3011
{
#line 3011
    int status = NC_NOERR;
#line 3011
    uchar *xp = (uchar *) *xpp;
#line 3011

#line 3011
    while (nelems-- != 0) {
#line 3011
        if (*tp > (uint)X_UCHAR_MAX ) {
#line 3011
            
#line 3011
            status = NC_ERANGE;
#line 3011
            
#line 3011
        }
#line 3011
        *xp++ = (uchar)  *tp++; /* type cast from uint to uchar */
#line 3011
    }
#line 3011

#line 3011
    *xpp = (void *)xp;
#line 3011
    return status;
#line 3011
}
#line 3011

int
#line 3012
ncx_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3012
{
#line 3012
    int status = NC_NOERR;
#line 3012
    uchar *xp = (uchar *) *xpp;
#line 3012

#line 3012
    while (nelems-- != 0) {
#line 3012
        if (*tp > (ulonglong)X_UCHAR_MAX ) {
#line 3012
            
#line 3012
            status = NC_ERANGE;
#line 3012
            
#line 3012
        }
#line 3012
        *xp++ = (uchar)  *tp++; /* type cast from ulonglong to uchar */
#line 3012
    }
#line 3012

#line 3012
    *xpp = (void *)xp;
#line 3012
    return status;
#line 3012
}
#line 3012


#line 3015
int
ncx_pad_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
{
    int status = NC_NOERR;
    size_t rndup = nelems % X_ALIGN;
    uchar *xp = (uchar *) *xpp;

    if (rndup) rndup = X_ALIGN - rndup;

    while (nelems-- != 0) {
        if (*tp < 0) {
            
            status = NC_ERANGE;
            
        }
        *xp++ = (uchar) (signed) *tp++; /* type cast from schar to uchar */
    }

    if (rndup) {
        (void) memcpy(xp, nada, (size_t)rndup);
        xp += rndup;
    }

    *xpp = (void *)xp;
    return status;
}
#line 3042
int
ncx_pad_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
{
		size_t rndup = nelems % X_ALIGN;
#line 3045

#line 3045
	if (rndup)
#line 3045
		rndup = X_ALIGN - rndup;
#line 3045

#line 3045
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3045
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3045

#line 3045
	if (rndup)
#line 3045
	{
#line 3045
		(void) memcpy(*xpp, nada, (size_t)rndup);
#line 3045
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3045
	}
#line 3045

#line 3045
	return NC_NOERR;
#line 3045

}
int
#line 3047
ncx_pad_putn_uchar_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3047
{
#line 3047
    int status = NC_NOERR;
#line 3047
    size_t rndup = nelems % X_ALIGN;
#line 3047
    uchar *xp = (uchar *) *xpp;
#line 3047

#line 3047
    if (rndup) rndup = X_ALIGN - rndup;
#line 3047

#line 3047
    while (nelems-- != 0) {
#line 3047
        if (*tp > (short)X_UCHAR_MAX || *tp < 0) {
#line 3047
            
#line 3047
            status = NC_ERANGE;
#line 3047
            
#line 3047
        }
#line 3047
        *xp++ = (uchar) (signed) *tp++; /* type cast from short to uchar */
#line 3047
    }
#line 3047

#line 3047

#line 3047
    if (rndup) {
#line 3047
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3047
        xp += rndup;
#line 3047
    }
#line 3047

#line 3047
    *xpp = (void *)xp;
#line 3047
    return status;
#line 3047
}
#line 3047

int
#line 3048
ncx_pad_putn_uchar_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3048
{
#line 3048
    int status = NC_NOERR;
#line 3048
    size_t rndup = nelems % X_ALIGN;
#line 3048
    uchar *xp = (uchar *) *xpp;
#line 3048

#line 3048
    if (rndup) rndup = X_ALIGN - rndup;
#line 3048

#line 3048
    while (nelems-- != 0) {
#line 3048
        if (*tp > (int)X_UCHAR_MAX || *tp < 0) {
#line 3048
            
#line 3048
            status = NC_ERANGE;
#line 3048
            
#line 3048
        }
#line 3048
        *xp++ = (uchar) (signed) *tp++; /* type cast from int to uchar */
#line 3048
    }
#line 3048

#line 3048

#line 3048
    if (rndup) {
#line 3048
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3048
        xp += rndup;
#line 3048
    }
#line 3048

#line 3048
    *xpp = (void *)xp;
#line 3048
    return status;
#line 3048
}
#line 3048

int
#line 3049
ncx_pad_putn_uchar_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3049
{
#line 3049
    int status = NC_NOERR;
#line 3049
    size_t rndup = nelems % X_ALIGN;
#line 3049
    uchar *xp = (uchar *) *xpp;
#line 3049

#line 3049
    if (rndup) rndup = X_ALIGN - rndup;
#line 3049

#line 3049
    while (nelems-- != 0) {
#line 3049
        if (*tp > (long)X_UCHAR_MAX || *tp < 0) {
#line 3049
            
#line 3049
            status = NC_ERANGE;
#line 3049
            
#line 3049
        }
#line 3049
        *xp++ = (uchar) (signed) *tp++; /* type cast from long to uchar */
#line 3049
    }
#line 3049

#line 3049

#line 3049
    if (rndup) {
#line 3049
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3049
        xp += rndup;
#line 3049
    }
#line 3049

#line 3049
    *xpp = (void *)xp;
#line 3049
    return status;
#line 3049
}
#line 3049

int
#line 3050
ncx_pad_putn_uchar_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3050
{
#line 3050
    int status = NC_NOERR;
#line 3050
    size_t rndup = nelems % X_ALIGN;
#line 3050
    uchar *xp = (uchar *) *xpp;
#line 3050

#line 3050
    if (rndup) rndup = X_ALIGN - rndup;
#line 3050

#line 3050
    while (nelems-- != 0) {
#line 3050
        if (*tp > (float)X_UCHAR_MAX || *tp < 0) {
#line 3050
            
#line 3050
            status = NC_ERANGE;
#line 3050
            
#line 3050
        }
#line 3050
        *xp++ = (uchar) (signed) *tp++; /* type cast from float to uchar */
#line 3050
    }
#line 3050

#line 3050

#line 3050
    if (rndup) {
#line 3050
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3050
        xp += rndup;
#line 3050
    }
#line 3050

#line 3050
    *xpp = (void *)xp;
#line 3050
    return status;
#line 3050
}
#line 3050

int
#line 3051
ncx_pad_putn_uchar_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3051
{
#line 3051
    int status = NC_NOERR;
#line 3051
    size_t rndup = nelems % X_ALIGN;
#line 3051
    uchar *xp = (uchar *) *xpp;
#line 3051

#line 3051
    if (rndup) rndup = X_ALIGN - rndup;
#line 3051

#line 3051
    while (nelems-- != 0) {
#line 3051
        if (*tp > (double)X_UCHAR_MAX || *tp < 0) {
#line 3051
            
#line 3051
            status = NC_ERANGE;
#line 3051
            
#line 3051
        }
#line 3051
        *xp++ = (uchar) (signed) *tp++; /* type cast from double to uchar */
#line 3051
    }
#line 3051

#line 3051

#line 3051
    if (rndup) {
#line 3051
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3051
        xp += rndup;
#line 3051
    }
#line 3051

#line 3051
    *xpp = (void *)xp;
#line 3051
    return status;
#line 3051
}
#line 3051

int
#line 3052
ncx_pad_putn_uchar_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3052
{
#line 3052
    int status = NC_NOERR;
#line 3052
    size_t rndup = nelems % X_ALIGN;
#line 3052
    uchar *xp = (uchar *) *xpp;
#line 3052

#line 3052
    if (rndup) rndup = X_ALIGN - rndup;
#line 3052

#line 3052
    while (nelems-- != 0) {
#line 3052
        if (*tp > (longlong)X_UCHAR_MAX || *tp < 0) {
#line 3052
            
#line 3052
            status = NC_ERANGE;
#line 3052
            
#line 3052
        }
#line 3052
        *xp++ = (uchar) (signed) *tp++; /* type cast from longlong to uchar */
#line 3052
    }
#line 3052

#line 3052

#line 3052
    if (rndup) {
#line 3052
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3052
        xp += rndup;
#line 3052
    }
#line 3052

#line 3052
    *xpp = (void *)xp;
#line 3052
    return status;
#line 3052
}
#line 3052

int
#line 3053
ncx_pad_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3053
{
#line 3053
    int status = NC_NOERR;
#line 3053
    size_t rndup = nelems % X_ALIGN;
#line 3053
    uchar *xp = (uchar *) *xpp;
#line 3053

#line 3053
    if (rndup) rndup = X_ALIGN - rndup;
#line 3053

#line 3053
    while (nelems-- != 0) {
#line 3053
        if (*tp > (ushort)X_UCHAR_MAX ) {
#line 3053
            
#line 3053
            status = NC_ERANGE;
#line 3053
            
#line 3053
        }
#line 3053
        *xp++ = (uchar)  *tp++; /* type cast from ushort to uchar */
#line 3053
    }
#line 3053

#line 3053

#line 3053
    if (rndup) {
#line 3053
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3053
        xp += rndup;
#line 3053
    }
#line 3053

#line 3053
    *xpp = (void *)xp;
#line 3053
    return status;
#line 3053
}
#line 3053

int
#line 3054
ncx_pad_putn_uchar_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3054
{
#line 3054
    int status = NC_NOERR;
#line 3054
    size_t rndup = nelems % X_ALIGN;
#line 3054
    uchar *xp = (uchar *) *xpp;
#line 3054

#line 3054
    if (rndup) rndup = X_ALIGN - rndup;
#line 3054

#line 3054
    while (nelems-- != 0) {
#line 3054
        if (*tp > (uint)X_UCHAR_MAX ) {
#line 3054
            
#line 3054
            status = NC_ERANGE;
#line 3054
            
#line 3054
        }
#line 3054
        *xp++ = (uchar)  *tp++; /* type cast from uint to uchar */
#line 3054
    }
#line 3054

#line 3054

#line 3054
    if (rndup) {
#line 3054
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3054
        xp += rndup;
#line 3054
    }
#line 3054

#line 3054
    *xpp = (void *)xp;
#line 3054
    return status;
#line 3054
}
#line 3054

int
#line 3055
ncx_pad_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3055
{
#line 3055
    int status = NC_NOERR;
#line 3055
    size_t rndup = nelems % X_ALIGN;
#line 3055
    uchar *xp = (uchar *) *xpp;
#line 3055

#line 3055
    if (rndup) rndup = X_ALIGN - rndup;
#line 3055

#line 3055
    while (nelems-- != 0) {
#line 3055
        if (*tp > (ulonglong)X_UCHAR_MAX ) {
#line 3055
            
#line 3055
            status = NC_ERANGE;
#line 3055
            
#line 3055
        }
#line 3055
        *xp++ = (uchar)  *tp++; /* type cast from ulonglong to uchar */
#line 3055
    }
#line 3055

#line 3055

#line 3055
    if (rndup) {
#line 3055
        (void) memcpy(xp, nada, (size_t)rndup);
#line 3055
        xp += rndup;
#line 3055
    }
#line 3055

#line 3055
    *xpp = (void *)xp;
#line 3055
    return status;
#line 3055
}
#line 3055


/* short ---------------------------------------------------------------------*/

#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_SHORT);
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return NC_NOERR;
}
#else
int
#line 3073
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 3073
{
#line 3073
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3073

#line 3073
 /* basic algorithm is:
#line 3073
  *   - ensure sane alignment of input data
#line 3073
  *   - copy (conversion happens automatically) input data
#line 3073
  *     to output
#line 3073
  *   - update xpp to point at next unconverted input, and tp to point
#line 3073
  *     at next location for converted output
#line 3073
  */
#line 3073
  long i, j, ni;
#line 3073
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3073
  short *xp;
#line 3073
  int nrange = 0;         /* number of range errors */
#line 3073
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3073
  long cxp = (long) *((char**)xpp);
#line 3073

#line 3073
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3073
  /* sjl: manually stripmine so we can limit amount of
#line 3073
   * vector work space reserved to LOOPCNT elements. Also
#line 3073
   * makes vectorisation easy */
#line 3073
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3073
    ni=Min(nelems-j,LOOPCNT);
#line 3073
    if (realign) {
#line 3073
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3073
      xp = tmp;
#line 3073
    } else {
#line 3073
      xp = (short *) *xpp;
#line 3073
    }
#line 3073
   /* copy the next block */
#line 3073
#pragma cdir loopcnt=LOOPCNT
#line 3073
#pragma cdir shortloop
#line 3073
    for (i=0; i<ni; i++) {
#line 3073
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3073
     /* test for range errors (not always needed but do it anyway) */
#line 3073
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3073
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3073
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3073
    }
#line 3073
   /* update xpp and tp */
#line 3073
    if (realign) xp = (short *) *xpp;
#line 3073
    xp += ni;
#line 3073
    tp += ni;
#line 3073
    *xpp = (void*)xp;
#line 3073
  }
#line 3073
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3073

#line 3073
#else   /* not SX */
#line 3073
	const char *xp = (const char *) *xpp;
#line 3073
	int status = NC_NOERR;
#line 3073

#line 3073
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3073
	{
#line 3073
		const int lstatus = ncx_get_short_short(xp, tp);
#line 3073
		if (status == NC_NOERR) /* report the first encountered error */
#line 3073
			status = lstatus;
#line 3073
	}
#line 3073

#line 3073
	*xpp = (const void *)xp;
#line 3073
	return status;
#line 3073
#endif
#line 3073
}
#line 3073

#endif
int
#line 3075
ncx_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 3075
{
#line 3075
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3075

#line 3075
 /* basic algorithm is:
#line 3075
  *   - ensure sane alignment of input data
#line 3075
  *   - copy (conversion happens automatically) input data
#line 3075
  *     to output
#line 3075
  *   - update xpp to point at next unconverted input, and tp to point
#line 3075
  *     at next location for converted output
#line 3075
  */
#line 3075
  long i, j, ni;
#line 3075
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3075
  short *xp;
#line 3075
  int nrange = 0;         /* number of range errors */
#line 3075
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3075
  long cxp = (long) *((char**)xpp);
#line 3075

#line 3075
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3075
  /* sjl: manually stripmine so we can limit amount of
#line 3075
   * vector work space reserved to LOOPCNT elements. Also
#line 3075
   * makes vectorisation easy */
#line 3075
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3075
    ni=Min(nelems-j,LOOPCNT);
#line 3075
    if (realign) {
#line 3075
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3075
      xp = tmp;
#line 3075
    } else {
#line 3075
      xp = (short *) *xpp;
#line 3075
    }
#line 3075
   /* copy the next block */
#line 3075
#pragma cdir loopcnt=LOOPCNT
#line 3075
#pragma cdir shortloop
#line 3075
    for (i=0; i<ni; i++) {
#line 3075
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3075
     /* test for range errors (not always needed but do it anyway) */
#line 3075
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3075
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3075
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3075
    }
#line 3075
   /* update xpp and tp */
#line 3075
    if (realign) xp = (short *) *xpp;
#line 3075
    xp += ni;
#line 3075
    tp += ni;
#line 3075
    *xpp = (void*)xp;
#line 3075
  }
#line 3075
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3075

#line 3075
#else   /* not SX */
#line 3075
	const char *xp = (const char *) *xpp;
#line 3075
	int status = NC_NOERR;
#line 3075

#line 3075
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3075
	{
#line 3075
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 3075
		if (status == NC_NOERR) /* report the first encountered error */
#line 3075
			status = lstatus;
#line 3075
	}
#line 3075

#line 3075
	*xpp = (const void *)xp;
#line 3075
	return status;
#line 3075
#endif
#line 3075
}
#line 3075

int
#line 3076
ncx_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 3076
{
#line 3076
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3076

#line 3076
 /* basic algorithm is:
#line 3076
  *   - ensure sane alignment of input data
#line 3076
  *   - copy (conversion happens automatically) input data
#line 3076
  *     to output
#line 3076
  *   - update xpp to point at next unconverted input, and tp to point
#line 3076
  *     at next location for converted output
#line 3076
  */
#line 3076
  long i, j, ni;
#line 3076
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3076
  short *xp;
#line 3076
  int nrange = 0;         /* number of range errors */
#line 3076
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3076
  long cxp = (long) *((char**)xpp);
#line 3076

#line 3076
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3076
  /* sjl: manually stripmine so we can limit amount of
#line 3076
   * vector work space reserved to LOOPCNT elements. Also
#line 3076
   * makes vectorisation easy */
#line 3076
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3076
    ni=Min(nelems-j,LOOPCNT);
#line 3076
    if (realign) {
#line 3076
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3076
      xp = tmp;
#line 3076
    } else {
#line 3076
      xp = (short *) *xpp;
#line 3076
    }
#line 3076
   /* copy the next block */
#line 3076
#pragma cdir loopcnt=LOOPCNT
#line 3076
#pragma cdir shortloop
#line 3076
    for (i=0; i<ni; i++) {
#line 3076
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3076
     /* test for range errors (not always needed but do it anyway) */
#line 3076
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3076
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3076
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3076
    }
#line 3076
   /* update xpp and tp */
#line 3076
    if (realign) xp = (short *) *xpp;
#line 3076
    xp += ni;
#line 3076
    tp += ni;
#line 3076
    *xpp = (void*)xp;
#line 3076
  }
#line 3076
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3076

#line 3076
#else   /* not SX */
#line 3076
	const char *xp = (const char *) *xpp;
#line 3076
	int status = NC_NOERR;
#line 3076

#line 3076
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3076
	{
#line 3076
		const int lstatus = ncx_get_short_int(xp, tp);
#line 3076
		if (status == NC_NOERR) /* report the first encountered error */
#line 3076
			status = lstatus;
#line 3076
	}
#line 3076

#line 3076
	*xpp = (const void *)xp;
#line 3076
	return status;
#line 3076
#endif
#line 3076
}
#line 3076

int
#line 3077
ncx_getn_short_long(const void **xpp, size_t nelems, long *tp)
#line 3077
{
#line 3077
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3077

#line 3077
 /* basic algorithm is:
#line 3077
  *   - ensure sane alignment of input data
#line 3077
  *   - copy (conversion happens automatically) input data
#line 3077
  *     to output
#line 3077
  *   - update xpp to point at next unconverted input, and tp to point
#line 3077
  *     at next location for converted output
#line 3077
  */
#line 3077
  long i, j, ni;
#line 3077
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3077
  short *xp;
#line 3077
  int nrange = 0;         /* number of range errors */
#line 3077
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3077
  long cxp = (long) *((char**)xpp);
#line 3077

#line 3077
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3077
  /* sjl: manually stripmine so we can limit amount of
#line 3077
   * vector work space reserved to LOOPCNT elements. Also
#line 3077
   * makes vectorisation easy */
#line 3077
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3077
    ni=Min(nelems-j,LOOPCNT);
#line 3077
    if (realign) {
#line 3077
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3077
      xp = tmp;
#line 3077
    } else {
#line 3077
      xp = (short *) *xpp;
#line 3077
    }
#line 3077
   /* copy the next block */
#line 3077
#pragma cdir loopcnt=LOOPCNT
#line 3077
#pragma cdir shortloop
#line 3077
    for (i=0; i<ni; i++) {
#line 3077
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3077
     /* test for range errors (not always needed but do it anyway) */
#line 3077
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3077
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3077
      nrange += xp[i] > LONG_MAX || xp[i] < LONG_MIN;
#line 3077
    }
#line 3077
   /* update xpp and tp */
#line 3077
    if (realign) xp = (short *) *xpp;
#line 3077
    xp += ni;
#line 3077
    tp += ni;
#line 3077
    *xpp = (void*)xp;
#line 3077
  }
#line 3077
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3077

#line 3077
#else   /* not SX */
#line 3077
	const char *xp = (const char *) *xpp;
#line 3077
	int status = NC_NOERR;
#line 3077

#line 3077
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3077
	{
#line 3077
		const int lstatus = ncx_get_short_long(xp, tp);
#line 3077
		if (status == NC_NOERR) /* report the first encountered error */
#line 3077
			status = lstatus;
#line 3077
	}
#line 3077

#line 3077
	*xpp = (const void *)xp;
#line 3077
	return status;
#line 3077
#endif
#line 3077
}
#line 3077

int
#line 3078
ncx_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 3078
{
#line 3078
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3078

#line 3078
 /* basic algorithm is:
#line 3078
  *   - ensure sane alignment of input data
#line 3078
  *   - copy (conversion happens automatically) input data
#line 3078
  *     to output
#line 3078
  *   - update xpp to point at next unconverted input, and tp to point
#line 3078
  *     at next location for converted output
#line 3078
  */
#line 3078
  long i, j, ni;
#line 3078
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3078
  short *xp;
#line 3078
  int nrange = 0;         /* number of range errors */
#line 3078
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3078
  long cxp = (long) *((char**)xpp);
#line 3078

#line 3078
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3078
  /* sjl: manually stripmine so we can limit amount of
#line 3078
   * vector work space reserved to LOOPCNT elements. Also
#line 3078
   * makes vectorisation easy */
#line 3078
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3078
    ni=Min(nelems-j,LOOPCNT);
#line 3078
    if (realign) {
#line 3078
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3078
      xp = tmp;
#line 3078
    } else {
#line 3078
      xp = (short *) *xpp;
#line 3078
    }
#line 3078
   /* copy the next block */
#line 3078
#pragma cdir loopcnt=LOOPCNT
#line 3078
#pragma cdir shortloop
#line 3078
    for (i=0; i<ni; i++) {
#line 3078
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3078
     /* test for range errors (not always needed but do it anyway) */
#line 3078
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3078
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3078
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3078
    }
#line 3078
   /* update xpp and tp */
#line 3078
    if (realign) xp = (short *) *xpp;
#line 3078
    xp += ni;
#line 3078
    tp += ni;
#line 3078
    *xpp = (void*)xp;
#line 3078
  }
#line 3078
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3078

#line 3078
#else   /* not SX */
#line 3078
	const char *xp = (const char *) *xpp;
#line 3078
	int status = NC_NOERR;
#line 3078

#line 3078
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3078
	{
#line 3078
		const int lstatus = ncx_get_short_float(xp, tp);
#line 3078
		if (status == NC_NOERR) /* report the first encountered error */
#line 3078
			status = lstatus;
#line 3078
	}
#line 3078

#line 3078
	*xpp = (const void *)xp;
#line 3078
	return status;
#line 3078
#endif
#line 3078
}
#line 3078

int
#line 3079
ncx_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 3079
{
#line 3079
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3079

#line 3079
 /* basic algorithm is:
#line 3079
  *   - ensure sane alignment of input data
#line 3079
  *   - copy (conversion happens automatically) input data
#line 3079
  *     to output
#line 3079
  *   - update xpp to point at next unconverted input, and tp to point
#line 3079
  *     at next location for converted output
#line 3079
  */
#line 3079
  long i, j, ni;
#line 3079
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3079
  short *xp;
#line 3079
  int nrange = 0;         /* number of range errors */
#line 3079
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3079
  long cxp = (long) *((char**)xpp);
#line 3079

#line 3079
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3079
  /* sjl: manually stripmine so we can limit amount of
#line 3079
   * vector work space reserved to LOOPCNT elements. Also
#line 3079
   * makes vectorisation easy */
#line 3079
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3079
    ni=Min(nelems-j,LOOPCNT);
#line 3079
    if (realign) {
#line 3079
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3079
      xp = tmp;
#line 3079
    } else {
#line 3079
      xp = (short *) *xpp;
#line 3079
    }
#line 3079
   /* copy the next block */
#line 3079
#pragma cdir loopcnt=LOOPCNT
#line 3079
#pragma cdir shortloop
#line 3079
    for (i=0; i<ni; i++) {
#line 3079
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3079
     /* test for range errors (not always needed but do it anyway) */
#line 3079
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3079
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3079
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3079
    }
#line 3079
   /* update xpp and tp */
#line 3079
    if (realign) xp = (short *) *xpp;
#line 3079
    xp += ni;
#line 3079
    tp += ni;
#line 3079
    *xpp = (void*)xp;
#line 3079
  }
#line 3079
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3079

#line 3079
#else   /* not SX */
#line 3079
	const char *xp = (const char *) *xpp;
#line 3079
	int status = NC_NOERR;
#line 3079

#line 3079
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3079
	{
#line 3079
		const int lstatus = ncx_get_short_double(xp, tp);
#line 3079
		if (status == NC_NOERR) /* report the first encountered error */
#line 3079
			status = lstatus;
#line 3079
	}
#line 3079

#line 3079
	*xpp = (const void *)xp;
#line 3079
	return status;
#line 3079
#endif
#line 3079
}
#line 3079

int
#line 3080
ncx_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3080
{
#line 3080
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3080

#line 3080
 /* basic algorithm is:
#line 3080
  *   - ensure sane alignment of input data
#line 3080
  *   - copy (conversion happens automatically) input data
#line 3080
  *     to output
#line 3080
  *   - update xpp to point at next unconverted input, and tp to point
#line 3080
  *     at next location for converted output
#line 3080
  */
#line 3080
  long i, j, ni;
#line 3080
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3080
  short *xp;
#line 3080
  int nrange = 0;         /* number of range errors */
#line 3080
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3080
  long cxp = (long) *((char**)xpp);
#line 3080

#line 3080
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3080
  /* sjl: manually stripmine so we can limit amount of
#line 3080
   * vector work space reserved to LOOPCNT elements. Also
#line 3080
   * makes vectorisation easy */
#line 3080
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3080
    ni=Min(nelems-j,LOOPCNT);
#line 3080
    if (realign) {
#line 3080
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3080
      xp = tmp;
#line 3080
    } else {
#line 3080
      xp = (short *) *xpp;
#line 3080
    }
#line 3080
   /* copy the next block */
#line 3080
#pragma cdir loopcnt=LOOPCNT
#line 3080
#pragma cdir shortloop
#line 3080
    for (i=0; i<ni; i++) {
#line 3080
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3080
     /* test for range errors (not always needed but do it anyway) */
#line 3080
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3080
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3080
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3080
    }
#line 3080
   /* update xpp and tp */
#line 3080
    if (realign) xp = (short *) *xpp;
#line 3080
    xp += ni;
#line 3080
    tp += ni;
#line 3080
    *xpp = (void*)xp;
#line 3080
  }
#line 3080
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3080

#line 3080
#else   /* not SX */
#line 3080
	const char *xp = (const char *) *xpp;
#line 3080
	int status = NC_NOERR;
#line 3080

#line 3080
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3080
	{
#line 3080
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 3080
		if (status == NC_NOERR) /* report the first encountered error */
#line 3080
			status = lstatus;
#line 3080
	}
#line 3080

#line 3080
	*xpp = (const void *)xp;
#line 3080
	return status;
#line 3080
#endif
#line 3080
}
#line 3080

int
#line 3081
ncx_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3081
{
#line 3081
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3081

#line 3081
 /* basic algorithm is:
#line 3081
  *   - ensure sane alignment of input data
#line 3081
  *   - copy (conversion happens automatically) input data
#line 3081
  *     to output
#line 3081
  *   - update xpp to point at next unconverted input, and tp to point
#line 3081
  *     at next location for converted output
#line 3081
  */
#line 3081
  long i, j, ni;
#line 3081
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3081
  short *xp;
#line 3081
  int nrange = 0;         /* number of range errors */
#line 3081
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3081
  long cxp = (long) *((char**)xpp);
#line 3081

#line 3081
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3081
  /* sjl: manually stripmine so we can limit amount of
#line 3081
   * vector work space reserved to LOOPCNT elements. Also
#line 3081
   * makes vectorisation easy */
#line 3081
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3081
    ni=Min(nelems-j,LOOPCNT);
#line 3081
    if (realign) {
#line 3081
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3081
      xp = tmp;
#line 3081
    } else {
#line 3081
      xp = (short *) *xpp;
#line 3081
    }
#line 3081
   /* copy the next block */
#line 3081
#pragma cdir loopcnt=LOOPCNT
#line 3081
#pragma cdir shortloop
#line 3081
    for (i=0; i<ni; i++) {
#line 3081
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3081
     /* test for range errors (not always needed but do it anyway) */
#line 3081
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3081
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3081
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3081
    }
#line 3081
   /* update xpp and tp */
#line 3081
    if (realign) xp = (short *) *xpp;
#line 3081
    xp += ni;
#line 3081
    tp += ni;
#line 3081
    *xpp = (void*)xp;
#line 3081
  }
#line 3081
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3081

#line 3081
#else   /* not SX */
#line 3081
	const char *xp = (const char *) *xpp;
#line 3081
	int status = NC_NOERR;
#line 3081

#line 3081
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3081
	{
#line 3081
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 3081
		if (status == NC_NOERR) /* report the first encountered error */
#line 3081
			status = lstatus;
#line 3081
	}
#line 3081

#line 3081
	*xpp = (const void *)xp;
#line 3081
	return status;
#line 3081
#endif
#line 3081
}
#line 3081

int
#line 3082
ncx_getn_short_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3082
{
#line 3082
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3082

#line 3082
 /* basic algorithm is:
#line 3082
  *   - ensure sane alignment of input data
#line 3082
  *   - copy (conversion happens automatically) input data
#line 3082
  *     to output
#line 3082
  *   - update xpp to point at next unconverted input, and tp to point
#line 3082
  *     at next location for converted output
#line 3082
  */
#line 3082
  long i, j, ni;
#line 3082
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3082
  short *xp;
#line 3082
  int nrange = 0;         /* number of range errors */
#line 3082
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3082
  long cxp = (long) *((char**)xpp);
#line 3082

#line 3082
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3082
  /* sjl: manually stripmine so we can limit amount of
#line 3082
   * vector work space reserved to LOOPCNT elements. Also
#line 3082
   * makes vectorisation easy */
#line 3082
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3082
    ni=Min(nelems-j,LOOPCNT);
#line 3082
    if (realign) {
#line 3082
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3082
      xp = tmp;
#line 3082
    } else {
#line 3082
      xp = (short *) *xpp;
#line 3082
    }
#line 3082
   /* copy the next block */
#line 3082
#pragma cdir loopcnt=LOOPCNT
#line 3082
#pragma cdir shortloop
#line 3082
    for (i=0; i<ni; i++) {
#line 3082
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3082
     /* test for range errors (not always needed but do it anyway) */
#line 3082
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3082
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3082
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3082
    }
#line 3082
   /* update xpp and tp */
#line 3082
    if (realign) xp = (short *) *xpp;
#line 3082
    xp += ni;
#line 3082
    tp += ni;
#line 3082
    *xpp = (void*)xp;
#line 3082
  }
#line 3082
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3082

#line 3082
#else   /* not SX */
#line 3082
	const char *xp = (const char *) *xpp;
#line 3082
	int status = NC_NOERR;
#line 3082

#line 3082
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3082
	{
#line 3082
		const int lstatus = ncx_get_short_ushort(xp, tp);
#line 3082
		if (status == NC_NOERR) /* report the first encountered error */
#line 3082
			status = lstatus;
#line 3082
	}
#line 3082

#line 3082
	*xpp = (const void *)xp;
#line 3082
	return status;
#line 3082
#endif
#line 3082
}
#line 3082

int
#line 3083
ncx_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 3083
{
#line 3083
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3083

#line 3083
 /* basic algorithm is:
#line 3083
  *   - ensure sane alignment of input data
#line 3083
  *   - copy (conversion happens automatically) input data
#line 3083
  *     to output
#line 3083
  *   - update xpp to point at next unconverted input, and tp to point
#line 3083
  *     at next location for converted output
#line 3083
  */
#line 3083
  long i, j, ni;
#line 3083
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3083
  short *xp;
#line 3083
  int nrange = 0;         /* number of range errors */
#line 3083
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3083
  long cxp = (long) *((char**)xpp);
#line 3083

#line 3083
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3083
  /* sjl: manually stripmine so we can limit amount of
#line 3083
   * vector work space reserved to LOOPCNT elements. Also
#line 3083
   * makes vectorisation easy */
#line 3083
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3083
    ni=Min(nelems-j,LOOPCNT);
#line 3083
    if (realign) {
#line 3083
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3083
      xp = tmp;
#line 3083
    } else {
#line 3083
      xp = (short *) *xpp;
#line 3083
    }
#line 3083
   /* copy the next block */
#line 3083
#pragma cdir loopcnt=LOOPCNT
#line 3083
#pragma cdir shortloop
#line 3083
    for (i=0; i<ni; i++) {
#line 3083
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3083
     /* test for range errors (not always needed but do it anyway) */
#line 3083
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3083
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3083
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3083
    }
#line 3083
   /* update xpp and tp */
#line 3083
    if (realign) xp = (short *) *xpp;
#line 3083
    xp += ni;
#line 3083
    tp += ni;
#line 3083
    *xpp = (void*)xp;
#line 3083
  }
#line 3083
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3083

#line 3083
#else   /* not SX */
#line 3083
	const char *xp = (const char *) *xpp;
#line 3083
	int status = NC_NOERR;
#line 3083

#line 3083
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3083
	{
#line 3083
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 3083
		if (status == NC_NOERR) /* report the first encountered error */
#line 3083
			status = lstatus;
#line 3083
	}
#line 3083

#line 3083
	*xpp = (const void *)xp;
#line 3083
	return status;
#line 3083
#endif
#line 3083
}
#line 3083

int
#line 3084
ncx_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3084
{
#line 3084
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3084

#line 3084
 /* basic algorithm is:
#line 3084
  *   - ensure sane alignment of input data
#line 3084
  *   - copy (conversion happens automatically) input data
#line 3084
  *     to output
#line 3084
  *   - update xpp to point at next unconverted input, and tp to point
#line 3084
  *     at next location for converted output
#line 3084
  */
#line 3084
  long i, j, ni;
#line 3084
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3084
  short *xp;
#line 3084
  int nrange = 0;         /* number of range errors */
#line 3084
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3084
  long cxp = (long) *((char**)xpp);
#line 3084

#line 3084
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3084
  /* sjl: manually stripmine so we can limit amount of
#line 3084
   * vector work space reserved to LOOPCNT elements. Also
#line 3084
   * makes vectorisation easy */
#line 3084
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3084
    ni=Min(nelems-j,LOOPCNT);
#line 3084
    if (realign) {
#line 3084
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_SHORT));
#line 3084
      xp = tmp;
#line 3084
    } else {
#line 3084
      xp = (short *) *xpp;
#line 3084
    }
#line 3084
   /* copy the next block */
#line 3084
#pragma cdir loopcnt=LOOPCNT
#line 3084
#pragma cdir shortloop
#line 3084
    for (i=0; i<ni; i++) {
#line 3084
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3084
     /* test for range errors (not always needed but do it anyway) */
#line 3084
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3084
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3084
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3084
    }
#line 3084
   /* update xpp and tp */
#line 3084
    if (realign) xp = (short *) *xpp;
#line 3084
    xp += ni;
#line 3084
    tp += ni;
#line 3084
    *xpp = (void*)xp;
#line 3084
  }
#line 3084
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3084

#line 3084
#else   /* not SX */
#line 3084
	const char *xp = (const char *) *xpp;
#line 3084
	int status = NC_NOERR;
#line 3084

#line 3084
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3084
	{
#line 3084
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 3084
		if (status == NC_NOERR) /* report the first encountered error */
#line 3084
			status = lstatus;
#line 3084
	}
#line 3084

#line 3084
	*xpp = (const void *)xp;
#line 3084
	return status;
#line 3084
#endif
#line 3084
}
#line 3084


int
#line 3086
ncx_pad_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 3086
{
#line 3086
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3086

#line 3086
	const char *xp = (const char *) *xpp;
#line 3086
	int status = NC_NOERR;
#line 3086

#line 3086
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3086
	{
#line 3086
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 3086
		if (status == NC_NOERR) /* report the first encountered error */
#line 3086
			status = lstatus;
#line 3086
	}
#line 3086

#line 3086
	if (rndup != 0)
#line 3086
		xp += X_SIZEOF_SHORT;
#line 3086

#line 3086
	*xpp = (void *)xp;
#line 3086
	return status;
#line 3086
}
#line 3086

int
#line 3087
ncx_pad_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3087
{
#line 3087
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3087

#line 3087
	const char *xp = (const char *) *xpp;
#line 3087
	int status = NC_NOERR;
#line 3087

#line 3087
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3087
	{
#line 3087
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 3087
		if (status == NC_NOERR) /* report the first encountered error */
#line 3087
			status = lstatus;
#line 3087
	}
#line 3087

#line 3087
	if (rndup != 0)
#line 3087
		xp += X_SIZEOF_SHORT;
#line 3087

#line 3087
	*xpp = (void *)xp;
#line 3087
	return status;
#line 3087
}
#line 3087

int
#line 3088
ncx_pad_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 3088
{
#line 3088
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3088

#line 3088
	const char *xp = (const char *) *xpp;
#line 3088
	int status = NC_NOERR;
#line 3088

#line 3088
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3088
	{
#line 3088
		const int lstatus = ncx_get_short_short(xp, tp);
#line 3088
		if (status == NC_NOERR) /* report the first encountered error */
#line 3088
			status = lstatus;
#line 3088
	}
#line 3088

#line 3088
	if (rndup != 0)
#line 3088
		xp += X_SIZEOF_SHORT;
#line 3088

#line 3088
	*xpp = (void *)xp;
#line 3088
	return status;
#line 3088
}
#line 3088

int
#line 3089
ncx_pad_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 3089
{
#line 3089
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3089

#line 3089
	const char *xp = (const char *) *xpp;
#line 3089
	int status = NC_NOERR;
#line 3089

#line 3089
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3089
	{
#line 3089
		const int lstatus = ncx_get_short_int(xp, tp);
#line 3089
		if (status == NC_NOERR) /* report the first encountered error */
#line 3089
			status = lstatus;
#line 3089
	}
#line 3089

#line 3089
	if (rndup != 0)
#line 3089
		xp += X_SIZEOF_SHORT;
#line 3089

#line 3089
	*xpp = (void *)xp;
#line 3089
	return status;
#line 3089
}
#line 3089

int
#line 3090
ncx_pad_getn_short_long(const void **xpp, size_t nelems, long *tp)
#line 3090
{
#line 3090
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3090

#line 3090
	const char *xp = (const char *) *xpp;
#line 3090
	int status = NC_NOERR;
#line 3090

#line 3090
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3090
	{
#line 3090
		const int lstatus = ncx_get_short_long(xp, tp);
#line 3090
		if (status == NC_NOERR) /* report the first encountered error */
#line 3090
			status = lstatus;
#line 3090
	}
#line 3090

#line 3090
	if (rndup != 0)
#line 3090
		xp += X_SIZEOF_SHORT;
#line 3090

#line 3090
	*xpp = (void *)xp;
#line 3090
	return status;
#line 3090
}
#line 3090

int
#line 3091
ncx_pad_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 3091
{
#line 3091
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3091

#line 3091
	const char *xp = (const char *) *xpp;
#line 3091
	int status = NC_NOERR;
#line 3091

#line 3091
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3091
	{
#line 3091
		const int lstatus = ncx_get_short_float(xp, tp);
#line 3091
		if (status == NC_NOERR) /* report the first encountered error */
#line 3091
			status = lstatus;
#line 3091
	}
#line 3091

#line 3091
	if (rndup != 0)
#line 3091
		xp += X_SIZEOF_SHORT;
#line 3091

#line 3091
	*xpp = (void *)xp;
#line 3091
	return status;
#line 3091
}
#line 3091

int
#line 3092
ncx_pad_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 3092
{
#line 3092
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3092

#line 3092
	const char *xp = (const char *) *xpp;
#line 3092
	int status = NC_NOERR;
#line 3092

#line 3092
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3092
	{
#line 3092
		const int lstatus = ncx_get_short_double(xp, tp);
#line 3092
		if (status == NC_NOERR) /* report the first encountered error */
#line 3092
			status = lstatus;
#line 3092
	}
#line 3092

#line 3092
	if (rndup != 0)
#line 3092
		xp += X_SIZEOF_SHORT;
#line 3092

#line 3092
	*xpp = (void *)xp;
#line 3092
	return status;
#line 3092
}
#line 3092

int
#line 3093
ncx_pad_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 3093
{
#line 3093
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3093

#line 3093
	const char *xp = (const char *) *xpp;
#line 3093
	int status = NC_NOERR;
#line 3093

#line 3093
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3093
	{
#line 3093
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 3093
		if (status == NC_NOERR) /* report the first encountered error */
#line 3093
			status = lstatus;
#line 3093
	}
#line 3093

#line 3093
	if (rndup != 0)
#line 3093
		xp += X_SIZEOF_SHORT;
#line 3093

#line 3093
	*xpp = (void *)xp;
#line 3093
	return status;
#line 3093
}
#line 3093

int
#line 3094
ncx_pad_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3094
{
#line 3094
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3094

#line 3094
	const char *xp = (const char *) *xpp;
#line 3094
	int status = NC_NOERR;
#line 3094

#line 3094
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3094
	{
#line 3094
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 3094
		if (status == NC_NOERR) /* report the first encountered error */
#line 3094
			status = lstatus;
#line 3094
	}
#line 3094

#line 3094
	if (rndup != 0)
#line 3094
		xp += X_SIZEOF_SHORT;
#line 3094

#line 3094
	*xpp = (void *)xp;
#line 3094
	return status;
#line 3094
}
#line 3094

int
#line 3095
ncx_pad_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3095
{
#line 3095
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3095

#line 3095
	const char *xp = (const char *) *xpp;
#line 3095
	int status = NC_NOERR;
#line 3095

#line 3095
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3095
	{
#line 3095
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 3095
		if (status == NC_NOERR) /* report the first encountered error */
#line 3095
			status = lstatus;
#line 3095
	}
#line 3095

#line 3095
	if (rndup != 0)
#line 3095
		xp += X_SIZEOF_SHORT;
#line 3095

#line 3095
	*xpp = (void *)xp;
#line 3095
	return status;
#line 3095
}
#line 3095

int
#line 3096
ncx_pad_getn_short_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3096
{
#line 3096
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3096

#line 3096
	const char *xp = (const char *) *xpp;
#line 3096
	int status = NC_NOERR;
#line 3096

#line 3096
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3096
	{
#line 3096
		const int lstatus = ncx_get_short_ushort(xp, tp);
#line 3096
		if (status == NC_NOERR) /* report the first encountered error */
#line 3096
			status = lstatus;
#line 3096
	}
#line 3096

#line 3096
	if (rndup != 0)
#line 3096
		xp += X_SIZEOF_SHORT;
#line 3096

#line 3096
	*xpp = (void *)xp;
#line 3096
	return status;
#line 3096
}
#line 3096


#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_SHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return NC_NOERR;
}
#else
int
#line 3112
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3112
{
#line 3112
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3112

#line 3112
 /* basic algorithm is:
#line 3112
  *   - ensure sane alignment of output data
#line 3112
  *   - copy (conversion happens automatically) input data
#line 3112
  *     to output
#line 3112
  *   - update tp to point at next unconverted input, and xpp to point
#line 3112
  *     at next location for converted output
#line 3112
  */
#line 3112
  long i, j, ni;
#line 3112
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3112
  short *xp;
#line 3112
  int nrange = 0;         /* number of range errors */
#line 3112
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3112
  long cxp = (long) *((char**)xpp);
#line 3112

#line 3112
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3112
  /* sjl: manually stripmine so we can limit amount of
#line 3112
   * vector work space reserved to LOOPCNT elements. Also
#line 3112
   * makes vectorisation easy */
#line 3112
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3112
    ni=Min(nelems-j,LOOPCNT);
#line 3112
    if (realign) {
#line 3112
      xp = tmp;
#line 3112
    } else {
#line 3112
      xp = (short *) *xpp;
#line 3112
    }
#line 3112
   /* copy the next block */
#line 3112
#pragma cdir loopcnt=LOOPCNT
#line 3112
#pragma cdir shortloop
#line 3112
    for (i=0; i<ni; i++) {
#line 3112
      /* the normal case: */
#line 3112
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3112
     /* test for range errors (not always needed but do it anyway) */
#line 3112
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3112
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3112
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3112
    }
#line 3112
   /* copy workspace back if necessary */
#line 3112
    if (realign) {
#line 3112
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3112
      xp = (short *) *xpp;
#line 3112
    }
#line 3112
   /* update xpp and tp */
#line 3112
    xp += ni;
#line 3112
    tp += ni;
#line 3112
    *xpp = (void*)xp;
#line 3112
  }
#line 3112
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3112

#line 3112
#else   /* not SX */
#line 3112

#line 3112
	char *xp = (char *) *xpp;
#line 3112
	int status = NC_NOERR;
#line 3112

#line 3112
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3112
	{
#line 3112
		int lstatus = ncx_put_short_short(xp, tp, fillp);
#line 3112
		if (status == NC_NOERR) /* report the first encountered error */
#line 3112
			status = lstatus;
#line 3112
	}
#line 3112

#line 3112
	*xpp = (void *)xp;
#line 3112
	return status;
#line 3112
#endif
#line 3112
}
#line 3112

#endif
int
#line 3114
ncx_putn_short_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3114
{
#line 3114
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3114

#line 3114
 /* basic algorithm is:
#line 3114
  *   - ensure sane alignment of output data
#line 3114
  *   - copy (conversion happens automatically) input data
#line 3114
  *     to output
#line 3114
  *   - update tp to point at next unconverted input, and xpp to point
#line 3114
  *     at next location for converted output
#line 3114
  */
#line 3114
  long i, j, ni;
#line 3114
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3114
  short *xp;
#line 3114
  int nrange = 0;         /* number of range errors */
#line 3114
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3114
  long cxp = (long) *((char**)xpp);
#line 3114

#line 3114
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3114
  /* sjl: manually stripmine so we can limit amount of
#line 3114
   * vector work space reserved to LOOPCNT elements. Also
#line 3114
   * makes vectorisation easy */
#line 3114
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3114
    ni=Min(nelems-j,LOOPCNT);
#line 3114
    if (realign) {
#line 3114
      xp = tmp;
#line 3114
    } else {
#line 3114
      xp = (short *) *xpp;
#line 3114
    }
#line 3114
   /* copy the next block */
#line 3114
#pragma cdir loopcnt=LOOPCNT
#line 3114
#pragma cdir shortloop
#line 3114
    for (i=0; i<ni; i++) {
#line 3114
      /* the normal case: */
#line 3114
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3114
     /* test for range errors (not always needed but do it anyway) */
#line 3114
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3114
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3114
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3114
    }
#line 3114
   /* copy workspace back if necessary */
#line 3114
    if (realign) {
#line 3114
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3114
      xp = (short *) *xpp;
#line 3114
    }
#line 3114
   /* update xpp and tp */
#line 3114
    xp += ni;
#line 3114
    tp += ni;
#line 3114
    *xpp = (void*)xp;
#line 3114
  }
#line 3114
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3114

#line 3114
#else   /* not SX */
#line 3114

#line 3114
	char *xp = (char *) *xpp;
#line 3114
	int status = NC_NOERR;
#line 3114

#line 3114
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3114
	{
#line 3114
		int lstatus = ncx_put_short_schar(xp, tp, fillp);
#line 3114
		if (status == NC_NOERR) /* report the first encountered error */
#line 3114
			status = lstatus;
#line 3114
	}
#line 3114

#line 3114
	*xpp = (void *)xp;
#line 3114
	return status;
#line 3114
#endif
#line 3114
}
#line 3114

int
#line 3115
ncx_putn_short_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3115
{
#line 3115
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3115

#line 3115
 /* basic algorithm is:
#line 3115
  *   - ensure sane alignment of output data
#line 3115
  *   - copy (conversion happens automatically) input data
#line 3115
  *     to output
#line 3115
  *   - update tp to point at next unconverted input, and xpp to point
#line 3115
  *     at next location for converted output
#line 3115
  */
#line 3115
  long i, j, ni;
#line 3115
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3115
  short *xp;
#line 3115
  int nrange = 0;         /* number of range errors */
#line 3115
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3115
  long cxp = (long) *((char**)xpp);
#line 3115

#line 3115
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3115
  /* sjl: manually stripmine so we can limit amount of
#line 3115
   * vector work space reserved to LOOPCNT elements. Also
#line 3115
   * makes vectorisation easy */
#line 3115
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3115
    ni=Min(nelems-j,LOOPCNT);
#line 3115
    if (realign) {
#line 3115
      xp = tmp;
#line 3115
    } else {
#line 3115
      xp = (short *) *xpp;
#line 3115
    }
#line 3115
   /* copy the next block */
#line 3115
#pragma cdir loopcnt=LOOPCNT
#line 3115
#pragma cdir shortloop
#line 3115
    for (i=0; i<ni; i++) {
#line 3115
      /* the normal case: */
#line 3115
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3115
     /* test for range errors (not always needed but do it anyway) */
#line 3115
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3115
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3115
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3115
    }
#line 3115
   /* copy workspace back if necessary */
#line 3115
    if (realign) {
#line 3115
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3115
      xp = (short *) *xpp;
#line 3115
    }
#line 3115
   /* update xpp and tp */
#line 3115
    xp += ni;
#line 3115
    tp += ni;
#line 3115
    *xpp = (void*)xp;
#line 3115
  }
#line 3115
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3115

#line 3115
#else   /* not SX */
#line 3115

#line 3115
	char *xp = (char *) *xpp;
#line 3115
	int status = NC_NOERR;
#line 3115

#line 3115
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3115
	{
#line 3115
		int lstatus = ncx_put_short_int(xp, tp, fillp);
#line 3115
		if (status == NC_NOERR) /* report the first encountered error */
#line 3115
			status = lstatus;
#line 3115
	}
#line 3115

#line 3115
	*xpp = (void *)xp;
#line 3115
	return status;
#line 3115
#endif
#line 3115
}
#line 3115

int
#line 3116
ncx_putn_short_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3116
{
#line 3116
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3116

#line 3116
 /* basic algorithm is:
#line 3116
  *   - ensure sane alignment of output data
#line 3116
  *   - copy (conversion happens automatically) input data
#line 3116
  *     to output
#line 3116
  *   - update tp to point at next unconverted input, and xpp to point
#line 3116
  *     at next location for converted output
#line 3116
  */
#line 3116
  long i, j, ni;
#line 3116
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3116
  short *xp;
#line 3116
  int nrange = 0;         /* number of range errors */
#line 3116
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3116
  long cxp = (long) *((char**)xpp);
#line 3116

#line 3116
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3116
  /* sjl: manually stripmine so we can limit amount of
#line 3116
   * vector work space reserved to LOOPCNT elements. Also
#line 3116
   * makes vectorisation easy */
#line 3116
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3116
    ni=Min(nelems-j,LOOPCNT);
#line 3116
    if (realign) {
#line 3116
      xp = tmp;
#line 3116
    } else {
#line 3116
      xp = (short *) *xpp;
#line 3116
    }
#line 3116
   /* copy the next block */
#line 3116
#pragma cdir loopcnt=LOOPCNT
#line 3116
#pragma cdir shortloop
#line 3116
    for (i=0; i<ni; i++) {
#line 3116
      /* the normal case: */
#line 3116
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3116
     /* test for range errors (not always needed but do it anyway) */
#line 3116
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3116
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3116
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3116
    }
#line 3116
   /* copy workspace back if necessary */
#line 3116
    if (realign) {
#line 3116
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3116
      xp = (short *) *xpp;
#line 3116
    }
#line 3116
   /* update xpp and tp */
#line 3116
    xp += ni;
#line 3116
    tp += ni;
#line 3116
    *xpp = (void*)xp;
#line 3116
  }
#line 3116
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3116

#line 3116
#else   /* not SX */
#line 3116

#line 3116
	char *xp = (char *) *xpp;
#line 3116
	int status = NC_NOERR;
#line 3116

#line 3116
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3116
	{
#line 3116
		int lstatus = ncx_put_short_long(xp, tp, fillp);
#line 3116
		if (status == NC_NOERR) /* report the first encountered error */
#line 3116
			status = lstatus;
#line 3116
	}
#line 3116

#line 3116
	*xpp = (void *)xp;
#line 3116
	return status;
#line 3116
#endif
#line 3116
}
#line 3116

int
#line 3117
ncx_putn_short_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3117
{
#line 3117
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3117

#line 3117
 /* basic algorithm is:
#line 3117
  *   - ensure sane alignment of output data
#line 3117
  *   - copy (conversion happens automatically) input data
#line 3117
  *     to output
#line 3117
  *   - update tp to point at next unconverted input, and xpp to point
#line 3117
  *     at next location for converted output
#line 3117
  */
#line 3117
  long i, j, ni;
#line 3117
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3117
  short *xp;
#line 3117
  int nrange = 0;         /* number of range errors */
#line 3117
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3117
  long cxp = (long) *((char**)xpp);
#line 3117

#line 3117
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3117
  /* sjl: manually stripmine so we can limit amount of
#line 3117
   * vector work space reserved to LOOPCNT elements. Also
#line 3117
   * makes vectorisation easy */
#line 3117
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3117
    ni=Min(nelems-j,LOOPCNT);
#line 3117
    if (realign) {
#line 3117
      xp = tmp;
#line 3117
    } else {
#line 3117
      xp = (short *) *xpp;
#line 3117
    }
#line 3117
   /* copy the next block */
#line 3117
#pragma cdir loopcnt=LOOPCNT
#line 3117
#pragma cdir shortloop
#line 3117
    for (i=0; i<ni; i++) {
#line 3117
      /* the normal case: */
#line 3117
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3117
     /* test for range errors (not always needed but do it anyway) */
#line 3117
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3117
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3117
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3117
    }
#line 3117
   /* copy workspace back if necessary */
#line 3117
    if (realign) {
#line 3117
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3117
      xp = (short *) *xpp;
#line 3117
    }
#line 3117
   /* update xpp and tp */
#line 3117
    xp += ni;
#line 3117
    tp += ni;
#line 3117
    *xpp = (void*)xp;
#line 3117
  }
#line 3117
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3117

#line 3117
#else   /* not SX */
#line 3117

#line 3117
	char *xp = (char *) *xpp;
#line 3117
	int status = NC_NOERR;
#line 3117

#line 3117
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3117
	{
#line 3117
		int lstatus = ncx_put_short_float(xp, tp, fillp);
#line 3117
		if (status == NC_NOERR) /* report the first encountered error */
#line 3117
			status = lstatus;
#line 3117
	}
#line 3117

#line 3117
	*xpp = (void *)xp;
#line 3117
	return status;
#line 3117
#endif
#line 3117
}
#line 3117

int
#line 3118
ncx_putn_short_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3118
{
#line 3118
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3118

#line 3118
 /* basic algorithm is:
#line 3118
  *   - ensure sane alignment of output data
#line 3118
  *   - copy (conversion happens automatically) input data
#line 3118
  *     to output
#line 3118
  *   - update tp to point at next unconverted input, and xpp to point
#line 3118
  *     at next location for converted output
#line 3118
  */
#line 3118
  long i, j, ni;
#line 3118
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3118
  short *xp;
#line 3118
  int nrange = 0;         /* number of range errors */
#line 3118
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3118
  long cxp = (long) *((char**)xpp);
#line 3118

#line 3118
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3118
  /* sjl: manually stripmine so we can limit amount of
#line 3118
   * vector work space reserved to LOOPCNT elements. Also
#line 3118
   * makes vectorisation easy */
#line 3118
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3118
    ni=Min(nelems-j,LOOPCNT);
#line 3118
    if (realign) {
#line 3118
      xp = tmp;
#line 3118
    } else {
#line 3118
      xp = (short *) *xpp;
#line 3118
    }
#line 3118
   /* copy the next block */
#line 3118
#pragma cdir loopcnt=LOOPCNT
#line 3118
#pragma cdir shortloop
#line 3118
    for (i=0; i<ni; i++) {
#line 3118
      /* the normal case: */
#line 3118
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3118
     /* test for range errors (not always needed but do it anyway) */
#line 3118
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3118
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3118
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3118
    }
#line 3118
   /* copy workspace back if necessary */
#line 3118
    if (realign) {
#line 3118
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3118
      xp = (short *) *xpp;
#line 3118
    }
#line 3118
   /* update xpp and tp */
#line 3118
    xp += ni;
#line 3118
    tp += ni;
#line 3118
    *xpp = (void*)xp;
#line 3118
  }
#line 3118
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3118

#line 3118
#else   /* not SX */
#line 3118

#line 3118
	char *xp = (char *) *xpp;
#line 3118
	int status = NC_NOERR;
#line 3118

#line 3118
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3118
	{
#line 3118
		int lstatus = ncx_put_short_double(xp, tp, fillp);
#line 3118
		if (status == NC_NOERR) /* report the first encountered error */
#line 3118
			status = lstatus;
#line 3118
	}
#line 3118

#line 3118
	*xpp = (void *)xp;
#line 3118
	return status;
#line 3118
#endif
#line 3118
}
#line 3118

int
#line 3119
ncx_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3119
{
#line 3119
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3119

#line 3119
 /* basic algorithm is:
#line 3119
  *   - ensure sane alignment of output data
#line 3119
  *   - copy (conversion happens automatically) input data
#line 3119
  *     to output
#line 3119
  *   - update tp to point at next unconverted input, and xpp to point
#line 3119
  *     at next location for converted output
#line 3119
  */
#line 3119
  long i, j, ni;
#line 3119
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3119
  short *xp;
#line 3119
  int nrange = 0;         /* number of range errors */
#line 3119
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3119
  long cxp = (long) *((char**)xpp);
#line 3119

#line 3119
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3119
  /* sjl: manually stripmine so we can limit amount of
#line 3119
   * vector work space reserved to LOOPCNT elements. Also
#line 3119
   * makes vectorisation easy */
#line 3119
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3119
    ni=Min(nelems-j,LOOPCNT);
#line 3119
    if (realign) {
#line 3119
      xp = tmp;
#line 3119
    } else {
#line 3119
      xp = (short *) *xpp;
#line 3119
    }
#line 3119
   /* copy the next block */
#line 3119
#pragma cdir loopcnt=LOOPCNT
#line 3119
#pragma cdir shortloop
#line 3119
    for (i=0; i<ni; i++) {
#line 3119
      /* the normal case: */
#line 3119
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3119
     /* test for range errors (not always needed but do it anyway) */
#line 3119
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3119
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3119
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 3119
    }
#line 3119
   /* copy workspace back if necessary */
#line 3119
    if (realign) {
#line 3119
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3119
      xp = (short *) *xpp;
#line 3119
    }
#line 3119
   /* update xpp and tp */
#line 3119
    xp += ni;
#line 3119
    tp += ni;
#line 3119
    *xpp = (void*)xp;
#line 3119
  }
#line 3119
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3119

#line 3119
#else   /* not SX */
#line 3119

#line 3119
	char *xp = (char *) *xpp;
#line 3119
	int status = NC_NOERR;
#line 3119

#line 3119
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3119
	{
#line 3119
		int lstatus = ncx_put_short_longlong(xp, tp, fillp);
#line 3119
		if (status == NC_NOERR) /* report the first encountered error */
#line 3119
			status = lstatus;
#line 3119
	}
#line 3119

#line 3119
	*xpp = (void *)xp;
#line 3119
	return status;
#line 3119
#endif
#line 3119
}
#line 3119

int
#line 3120
ncx_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3120
{
#line 3120
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3120

#line 3120
 /* basic algorithm is:
#line 3120
  *   - ensure sane alignment of output data
#line 3120
  *   - copy (conversion happens automatically) input data
#line 3120
  *     to output
#line 3120
  *   - update tp to point at next unconverted input, and xpp to point
#line 3120
  *     at next location for converted output
#line 3120
  */
#line 3120
  long i, j, ni;
#line 3120
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3120
  short *xp;
#line 3120
  int nrange = 0;         /* number of range errors */
#line 3120
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3120
  long cxp = (long) *((char**)xpp);
#line 3120

#line 3120
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3120
  /* sjl: manually stripmine so we can limit amount of
#line 3120
   * vector work space reserved to LOOPCNT elements. Also
#line 3120
   * makes vectorisation easy */
#line 3120
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3120
    ni=Min(nelems-j,LOOPCNT);
#line 3120
    if (realign) {
#line 3120
      xp = tmp;
#line 3120
    } else {
#line 3120
      xp = (short *) *xpp;
#line 3120
    }
#line 3120
   /* copy the next block */
#line 3120
#pragma cdir loopcnt=LOOPCNT
#line 3120
#pragma cdir shortloop
#line 3120
    for (i=0; i<ni; i++) {
#line 3120
      /* the normal case: */
#line 3120
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3120
     /* test for range errors (not always needed but do it anyway) */
#line 3120
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3120
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3120
      nrange += tp[i] > X_SHORT_MAX ;
#line 3120
    }
#line 3120
   /* copy workspace back if necessary */
#line 3120
    if (realign) {
#line 3120
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3120
      xp = (short *) *xpp;
#line 3120
    }
#line 3120
   /* update xpp and tp */
#line 3120
    xp += ni;
#line 3120
    tp += ni;
#line 3120
    *xpp = (void*)xp;
#line 3120
  }
#line 3120
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3120

#line 3120
#else   /* not SX */
#line 3120

#line 3120
	char *xp = (char *) *xpp;
#line 3120
	int status = NC_NOERR;
#line 3120

#line 3120
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3120
	{
#line 3120
		int lstatus = ncx_put_short_uchar(xp, tp, fillp);
#line 3120
		if (status == NC_NOERR) /* report the first encountered error */
#line 3120
			status = lstatus;
#line 3120
	}
#line 3120

#line 3120
	*xpp = (void *)xp;
#line 3120
	return status;
#line 3120
#endif
#line 3120
}
#line 3120

int
#line 3121
ncx_putn_short_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3121
{
#line 3121
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3121

#line 3121
 /* basic algorithm is:
#line 3121
  *   - ensure sane alignment of output data
#line 3121
  *   - copy (conversion happens automatically) input data
#line 3121
  *     to output
#line 3121
  *   - update tp to point at next unconverted input, and xpp to point
#line 3121
  *     at next location for converted output
#line 3121
  */
#line 3121
  long i, j, ni;
#line 3121
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3121
  short *xp;
#line 3121
  int nrange = 0;         /* number of range errors */
#line 3121
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3121
  long cxp = (long) *((char**)xpp);
#line 3121

#line 3121
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3121
  /* sjl: manually stripmine so we can limit amount of
#line 3121
   * vector work space reserved to LOOPCNT elements. Also
#line 3121
   * makes vectorisation easy */
#line 3121
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3121
    ni=Min(nelems-j,LOOPCNT);
#line 3121
    if (realign) {
#line 3121
      xp = tmp;
#line 3121
    } else {
#line 3121
      xp = (short *) *xpp;
#line 3121
    }
#line 3121
   /* copy the next block */
#line 3121
#pragma cdir loopcnt=LOOPCNT
#line 3121
#pragma cdir shortloop
#line 3121
    for (i=0; i<ni; i++) {
#line 3121
      /* the normal case: */
#line 3121
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3121
     /* test for range errors (not always needed but do it anyway) */
#line 3121
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3121
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3121
      nrange += tp[i] > X_SHORT_MAX ;
#line 3121
    }
#line 3121
   /* copy workspace back if necessary */
#line 3121
    if (realign) {
#line 3121
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3121
      xp = (short *) *xpp;
#line 3121
    }
#line 3121
   /* update xpp and tp */
#line 3121
    xp += ni;
#line 3121
    tp += ni;
#line 3121
    *xpp = (void*)xp;
#line 3121
  }
#line 3121
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3121

#line 3121
#else   /* not SX */
#line 3121

#line 3121
	char *xp = (char *) *xpp;
#line 3121
	int status = NC_NOERR;
#line 3121

#line 3121
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3121
	{
#line 3121
		int lstatus = ncx_put_short_uint(xp, tp, fillp);
#line 3121
		if (status == NC_NOERR) /* report the first encountered error */
#line 3121
			status = lstatus;
#line 3121
	}
#line 3121

#line 3121
	*xpp = (void *)xp;
#line 3121
	return status;
#line 3121
#endif
#line 3121
}
#line 3121

int
#line 3122
ncx_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3122
{
#line 3122
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3122

#line 3122
 /* basic algorithm is:
#line 3122
  *   - ensure sane alignment of output data
#line 3122
  *   - copy (conversion happens automatically) input data
#line 3122
  *     to output
#line 3122
  *   - update tp to point at next unconverted input, and xpp to point
#line 3122
  *     at next location for converted output
#line 3122
  */
#line 3122
  long i, j, ni;
#line 3122
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3122
  short *xp;
#line 3122
  int nrange = 0;         /* number of range errors */
#line 3122
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3122
  long cxp = (long) *((char**)xpp);
#line 3122

#line 3122
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3122
  /* sjl: manually stripmine so we can limit amount of
#line 3122
   * vector work space reserved to LOOPCNT elements. Also
#line 3122
   * makes vectorisation easy */
#line 3122
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3122
    ni=Min(nelems-j,LOOPCNT);
#line 3122
    if (realign) {
#line 3122
      xp = tmp;
#line 3122
    } else {
#line 3122
      xp = (short *) *xpp;
#line 3122
    }
#line 3122
   /* copy the next block */
#line 3122
#pragma cdir loopcnt=LOOPCNT
#line 3122
#pragma cdir shortloop
#line 3122
    for (i=0; i<ni; i++) {
#line 3122
      /* the normal case: */
#line 3122
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3122
     /* test for range errors (not always needed but do it anyway) */
#line 3122
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3122
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3122
      nrange += tp[i] > X_SHORT_MAX ;
#line 3122
    }
#line 3122
   /* copy workspace back if necessary */
#line 3122
    if (realign) {
#line 3122
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3122
      xp = (short *) *xpp;
#line 3122
    }
#line 3122
   /* update xpp and tp */
#line 3122
    xp += ni;
#line 3122
    tp += ni;
#line 3122
    *xpp = (void*)xp;
#line 3122
  }
#line 3122
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3122

#line 3122
#else   /* not SX */
#line 3122

#line 3122
	char *xp = (char *) *xpp;
#line 3122
	int status = NC_NOERR;
#line 3122

#line 3122
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3122
	{
#line 3122
		int lstatus = ncx_put_short_ulonglong(xp, tp, fillp);
#line 3122
		if (status == NC_NOERR) /* report the first encountered error */
#line 3122
			status = lstatus;
#line 3122
	}
#line 3122

#line 3122
	*xpp = (void *)xp;
#line 3122
	return status;
#line 3122
#endif
#line 3122
}
#line 3122

int
#line 3123
ncx_putn_short_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3123
{
#line 3123
#if defined(_SX) && _SX != 0 && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 3123

#line 3123
 /* basic algorithm is:
#line 3123
  *   - ensure sane alignment of output data
#line 3123
  *   - copy (conversion happens automatically) input data
#line 3123
  *     to output
#line 3123
  *   - update tp to point at next unconverted input, and xpp to point
#line 3123
  *     at next location for converted output
#line 3123
  */
#line 3123
  long i, j, ni;
#line 3123
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 3123
  short *xp;
#line 3123
  int nrange = 0;         /* number of range errors */
#line 3123
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3123
  long cxp = (long) *((char**)xpp);
#line 3123

#line 3123
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 3123
  /* sjl: manually stripmine so we can limit amount of
#line 3123
   * vector work space reserved to LOOPCNT elements. Also
#line 3123
   * makes vectorisation easy */
#line 3123
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3123
    ni=Min(nelems-j,LOOPCNT);
#line 3123
    if (realign) {
#line 3123
      xp = tmp;
#line 3123
    } else {
#line 3123
      xp = (short *) *xpp;
#line 3123
    }
#line 3123
   /* copy the next block */
#line 3123
#pragma cdir loopcnt=LOOPCNT
#line 3123
#pragma cdir shortloop
#line 3123
    for (i=0; i<ni; i++) {
#line 3123
      /* the normal case: */
#line 3123
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 3123
     /* test for range errors (not always needed but do it anyway) */
#line 3123
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3123
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3123
      nrange += tp[i] > X_SHORT_MAX ;
#line 3123
    }
#line 3123
   /* copy workspace back if necessary */
#line 3123
    if (realign) {
#line 3123
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_SHORT);
#line 3123
      xp = (short *) *xpp;
#line 3123
    }
#line 3123
   /* update xpp and tp */
#line 3123
    xp += ni;
#line 3123
    tp += ni;
#line 3123
    *xpp = (void*)xp;
#line 3123
  }
#line 3123
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3123

#line 3123
#else   /* not SX */
#line 3123

#line 3123
	char *xp = (char *) *xpp;
#line 3123
	int status = NC_NOERR;
#line 3123

#line 3123
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3123
	{
#line 3123
		int lstatus = ncx_put_short_ushort(xp, tp, fillp);
#line 3123
		if (status == NC_NOERR) /* report the first encountered error */
#line 3123
			status = lstatus;
#line 3123
	}
#line 3123

#line 3123
	*xpp = (void *)xp;
#line 3123
	return status;
#line 3123
#endif
#line 3123
}
#line 3123


int
#line 3125
ncx_pad_putn_short_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3125
{
#line 3125
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3125

#line 3125
	char *xp = (char *) *xpp;
#line 3125
	int status = NC_NOERR;
#line 3125

#line 3125
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3125
	{
#line 3125
		int lstatus = ncx_put_short_schar(xp, tp, fillp);
#line 3125
		if (status == NC_NOERR) /* report the first encountered error */
#line 3125
			status = lstatus;
#line 3125
	}
#line 3125

#line 3125
	if (rndup != 0)
#line 3125
	{
#line 3125
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3125
		xp += X_SIZEOF_SHORT;
#line 3125
	}
#line 3125

#line 3125
	*xpp = (void *)xp;
#line 3125
	return status;
#line 3125
}
#line 3125

int
#line 3126
ncx_pad_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3126
{
#line 3126
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3126

#line 3126
	char *xp = (char *) *xpp;
#line 3126
	int status = NC_NOERR;
#line 3126

#line 3126
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3126
	{
#line 3126
		int lstatus = ncx_put_short_uchar(xp, tp, fillp);
#line 3126
		if (status == NC_NOERR) /* report the first encountered error */
#line 3126
			status = lstatus;
#line 3126
	}
#line 3126

#line 3126
	if (rndup != 0)
#line 3126
	{
#line 3126
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3126
		xp += X_SIZEOF_SHORT;
#line 3126
	}
#line 3126

#line 3126
	*xpp = (void *)xp;
#line 3126
	return status;
#line 3126
}
#line 3126

int
#line 3127
ncx_pad_putn_short_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3127
{
#line 3127
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3127

#line 3127
	char *xp = (char *) *xpp;
#line 3127
	int status = NC_NOERR;
#line 3127

#line 3127
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3127
	{
#line 3127
		int lstatus = ncx_put_short_short(xp, tp, fillp);
#line 3127
		if (status == NC_NOERR) /* report the first encountered error */
#line 3127
			status = lstatus;
#line 3127
	}
#line 3127

#line 3127
	if (rndup != 0)
#line 3127
	{
#line 3127
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3127
		xp += X_SIZEOF_SHORT;
#line 3127
	}
#line 3127

#line 3127
	*xpp = (void *)xp;
#line 3127
	return status;
#line 3127
}
#line 3127

int
#line 3128
ncx_pad_putn_short_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3128
{
#line 3128
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3128

#line 3128
	char *xp = (char *) *xpp;
#line 3128
	int status = NC_NOERR;
#line 3128

#line 3128
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3128
	{
#line 3128
		int lstatus = ncx_put_short_int(xp, tp, fillp);
#line 3128
		if (status == NC_NOERR) /* report the first encountered error */
#line 3128
			status = lstatus;
#line 3128
	}
#line 3128

#line 3128
	if (rndup != 0)
#line 3128
	{
#line 3128
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3128
		xp += X_SIZEOF_SHORT;
#line 3128
	}
#line 3128

#line 3128
	*xpp = (void *)xp;
#line 3128
	return status;
#line 3128
}
#line 3128

int
#line 3129
ncx_pad_putn_short_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3129
{
#line 3129
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3129

#line 3129
	char *xp = (char *) *xpp;
#line 3129
	int status = NC_NOERR;
#line 3129

#line 3129
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3129
	{
#line 3129
		int lstatus = ncx_put_short_long(xp, tp, fillp);
#line 3129
		if (status == NC_NOERR) /* report the first encountered error */
#line 3129
			status = lstatus;
#line 3129
	}
#line 3129

#line 3129
	if (rndup != 0)
#line 3129
	{
#line 3129
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3129
		xp += X_SIZEOF_SHORT;
#line 3129
	}
#line 3129

#line 3129
	*xpp = (void *)xp;
#line 3129
	return status;
#line 3129
}
#line 3129

int
#line 3130
ncx_pad_putn_short_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3130
{
#line 3130
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3130

#line 3130
	char *xp = (char *) *xpp;
#line 3130
	int status = NC_NOERR;
#line 3130

#line 3130
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3130
	{
#line 3130
		int lstatus = ncx_put_short_float(xp, tp, fillp);
#line 3130
		if (status == NC_NOERR) /* report the first encountered error */
#line 3130
			status = lstatus;
#line 3130
	}
#line 3130

#line 3130
	if (rndup != 0)
#line 3130
	{
#line 3130
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3130
		xp += X_SIZEOF_SHORT;
#line 3130
	}
#line 3130

#line 3130
	*xpp = (void *)xp;
#line 3130
	return status;
#line 3130
}
#line 3130

int
#line 3131
ncx_pad_putn_short_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3131
{
#line 3131
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3131

#line 3131
	char *xp = (char *) *xpp;
#line 3131
	int status = NC_NOERR;
#line 3131

#line 3131
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3131
	{
#line 3131
		int lstatus = ncx_put_short_double(xp, tp, fillp);
#line 3131
		if (status == NC_NOERR) /* report the first encountered error */
#line 3131
			status = lstatus;
#line 3131
	}
#line 3131

#line 3131
	if (rndup != 0)
#line 3131
	{
#line 3131
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3131
		xp += X_SIZEOF_SHORT;
#line 3131
	}
#line 3131

#line 3131
	*xpp = (void *)xp;
#line 3131
	return status;
#line 3131
}
#line 3131

int
#line 3132
ncx_pad_putn_short_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3132
{
#line 3132
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3132

#line 3132
	char *xp = (char *) *xpp;
#line 3132
	int status = NC_NOERR;
#line 3132

#line 3132
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3132
	{
#line 3132
		int lstatus = ncx_put_short_uint(xp, tp, fillp);
#line 3132
		if (status == NC_NOERR) /* report the first encountered error */
#line 3132
			status = lstatus;
#line 3132
	}
#line 3132

#line 3132
	if (rndup != 0)
#line 3132
	{
#line 3132
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3132
		xp += X_SIZEOF_SHORT;
#line 3132
	}
#line 3132

#line 3132
	*xpp = (void *)xp;
#line 3132
	return status;
#line 3132
}
#line 3132

int
#line 3133
ncx_pad_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3133
{
#line 3133
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3133

#line 3133
	char *xp = (char *) *xpp;
#line 3133
	int status = NC_NOERR;
#line 3133

#line 3133
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3133
	{
#line 3133
		int lstatus = ncx_put_short_longlong(xp, tp, fillp);
#line 3133
		if (status == NC_NOERR) /* report the first encountered error */
#line 3133
			status = lstatus;
#line 3133
	}
#line 3133

#line 3133
	if (rndup != 0)
#line 3133
	{
#line 3133
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3133
		xp += X_SIZEOF_SHORT;
#line 3133
	}
#line 3133

#line 3133
	*xpp = (void *)xp;
#line 3133
	return status;
#line 3133
}
#line 3133

int
#line 3134
ncx_pad_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3134
{
#line 3134
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3134

#line 3134
	char *xp = (char *) *xpp;
#line 3134
	int status = NC_NOERR;
#line 3134

#line 3134
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3134
	{
#line 3134
		int lstatus = ncx_put_short_ulonglong(xp, tp, fillp);
#line 3134
		if (status == NC_NOERR) /* report the first encountered error */
#line 3134
			status = lstatus;
#line 3134
	}
#line 3134

#line 3134
	if (rndup != 0)
#line 3134
	{
#line 3134
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3134
		xp += X_SIZEOF_SHORT;
#line 3134
	}
#line 3134

#line 3134
	*xpp = (void *)xp;
#line 3134
	return status;
#line 3134
}
#line 3134

int
#line 3135
ncx_pad_putn_short_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3135
{
#line 3135
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3135

#line 3135
	char *xp = (char *) *xpp;
#line 3135
	int status = NC_NOERR;
#line 3135

#line 3135
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 3135
	{
#line 3135
		int lstatus = ncx_put_short_ushort(xp, tp, fillp);
#line 3135
		if (status == NC_NOERR) /* report the first encountered error */
#line 3135
			status = lstatus;
#line 3135
	}
#line 3135

#line 3135
	if (rndup != 0)
#line 3135
	{
#line 3135
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_SHORT));
#line 3135
		xp += X_SIZEOF_SHORT;
#line 3135
	}
#line 3135

#line 3135
	*xpp = (void *)xp;
#line 3135
	return status;
#line 3135
}
#line 3135



/* ushort --------------------------------------------------------------------*/

#if X_SIZEOF_USHORT == SIZEOF_USHORT
/* optimized version */
int
ncx_getn_ushort_ushort(const void **xpp, size_t nelems, unsigned short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_USHORT);
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_USHORT);
	return NC_NOERR;
}
#else
int
#line 3154
ncx_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3154
{
#line 3154
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3154

#line 3154
 /* basic algorithm is:
#line 3154
  *   - ensure sane alignment of input data
#line 3154
  *   - copy (conversion happens automatically) input data
#line 3154
  *     to output
#line 3154
  *   - update xpp to point at next unconverted input, and tp to point
#line 3154
  *     at next location for converted output
#line 3154
  */
#line 3154
  long i, j, ni;
#line 3154
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3154
  ushort *xp;
#line 3154
  int nrange = 0;         /* number of range errors */
#line 3154
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3154
  long cxp = (long) *((char**)xpp);
#line 3154

#line 3154
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3154
  /* sjl: manually stripmine so we can limit amount of
#line 3154
   * vector work space reserved to LOOPCNT elements. Also
#line 3154
   * makes vectorisation easy */
#line 3154
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3154
    ni=Min(nelems-j,LOOPCNT);
#line 3154
    if (realign) {
#line 3154
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3154
      xp = tmp;
#line 3154
    } else {
#line 3154
      xp = (ushort *) *xpp;
#line 3154
    }
#line 3154
   /* copy the next block */
#line 3154
#pragma cdir loopcnt=LOOPCNT
#line 3154
#pragma cdir shortloop
#line 3154
    for (i=0; i<ni; i++) {
#line 3154
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3154
     /* test for range errors (not always needed but do it anyway) */
#line 3154
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3154
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3154
      nrange += xp[i] > USHORT_MAX ;
#line 3154
    }
#line 3154
   /* update xpp and tp */
#line 3154
    if (realign) xp = (ushort *) *xpp;
#line 3154
    xp += ni;
#line 3154
    tp += ni;
#line 3154
    *xpp = (void*)xp;
#line 3154
  }
#line 3154
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3154

#line 3154
#else   /* not SX */
#line 3154
	const char *xp = (const char *) *xpp;
#line 3154
	int status = NC_NOERR;
#line 3154

#line 3154
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3154
	{
#line 3154
		const int lstatus = ncx_get_ushort_ushort(xp, tp);
#line 3154
		if (status == NC_NOERR) /* report the first encountered error */
#line 3154
			status = lstatus;
#line 3154
	}
#line 3154

#line 3154
	*xpp = (const void *)xp;
#line 3154
	return status;
#line 3154
#endif
#line 3154
}
#line 3154

#endif
int
#line 3156
ncx_getn_ushort_schar(const void **xpp, size_t nelems, schar *tp)
#line 3156
{
#line 3156
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3156

#line 3156
 /* basic algorithm is:
#line 3156
  *   - ensure sane alignment of input data
#line 3156
  *   - copy (conversion happens automatically) input data
#line 3156
  *     to output
#line 3156
  *   - update xpp to point at next unconverted input, and tp to point
#line 3156
  *     at next location for converted output
#line 3156
  */
#line 3156
  long i, j, ni;
#line 3156
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3156
  ushort *xp;
#line 3156
  int nrange = 0;         /* number of range errors */
#line 3156
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3156
  long cxp = (long) *((char**)xpp);
#line 3156

#line 3156
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3156
  /* sjl: manually stripmine so we can limit amount of
#line 3156
   * vector work space reserved to LOOPCNT elements. Also
#line 3156
   * makes vectorisation easy */
#line 3156
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3156
    ni=Min(nelems-j,LOOPCNT);
#line 3156
    if (realign) {
#line 3156
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3156
      xp = tmp;
#line 3156
    } else {
#line 3156
      xp = (ushort *) *xpp;
#line 3156
    }
#line 3156
   /* copy the next block */
#line 3156
#pragma cdir loopcnt=LOOPCNT
#line 3156
#pragma cdir shortloop
#line 3156
    for (i=0; i<ni; i++) {
#line 3156
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3156
     /* test for range errors (not always needed but do it anyway) */
#line 3156
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3156
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3156
      nrange += xp[i] > SCHAR_MAX ;
#line 3156
    }
#line 3156
   /* update xpp and tp */
#line 3156
    if (realign) xp = (ushort *) *xpp;
#line 3156
    xp += ni;
#line 3156
    tp += ni;
#line 3156
    *xpp = (void*)xp;
#line 3156
  }
#line 3156
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3156

#line 3156
#else   /* not SX */
#line 3156
	const char *xp = (const char *) *xpp;
#line 3156
	int status = NC_NOERR;
#line 3156

#line 3156
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3156
	{
#line 3156
		const int lstatus = ncx_get_ushort_schar(xp, tp);
#line 3156
		if (status == NC_NOERR) /* report the first encountered error */
#line 3156
			status = lstatus;
#line 3156
	}
#line 3156

#line 3156
	*xpp = (const void *)xp;
#line 3156
	return status;
#line 3156
#endif
#line 3156
}
#line 3156

int
#line 3157
ncx_getn_ushort_short(const void **xpp, size_t nelems, short *tp)
#line 3157
{
#line 3157
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3157

#line 3157
 /* basic algorithm is:
#line 3157
  *   - ensure sane alignment of input data
#line 3157
  *   - copy (conversion happens automatically) input data
#line 3157
  *     to output
#line 3157
  *   - update xpp to point at next unconverted input, and tp to point
#line 3157
  *     at next location for converted output
#line 3157
  */
#line 3157
  long i, j, ni;
#line 3157
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3157
  ushort *xp;
#line 3157
  int nrange = 0;         /* number of range errors */
#line 3157
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3157
  long cxp = (long) *((char**)xpp);
#line 3157

#line 3157
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3157
  /* sjl: manually stripmine so we can limit amount of
#line 3157
   * vector work space reserved to LOOPCNT elements. Also
#line 3157
   * makes vectorisation easy */
#line 3157
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3157
    ni=Min(nelems-j,LOOPCNT);
#line 3157
    if (realign) {
#line 3157
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3157
      xp = tmp;
#line 3157
    } else {
#line 3157
      xp = (ushort *) *xpp;
#line 3157
    }
#line 3157
   /* copy the next block */
#line 3157
#pragma cdir loopcnt=LOOPCNT
#line 3157
#pragma cdir shortloop
#line 3157
    for (i=0; i<ni; i++) {
#line 3157
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3157
     /* test for range errors (not always needed but do it anyway) */
#line 3157
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3157
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3157
      nrange += xp[i] > SHORT_MAX ;
#line 3157
    }
#line 3157
   /* update xpp and tp */
#line 3157
    if (realign) xp = (ushort *) *xpp;
#line 3157
    xp += ni;
#line 3157
    tp += ni;
#line 3157
    *xpp = (void*)xp;
#line 3157
  }
#line 3157
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3157

#line 3157
#else   /* not SX */
#line 3157
	const char *xp = (const char *) *xpp;
#line 3157
	int status = NC_NOERR;
#line 3157

#line 3157
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3157
	{
#line 3157
		const int lstatus = ncx_get_ushort_short(xp, tp);
#line 3157
		if (status == NC_NOERR) /* report the first encountered error */
#line 3157
			status = lstatus;
#line 3157
	}
#line 3157

#line 3157
	*xpp = (const void *)xp;
#line 3157
	return status;
#line 3157
#endif
#line 3157
}
#line 3157

int
#line 3158
ncx_getn_ushort_int(const void **xpp, size_t nelems, int *tp)
#line 3158
{
#line 3158
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3158

#line 3158
 /* basic algorithm is:
#line 3158
  *   - ensure sane alignment of input data
#line 3158
  *   - copy (conversion happens automatically) input data
#line 3158
  *     to output
#line 3158
  *   - update xpp to point at next unconverted input, and tp to point
#line 3158
  *     at next location for converted output
#line 3158
  */
#line 3158
  long i, j, ni;
#line 3158
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3158
  ushort *xp;
#line 3158
  int nrange = 0;         /* number of range errors */
#line 3158
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3158
  long cxp = (long) *((char**)xpp);
#line 3158

#line 3158
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3158
  /* sjl: manually stripmine so we can limit amount of
#line 3158
   * vector work space reserved to LOOPCNT elements. Also
#line 3158
   * makes vectorisation easy */
#line 3158
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3158
    ni=Min(nelems-j,LOOPCNT);
#line 3158
    if (realign) {
#line 3158
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3158
      xp = tmp;
#line 3158
    } else {
#line 3158
      xp = (ushort *) *xpp;
#line 3158
    }
#line 3158
   /* copy the next block */
#line 3158
#pragma cdir loopcnt=LOOPCNT
#line 3158
#pragma cdir shortloop
#line 3158
    for (i=0; i<ni; i++) {
#line 3158
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3158
     /* test for range errors (not always needed but do it anyway) */
#line 3158
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3158
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3158
      nrange += xp[i] > INT_MAX ;
#line 3158
    }
#line 3158
   /* update xpp and tp */
#line 3158
    if (realign) xp = (ushort *) *xpp;
#line 3158
    xp += ni;
#line 3158
    tp += ni;
#line 3158
    *xpp = (void*)xp;
#line 3158
  }
#line 3158
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3158

#line 3158
#else   /* not SX */
#line 3158
	const char *xp = (const char *) *xpp;
#line 3158
	int status = NC_NOERR;
#line 3158

#line 3158
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3158
	{
#line 3158
		const int lstatus = ncx_get_ushort_int(xp, tp);
#line 3158
		if (status == NC_NOERR) /* report the first encountered error */
#line 3158
			status = lstatus;
#line 3158
	}
#line 3158

#line 3158
	*xpp = (const void *)xp;
#line 3158
	return status;
#line 3158
#endif
#line 3158
}
#line 3158

int
#line 3159
ncx_getn_ushort_long(const void **xpp, size_t nelems, long *tp)
#line 3159
{
#line 3159
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3159

#line 3159
 /* basic algorithm is:
#line 3159
  *   - ensure sane alignment of input data
#line 3159
  *   - copy (conversion happens automatically) input data
#line 3159
  *     to output
#line 3159
  *   - update xpp to point at next unconverted input, and tp to point
#line 3159
  *     at next location for converted output
#line 3159
  */
#line 3159
  long i, j, ni;
#line 3159
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3159
  ushort *xp;
#line 3159
  int nrange = 0;         /* number of range errors */
#line 3159
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3159
  long cxp = (long) *((char**)xpp);
#line 3159

#line 3159
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3159
  /* sjl: manually stripmine so we can limit amount of
#line 3159
   * vector work space reserved to LOOPCNT elements. Also
#line 3159
   * makes vectorisation easy */
#line 3159
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3159
    ni=Min(nelems-j,LOOPCNT);
#line 3159
    if (realign) {
#line 3159
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3159
      xp = tmp;
#line 3159
    } else {
#line 3159
      xp = (ushort *) *xpp;
#line 3159
    }
#line 3159
   /* copy the next block */
#line 3159
#pragma cdir loopcnt=LOOPCNT
#line 3159
#pragma cdir shortloop
#line 3159
    for (i=0; i<ni; i++) {
#line 3159
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3159
     /* test for range errors (not always needed but do it anyway) */
#line 3159
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3159
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3159
      nrange += xp[i] > LONG_MAX ;
#line 3159
    }
#line 3159
   /* update xpp and tp */
#line 3159
    if (realign) xp = (ushort *) *xpp;
#line 3159
    xp += ni;
#line 3159
    tp += ni;
#line 3159
    *xpp = (void*)xp;
#line 3159
  }
#line 3159
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3159

#line 3159
#else   /* not SX */
#line 3159
	const char *xp = (const char *) *xpp;
#line 3159
	int status = NC_NOERR;
#line 3159

#line 3159
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3159
	{
#line 3159
		const int lstatus = ncx_get_ushort_long(xp, tp);
#line 3159
		if (status == NC_NOERR) /* report the first encountered error */
#line 3159
			status = lstatus;
#line 3159
	}
#line 3159

#line 3159
	*xpp = (const void *)xp;
#line 3159
	return status;
#line 3159
#endif
#line 3159
}
#line 3159

int
#line 3160
ncx_getn_ushort_float(const void **xpp, size_t nelems, float *tp)
#line 3160
{
#line 3160
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3160

#line 3160
 /* basic algorithm is:
#line 3160
  *   - ensure sane alignment of input data
#line 3160
  *   - copy (conversion happens automatically) input data
#line 3160
  *     to output
#line 3160
  *   - update xpp to point at next unconverted input, and tp to point
#line 3160
  *     at next location for converted output
#line 3160
  */
#line 3160
  long i, j, ni;
#line 3160
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3160
  ushort *xp;
#line 3160
  int nrange = 0;         /* number of range errors */
#line 3160
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3160
  long cxp = (long) *((char**)xpp);
#line 3160

#line 3160
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3160
  /* sjl: manually stripmine so we can limit amount of
#line 3160
   * vector work space reserved to LOOPCNT elements. Also
#line 3160
   * makes vectorisation easy */
#line 3160
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3160
    ni=Min(nelems-j,LOOPCNT);
#line 3160
    if (realign) {
#line 3160
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3160
      xp = tmp;
#line 3160
    } else {
#line 3160
      xp = (ushort *) *xpp;
#line 3160
    }
#line 3160
   /* copy the next block */
#line 3160
#pragma cdir loopcnt=LOOPCNT
#line 3160
#pragma cdir shortloop
#line 3160
    for (i=0; i<ni; i++) {
#line 3160
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3160
     /* test for range errors (not always needed but do it anyway) */
#line 3160
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3160
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3160
      nrange += xp[i] > FLOAT_MAX ;
#line 3160
    }
#line 3160
   /* update xpp and tp */
#line 3160
    if (realign) xp = (ushort *) *xpp;
#line 3160
    xp += ni;
#line 3160
    tp += ni;
#line 3160
    *xpp = (void*)xp;
#line 3160
  }
#line 3160
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3160

#line 3160
#else   /* not SX */
#line 3160
	const char *xp = (const char *) *xpp;
#line 3160
	int status = NC_NOERR;
#line 3160

#line 3160
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3160
	{
#line 3160
		const int lstatus = ncx_get_ushort_float(xp, tp);
#line 3160
		if (status == NC_NOERR) /* report the first encountered error */
#line 3160
			status = lstatus;
#line 3160
	}
#line 3160

#line 3160
	*xpp = (const void *)xp;
#line 3160
	return status;
#line 3160
#endif
#line 3160
}
#line 3160

int
#line 3161
ncx_getn_ushort_double(const void **xpp, size_t nelems, double *tp)
#line 3161
{
#line 3161
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3161

#line 3161
 /* basic algorithm is:
#line 3161
  *   - ensure sane alignment of input data
#line 3161
  *   - copy (conversion happens automatically) input data
#line 3161
  *     to output
#line 3161
  *   - update xpp to point at next unconverted input, and tp to point
#line 3161
  *     at next location for converted output
#line 3161
  */
#line 3161
  long i, j, ni;
#line 3161
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3161
  ushort *xp;
#line 3161
  int nrange = 0;         /* number of range errors */
#line 3161
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3161
  long cxp = (long) *((char**)xpp);
#line 3161

#line 3161
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3161
  /* sjl: manually stripmine so we can limit amount of
#line 3161
   * vector work space reserved to LOOPCNT elements. Also
#line 3161
   * makes vectorisation easy */
#line 3161
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3161
    ni=Min(nelems-j,LOOPCNT);
#line 3161
    if (realign) {
#line 3161
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3161
      xp = tmp;
#line 3161
    } else {
#line 3161
      xp = (ushort *) *xpp;
#line 3161
    }
#line 3161
   /* copy the next block */
#line 3161
#pragma cdir loopcnt=LOOPCNT
#line 3161
#pragma cdir shortloop
#line 3161
    for (i=0; i<ni; i++) {
#line 3161
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3161
     /* test for range errors (not always needed but do it anyway) */
#line 3161
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3161
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3161
      nrange += xp[i] > DOUBLE_MAX ;
#line 3161
    }
#line 3161
   /* update xpp and tp */
#line 3161
    if (realign) xp = (ushort *) *xpp;
#line 3161
    xp += ni;
#line 3161
    tp += ni;
#line 3161
    *xpp = (void*)xp;
#line 3161
  }
#line 3161
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3161

#line 3161
#else   /* not SX */
#line 3161
	const char *xp = (const char *) *xpp;
#line 3161
	int status = NC_NOERR;
#line 3161

#line 3161
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3161
	{
#line 3161
		const int lstatus = ncx_get_ushort_double(xp, tp);
#line 3161
		if (status == NC_NOERR) /* report the first encountered error */
#line 3161
			status = lstatus;
#line 3161
	}
#line 3161

#line 3161
	*xpp = (const void *)xp;
#line 3161
	return status;
#line 3161
#endif
#line 3161
}
#line 3161

int
#line 3162
ncx_getn_ushort_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3162
{
#line 3162
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3162

#line 3162
 /* basic algorithm is:
#line 3162
  *   - ensure sane alignment of input data
#line 3162
  *   - copy (conversion happens automatically) input data
#line 3162
  *     to output
#line 3162
  *   - update xpp to point at next unconverted input, and tp to point
#line 3162
  *     at next location for converted output
#line 3162
  */
#line 3162
  long i, j, ni;
#line 3162
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3162
  ushort *xp;
#line 3162
  int nrange = 0;         /* number of range errors */
#line 3162
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3162
  long cxp = (long) *((char**)xpp);
#line 3162

#line 3162
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3162
  /* sjl: manually stripmine so we can limit amount of
#line 3162
   * vector work space reserved to LOOPCNT elements. Also
#line 3162
   * makes vectorisation easy */
#line 3162
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3162
    ni=Min(nelems-j,LOOPCNT);
#line 3162
    if (realign) {
#line 3162
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3162
      xp = tmp;
#line 3162
    } else {
#line 3162
      xp = (ushort *) *xpp;
#line 3162
    }
#line 3162
   /* copy the next block */
#line 3162
#pragma cdir loopcnt=LOOPCNT
#line 3162
#pragma cdir shortloop
#line 3162
    for (i=0; i<ni; i++) {
#line 3162
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3162
     /* test for range errors (not always needed but do it anyway) */
#line 3162
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3162
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3162
      nrange += xp[i] > LONGLONG_MAX ;
#line 3162
    }
#line 3162
   /* update xpp and tp */
#line 3162
    if (realign) xp = (ushort *) *xpp;
#line 3162
    xp += ni;
#line 3162
    tp += ni;
#line 3162
    *xpp = (void*)xp;
#line 3162
  }
#line 3162
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3162

#line 3162
#else   /* not SX */
#line 3162
	const char *xp = (const char *) *xpp;
#line 3162
	int status = NC_NOERR;
#line 3162

#line 3162
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3162
	{
#line 3162
		const int lstatus = ncx_get_ushort_longlong(xp, tp);
#line 3162
		if (status == NC_NOERR) /* report the first encountered error */
#line 3162
			status = lstatus;
#line 3162
	}
#line 3162

#line 3162
	*xpp = (const void *)xp;
#line 3162
	return status;
#line 3162
#endif
#line 3162
}
#line 3162

int
#line 3163
ncx_getn_ushort_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3163
{
#line 3163
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3163

#line 3163
 /* basic algorithm is:
#line 3163
  *   - ensure sane alignment of input data
#line 3163
  *   - copy (conversion happens automatically) input data
#line 3163
  *     to output
#line 3163
  *   - update xpp to point at next unconverted input, and tp to point
#line 3163
  *     at next location for converted output
#line 3163
  */
#line 3163
  long i, j, ni;
#line 3163
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3163
  ushort *xp;
#line 3163
  int nrange = 0;         /* number of range errors */
#line 3163
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3163
  long cxp = (long) *((char**)xpp);
#line 3163

#line 3163
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3163
  /* sjl: manually stripmine so we can limit amount of
#line 3163
   * vector work space reserved to LOOPCNT elements. Also
#line 3163
   * makes vectorisation easy */
#line 3163
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3163
    ni=Min(nelems-j,LOOPCNT);
#line 3163
    if (realign) {
#line 3163
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3163
      xp = tmp;
#line 3163
    } else {
#line 3163
      xp = (ushort *) *xpp;
#line 3163
    }
#line 3163
   /* copy the next block */
#line 3163
#pragma cdir loopcnt=LOOPCNT
#line 3163
#pragma cdir shortloop
#line 3163
    for (i=0; i<ni; i++) {
#line 3163
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3163
     /* test for range errors (not always needed but do it anyway) */
#line 3163
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3163
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3163
      nrange += xp[i] > UCHAR_MAX ;
#line 3163
    }
#line 3163
   /* update xpp and tp */
#line 3163
    if (realign) xp = (ushort *) *xpp;
#line 3163
    xp += ni;
#line 3163
    tp += ni;
#line 3163
    *xpp = (void*)xp;
#line 3163
  }
#line 3163
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3163

#line 3163
#else   /* not SX */
#line 3163
	const char *xp = (const char *) *xpp;
#line 3163
	int status = NC_NOERR;
#line 3163

#line 3163
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3163
	{
#line 3163
		const int lstatus = ncx_get_ushort_uchar(xp, tp);
#line 3163
		if (status == NC_NOERR) /* report the first encountered error */
#line 3163
			status = lstatus;
#line 3163
	}
#line 3163

#line 3163
	*xpp = (const void *)xp;
#line 3163
	return status;
#line 3163
#endif
#line 3163
}
#line 3163

int
#line 3164
ncx_getn_ushort_uint(const void **xpp, size_t nelems, uint *tp)
#line 3164
{
#line 3164
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3164

#line 3164
 /* basic algorithm is:
#line 3164
  *   - ensure sane alignment of input data
#line 3164
  *   - copy (conversion happens automatically) input data
#line 3164
  *     to output
#line 3164
  *   - update xpp to point at next unconverted input, and tp to point
#line 3164
  *     at next location for converted output
#line 3164
  */
#line 3164
  long i, j, ni;
#line 3164
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3164
  ushort *xp;
#line 3164
  int nrange = 0;         /* number of range errors */
#line 3164
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3164
  long cxp = (long) *((char**)xpp);
#line 3164

#line 3164
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3164
  /* sjl: manually stripmine so we can limit amount of
#line 3164
   * vector work space reserved to LOOPCNT elements. Also
#line 3164
   * makes vectorisation easy */
#line 3164
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3164
    ni=Min(nelems-j,LOOPCNT);
#line 3164
    if (realign) {
#line 3164
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3164
      xp = tmp;
#line 3164
    } else {
#line 3164
      xp = (ushort *) *xpp;
#line 3164
    }
#line 3164
   /* copy the next block */
#line 3164
#pragma cdir loopcnt=LOOPCNT
#line 3164
#pragma cdir shortloop
#line 3164
    for (i=0; i<ni; i++) {
#line 3164
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3164
     /* test for range errors (not always needed but do it anyway) */
#line 3164
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3164
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3164
      nrange += xp[i] > UINT_MAX ;
#line 3164
    }
#line 3164
   /* update xpp and tp */
#line 3164
    if (realign) xp = (ushort *) *xpp;
#line 3164
    xp += ni;
#line 3164
    tp += ni;
#line 3164
    *xpp = (void*)xp;
#line 3164
  }
#line 3164
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3164

#line 3164
#else   /* not SX */
#line 3164
	const char *xp = (const char *) *xpp;
#line 3164
	int status = NC_NOERR;
#line 3164

#line 3164
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3164
	{
#line 3164
		const int lstatus = ncx_get_ushort_uint(xp, tp);
#line 3164
		if (status == NC_NOERR) /* report the first encountered error */
#line 3164
			status = lstatus;
#line 3164
	}
#line 3164

#line 3164
	*xpp = (const void *)xp;
#line 3164
	return status;
#line 3164
#endif
#line 3164
}
#line 3164

int
#line 3165
ncx_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3165
{
#line 3165
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3165

#line 3165
 /* basic algorithm is:
#line 3165
  *   - ensure sane alignment of input data
#line 3165
  *   - copy (conversion happens automatically) input data
#line 3165
  *     to output
#line 3165
  *   - update xpp to point at next unconverted input, and tp to point
#line 3165
  *     at next location for converted output
#line 3165
  */
#line 3165
  long i, j, ni;
#line 3165
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3165
  ushort *xp;
#line 3165
  int nrange = 0;         /* number of range errors */
#line 3165
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3165
  long cxp = (long) *((char**)xpp);
#line 3165

#line 3165
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3165
  /* sjl: manually stripmine so we can limit amount of
#line 3165
   * vector work space reserved to LOOPCNT elements. Also
#line 3165
   * makes vectorisation easy */
#line 3165
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3165
    ni=Min(nelems-j,LOOPCNT);
#line 3165
    if (realign) {
#line 3165
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_USHORT));
#line 3165
      xp = tmp;
#line 3165
    } else {
#line 3165
      xp = (ushort *) *xpp;
#line 3165
    }
#line 3165
   /* copy the next block */
#line 3165
#pragma cdir loopcnt=LOOPCNT
#line 3165
#pragma cdir shortloop
#line 3165
    for (i=0; i<ni; i++) {
#line 3165
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3165
     /* test for range errors (not always needed but do it anyway) */
#line 3165
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3165
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3165
      nrange += xp[i] > ULONGLONG_MAX ;
#line 3165
    }
#line 3165
   /* update xpp and tp */
#line 3165
    if (realign) xp = (ushort *) *xpp;
#line 3165
    xp += ni;
#line 3165
    tp += ni;
#line 3165
    *xpp = (void*)xp;
#line 3165
  }
#line 3165
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3165

#line 3165
#else   /* not SX */
#line 3165
	const char *xp = (const char *) *xpp;
#line 3165
	int status = NC_NOERR;
#line 3165

#line 3165
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3165
	{
#line 3165
		const int lstatus = ncx_get_ushort_ulonglong(xp, tp);
#line 3165
		if (status == NC_NOERR) /* report the first encountered error */
#line 3165
			status = lstatus;
#line 3165
	}
#line 3165

#line 3165
	*xpp = (const void *)xp;
#line 3165
	return status;
#line 3165
#endif
#line 3165
}
#line 3165


int
#line 3167
ncx_pad_getn_ushort_schar(const void **xpp, size_t nelems, schar *tp)
#line 3167
{
#line 3167
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3167

#line 3167
	const char *xp = (const char *) *xpp;
#line 3167
	int status = NC_NOERR;
#line 3167

#line 3167
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3167
	{
#line 3167
		const int lstatus = ncx_get_ushort_schar(xp, tp);
#line 3167
		if (status == NC_NOERR) /* report the first encountered error */
#line 3167
			status = lstatus;
#line 3167
	}
#line 3167

#line 3167
	if (rndup != 0)
#line 3167
		xp += X_SIZEOF_USHORT;
#line 3167

#line 3167
	*xpp = (void *)xp;
#line 3167
	return status;
#line 3167
}
#line 3167

int
#line 3168
ncx_pad_getn_ushort_short(const void **xpp, size_t nelems, short *tp)
#line 3168
{
#line 3168
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3168

#line 3168
	const char *xp = (const char *) *xpp;
#line 3168
	int status = NC_NOERR;
#line 3168

#line 3168
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3168
	{
#line 3168
		const int lstatus = ncx_get_ushort_short(xp, tp);
#line 3168
		if (status == NC_NOERR) /* report the first encountered error */
#line 3168
			status = lstatus;
#line 3168
	}
#line 3168

#line 3168
	if (rndup != 0)
#line 3168
		xp += X_SIZEOF_USHORT;
#line 3168

#line 3168
	*xpp = (void *)xp;
#line 3168
	return status;
#line 3168
}
#line 3168

int
#line 3169
ncx_pad_getn_ushort_int(const void **xpp, size_t nelems, int *tp)
#line 3169
{
#line 3169
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3169

#line 3169
	const char *xp = (const char *) *xpp;
#line 3169
	int status = NC_NOERR;
#line 3169

#line 3169
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3169
	{
#line 3169
		const int lstatus = ncx_get_ushort_int(xp, tp);
#line 3169
		if (status == NC_NOERR) /* report the first encountered error */
#line 3169
			status = lstatus;
#line 3169
	}
#line 3169

#line 3169
	if (rndup != 0)
#line 3169
		xp += X_SIZEOF_USHORT;
#line 3169

#line 3169
	*xpp = (void *)xp;
#line 3169
	return status;
#line 3169
}
#line 3169

int
#line 3170
ncx_pad_getn_ushort_long(const void **xpp, size_t nelems, long *tp)
#line 3170
{
#line 3170
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3170

#line 3170
	const char *xp = (const char *) *xpp;
#line 3170
	int status = NC_NOERR;
#line 3170

#line 3170
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3170
	{
#line 3170
		const int lstatus = ncx_get_ushort_long(xp, tp);
#line 3170
		if (status == NC_NOERR) /* report the first encountered error */
#line 3170
			status = lstatus;
#line 3170
	}
#line 3170

#line 3170
	if (rndup != 0)
#line 3170
		xp += X_SIZEOF_USHORT;
#line 3170

#line 3170
	*xpp = (void *)xp;
#line 3170
	return status;
#line 3170
}
#line 3170

int
#line 3171
ncx_pad_getn_ushort_float(const void **xpp, size_t nelems, float *tp)
#line 3171
{
#line 3171
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3171

#line 3171
	const char *xp = (const char *) *xpp;
#line 3171
	int status = NC_NOERR;
#line 3171

#line 3171
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3171
	{
#line 3171
		const int lstatus = ncx_get_ushort_float(xp, tp);
#line 3171
		if (status == NC_NOERR) /* report the first encountered error */
#line 3171
			status = lstatus;
#line 3171
	}
#line 3171

#line 3171
	if (rndup != 0)
#line 3171
		xp += X_SIZEOF_USHORT;
#line 3171

#line 3171
	*xpp = (void *)xp;
#line 3171
	return status;
#line 3171
}
#line 3171

int
#line 3172
ncx_pad_getn_ushort_double(const void **xpp, size_t nelems, double *tp)
#line 3172
{
#line 3172
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3172

#line 3172
	const char *xp = (const char *) *xpp;
#line 3172
	int status = NC_NOERR;
#line 3172

#line 3172
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3172
	{
#line 3172
		const int lstatus = ncx_get_ushort_double(xp, tp);
#line 3172
		if (status == NC_NOERR) /* report the first encountered error */
#line 3172
			status = lstatus;
#line 3172
	}
#line 3172

#line 3172
	if (rndup != 0)
#line 3172
		xp += X_SIZEOF_USHORT;
#line 3172

#line 3172
	*xpp = (void *)xp;
#line 3172
	return status;
#line 3172
}
#line 3172

int
#line 3173
ncx_pad_getn_ushort_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3173
{
#line 3173
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3173

#line 3173
	const char *xp = (const char *) *xpp;
#line 3173
	int status = NC_NOERR;
#line 3173

#line 3173
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3173
	{
#line 3173
		const int lstatus = ncx_get_ushort_uchar(xp, tp);
#line 3173
		if (status == NC_NOERR) /* report the first encountered error */
#line 3173
			status = lstatus;
#line 3173
	}
#line 3173

#line 3173
	if (rndup != 0)
#line 3173
		xp += X_SIZEOF_USHORT;
#line 3173

#line 3173
	*xpp = (void *)xp;
#line 3173
	return status;
#line 3173
}
#line 3173

int
#line 3174
ncx_pad_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3174
{
#line 3174
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3174

#line 3174
	const char *xp = (const char *) *xpp;
#line 3174
	int status = NC_NOERR;
#line 3174

#line 3174
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3174
	{
#line 3174
		const int lstatus = ncx_get_ushort_ushort(xp, tp);
#line 3174
		if (status == NC_NOERR) /* report the first encountered error */
#line 3174
			status = lstatus;
#line 3174
	}
#line 3174

#line 3174
	if (rndup != 0)
#line 3174
		xp += X_SIZEOF_USHORT;
#line 3174

#line 3174
	*xpp = (void *)xp;
#line 3174
	return status;
#line 3174
}
#line 3174

int
#line 3175
ncx_pad_getn_ushort_uint(const void **xpp, size_t nelems, uint *tp)
#line 3175
{
#line 3175
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3175

#line 3175
	const char *xp = (const char *) *xpp;
#line 3175
	int status = NC_NOERR;
#line 3175

#line 3175
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3175
	{
#line 3175
		const int lstatus = ncx_get_ushort_uint(xp, tp);
#line 3175
		if (status == NC_NOERR) /* report the first encountered error */
#line 3175
			status = lstatus;
#line 3175
	}
#line 3175

#line 3175
	if (rndup != 0)
#line 3175
		xp += X_SIZEOF_USHORT;
#line 3175

#line 3175
	*xpp = (void *)xp;
#line 3175
	return status;
#line 3175
}
#line 3175

int
#line 3176
ncx_pad_getn_ushort_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3176
{
#line 3176
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3176

#line 3176
	const char *xp = (const char *) *xpp;
#line 3176
	int status = NC_NOERR;
#line 3176

#line 3176
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3176
	{
#line 3176
		const int lstatus = ncx_get_ushort_longlong(xp, tp);
#line 3176
		if (status == NC_NOERR) /* report the first encountered error */
#line 3176
			status = lstatus;
#line 3176
	}
#line 3176

#line 3176
	if (rndup != 0)
#line 3176
		xp += X_SIZEOF_USHORT;
#line 3176

#line 3176
	*xpp = (void *)xp;
#line 3176
	return status;
#line 3176
}
#line 3176

int
#line 3177
ncx_pad_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3177
{
#line 3177
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3177

#line 3177
	const char *xp = (const char *) *xpp;
#line 3177
	int status = NC_NOERR;
#line 3177

#line 3177
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3177
	{
#line 3177
		const int lstatus = ncx_get_ushort_ulonglong(xp, tp);
#line 3177
		if (status == NC_NOERR) /* report the first encountered error */
#line 3177
			status = lstatus;
#line 3177
	}
#line 3177

#line 3177
	if (rndup != 0)
#line 3177
		xp += X_SIZEOF_USHORT;
#line 3177

#line 3177
	*xpp = (void *)xp;
#line 3177
	return status;
#line 3177
}
#line 3177


#if X_SIZEOF_USHORT == SIZEOF_USHORT
/* optimized version */
int
ncx_putn_ushort_ushort(void **xpp, size_t nelems, const unsigned short *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_USHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_USHORT);
	return NC_NOERR;
}
#else
int
#line 3193
ncx_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3193
{
#line 3193
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3193

#line 3193
 /* basic algorithm is:
#line 3193
  *   - ensure sane alignment of output data
#line 3193
  *   - copy (conversion happens automatically) input data
#line 3193
  *     to output
#line 3193
  *   - update tp to point at next unconverted input, and xpp to point
#line 3193
  *     at next location for converted output
#line 3193
  */
#line 3193
  long i, j, ni;
#line 3193
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3193
  ushort *xp;
#line 3193
  int nrange = 0;         /* number of range errors */
#line 3193
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3193
  long cxp = (long) *((char**)xpp);
#line 3193

#line 3193
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3193
  /* sjl: manually stripmine so we can limit amount of
#line 3193
   * vector work space reserved to LOOPCNT elements. Also
#line 3193
   * makes vectorisation easy */
#line 3193
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3193
    ni=Min(nelems-j,LOOPCNT);
#line 3193
    if (realign) {
#line 3193
      xp = tmp;
#line 3193
    } else {
#line 3193
      xp = (ushort *) *xpp;
#line 3193
    }
#line 3193
   /* copy the next block */
#line 3193
#pragma cdir loopcnt=LOOPCNT
#line 3193
#pragma cdir shortloop
#line 3193
    for (i=0; i<ni; i++) {
#line 3193
      /* the normal case: */
#line 3193
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3193
     /* test for range errors (not always needed but do it anyway) */
#line 3193
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3193
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3193
      nrange += tp[i] > X_USHORT_MAX ;
#line 3193
    }
#line 3193
   /* copy workspace back if necessary */
#line 3193
    if (realign) {
#line 3193
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3193
      xp = (ushort *) *xpp;
#line 3193
    }
#line 3193
   /* update xpp and tp */
#line 3193
    xp += ni;
#line 3193
    tp += ni;
#line 3193
    *xpp = (void*)xp;
#line 3193
  }
#line 3193
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3193

#line 3193
#else   /* not SX */
#line 3193

#line 3193
	char *xp = (char *) *xpp;
#line 3193
	int status = NC_NOERR;
#line 3193

#line 3193
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3193
	{
#line 3193
		int lstatus = ncx_put_ushort_ushort(xp, tp, fillp);
#line 3193
		if (status == NC_NOERR) /* report the first encountered error */
#line 3193
			status = lstatus;
#line 3193
	}
#line 3193

#line 3193
	*xpp = (void *)xp;
#line 3193
	return status;
#line 3193
#endif
#line 3193
}
#line 3193

#endif
int
#line 3195
ncx_putn_ushort_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3195
{
#line 3195
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3195

#line 3195
 /* basic algorithm is:
#line 3195
  *   - ensure sane alignment of output data
#line 3195
  *   - copy (conversion happens automatically) input data
#line 3195
  *     to output
#line 3195
  *   - update tp to point at next unconverted input, and xpp to point
#line 3195
  *     at next location for converted output
#line 3195
  */
#line 3195
  long i, j, ni;
#line 3195
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3195
  ushort *xp;
#line 3195
  int nrange = 0;         /* number of range errors */
#line 3195
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3195
  long cxp = (long) *((char**)xpp);
#line 3195

#line 3195
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3195
  /* sjl: manually stripmine so we can limit amount of
#line 3195
   * vector work space reserved to LOOPCNT elements. Also
#line 3195
   * makes vectorisation easy */
#line 3195
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3195
    ni=Min(nelems-j,LOOPCNT);
#line 3195
    if (realign) {
#line 3195
      xp = tmp;
#line 3195
    } else {
#line 3195
      xp = (ushort *) *xpp;
#line 3195
    }
#line 3195
   /* copy the next block */
#line 3195
#pragma cdir loopcnt=LOOPCNT
#line 3195
#pragma cdir shortloop
#line 3195
    for (i=0; i<ni; i++) {
#line 3195
      /* the normal case: */
#line 3195
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3195
     /* test for range errors (not always needed but do it anyway) */
#line 3195
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3195
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3195
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3195
    }
#line 3195
   /* copy workspace back if necessary */
#line 3195
    if (realign) {
#line 3195
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3195
      xp = (ushort *) *xpp;
#line 3195
    }
#line 3195
   /* update xpp and tp */
#line 3195
    xp += ni;
#line 3195
    tp += ni;
#line 3195
    *xpp = (void*)xp;
#line 3195
  }
#line 3195
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3195

#line 3195
#else   /* not SX */
#line 3195

#line 3195
	char *xp = (char *) *xpp;
#line 3195
	int status = NC_NOERR;
#line 3195

#line 3195
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3195
	{
#line 3195
		int lstatus = ncx_put_ushort_schar(xp, tp, fillp);
#line 3195
		if (status == NC_NOERR) /* report the first encountered error */
#line 3195
			status = lstatus;
#line 3195
	}
#line 3195

#line 3195
	*xpp = (void *)xp;
#line 3195
	return status;
#line 3195
#endif
#line 3195
}
#line 3195

int
#line 3196
ncx_putn_ushort_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3196
{
#line 3196
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3196

#line 3196
 /* basic algorithm is:
#line 3196
  *   - ensure sane alignment of output data
#line 3196
  *   - copy (conversion happens automatically) input data
#line 3196
  *     to output
#line 3196
  *   - update tp to point at next unconverted input, and xpp to point
#line 3196
  *     at next location for converted output
#line 3196
  */
#line 3196
  long i, j, ni;
#line 3196
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3196
  ushort *xp;
#line 3196
  int nrange = 0;         /* number of range errors */
#line 3196
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3196
  long cxp = (long) *((char**)xpp);
#line 3196

#line 3196
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3196
  /* sjl: manually stripmine so we can limit amount of
#line 3196
   * vector work space reserved to LOOPCNT elements. Also
#line 3196
   * makes vectorisation easy */
#line 3196
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3196
    ni=Min(nelems-j,LOOPCNT);
#line 3196
    if (realign) {
#line 3196
      xp = tmp;
#line 3196
    } else {
#line 3196
      xp = (ushort *) *xpp;
#line 3196
    }
#line 3196
   /* copy the next block */
#line 3196
#pragma cdir loopcnt=LOOPCNT
#line 3196
#pragma cdir shortloop
#line 3196
    for (i=0; i<ni; i++) {
#line 3196
      /* the normal case: */
#line 3196
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3196
     /* test for range errors (not always needed but do it anyway) */
#line 3196
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3196
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3196
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3196
    }
#line 3196
   /* copy workspace back if necessary */
#line 3196
    if (realign) {
#line 3196
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3196
      xp = (ushort *) *xpp;
#line 3196
    }
#line 3196
   /* update xpp and tp */
#line 3196
    xp += ni;
#line 3196
    tp += ni;
#line 3196
    *xpp = (void*)xp;
#line 3196
  }
#line 3196
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3196

#line 3196
#else   /* not SX */
#line 3196

#line 3196
	char *xp = (char *) *xpp;
#line 3196
	int status = NC_NOERR;
#line 3196

#line 3196
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3196
	{
#line 3196
		int lstatus = ncx_put_ushort_short(xp, tp, fillp);
#line 3196
		if (status == NC_NOERR) /* report the first encountered error */
#line 3196
			status = lstatus;
#line 3196
	}
#line 3196

#line 3196
	*xpp = (void *)xp;
#line 3196
	return status;
#line 3196
#endif
#line 3196
}
#line 3196

int
#line 3197
ncx_putn_ushort_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3197
{
#line 3197
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3197

#line 3197
 /* basic algorithm is:
#line 3197
  *   - ensure sane alignment of output data
#line 3197
  *   - copy (conversion happens automatically) input data
#line 3197
  *     to output
#line 3197
  *   - update tp to point at next unconverted input, and xpp to point
#line 3197
  *     at next location for converted output
#line 3197
  */
#line 3197
  long i, j, ni;
#line 3197
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3197
  ushort *xp;
#line 3197
  int nrange = 0;         /* number of range errors */
#line 3197
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3197
  long cxp = (long) *((char**)xpp);
#line 3197

#line 3197
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3197
  /* sjl: manually stripmine so we can limit amount of
#line 3197
   * vector work space reserved to LOOPCNT elements. Also
#line 3197
   * makes vectorisation easy */
#line 3197
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3197
    ni=Min(nelems-j,LOOPCNT);
#line 3197
    if (realign) {
#line 3197
      xp = tmp;
#line 3197
    } else {
#line 3197
      xp = (ushort *) *xpp;
#line 3197
    }
#line 3197
   /* copy the next block */
#line 3197
#pragma cdir loopcnt=LOOPCNT
#line 3197
#pragma cdir shortloop
#line 3197
    for (i=0; i<ni; i++) {
#line 3197
      /* the normal case: */
#line 3197
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3197
     /* test for range errors (not always needed but do it anyway) */
#line 3197
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3197
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3197
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3197
    }
#line 3197
   /* copy workspace back if necessary */
#line 3197
    if (realign) {
#line 3197
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3197
      xp = (ushort *) *xpp;
#line 3197
    }
#line 3197
   /* update xpp and tp */
#line 3197
    xp += ni;
#line 3197
    tp += ni;
#line 3197
    *xpp = (void*)xp;
#line 3197
  }
#line 3197
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3197

#line 3197
#else   /* not SX */
#line 3197

#line 3197
	char *xp = (char *) *xpp;
#line 3197
	int status = NC_NOERR;
#line 3197

#line 3197
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3197
	{
#line 3197
		int lstatus = ncx_put_ushort_int(xp, tp, fillp);
#line 3197
		if (status == NC_NOERR) /* report the first encountered error */
#line 3197
			status = lstatus;
#line 3197
	}
#line 3197

#line 3197
	*xpp = (void *)xp;
#line 3197
	return status;
#line 3197
#endif
#line 3197
}
#line 3197

int
#line 3198
ncx_putn_ushort_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3198
{
#line 3198
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3198

#line 3198
 /* basic algorithm is:
#line 3198
  *   - ensure sane alignment of output data
#line 3198
  *   - copy (conversion happens automatically) input data
#line 3198
  *     to output
#line 3198
  *   - update tp to point at next unconverted input, and xpp to point
#line 3198
  *     at next location for converted output
#line 3198
  */
#line 3198
  long i, j, ni;
#line 3198
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3198
  ushort *xp;
#line 3198
  int nrange = 0;         /* number of range errors */
#line 3198
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3198
  long cxp = (long) *((char**)xpp);
#line 3198

#line 3198
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3198
  /* sjl: manually stripmine so we can limit amount of
#line 3198
   * vector work space reserved to LOOPCNT elements. Also
#line 3198
   * makes vectorisation easy */
#line 3198
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3198
    ni=Min(nelems-j,LOOPCNT);
#line 3198
    if (realign) {
#line 3198
      xp = tmp;
#line 3198
    } else {
#line 3198
      xp = (ushort *) *xpp;
#line 3198
    }
#line 3198
   /* copy the next block */
#line 3198
#pragma cdir loopcnt=LOOPCNT
#line 3198
#pragma cdir shortloop
#line 3198
    for (i=0; i<ni; i++) {
#line 3198
      /* the normal case: */
#line 3198
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3198
     /* test for range errors (not always needed but do it anyway) */
#line 3198
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3198
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3198
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3198
    }
#line 3198
   /* copy workspace back if necessary */
#line 3198
    if (realign) {
#line 3198
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3198
      xp = (ushort *) *xpp;
#line 3198
    }
#line 3198
   /* update xpp and tp */
#line 3198
    xp += ni;
#line 3198
    tp += ni;
#line 3198
    *xpp = (void*)xp;
#line 3198
  }
#line 3198
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3198

#line 3198
#else   /* not SX */
#line 3198

#line 3198
	char *xp = (char *) *xpp;
#line 3198
	int status = NC_NOERR;
#line 3198

#line 3198
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3198
	{
#line 3198
		int lstatus = ncx_put_ushort_long(xp, tp, fillp);
#line 3198
		if (status == NC_NOERR) /* report the first encountered error */
#line 3198
			status = lstatus;
#line 3198
	}
#line 3198

#line 3198
	*xpp = (void *)xp;
#line 3198
	return status;
#line 3198
#endif
#line 3198
}
#line 3198

int
#line 3199
ncx_putn_ushort_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3199
{
#line 3199
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3199

#line 3199
 /* basic algorithm is:
#line 3199
  *   - ensure sane alignment of output data
#line 3199
  *   - copy (conversion happens automatically) input data
#line 3199
  *     to output
#line 3199
  *   - update tp to point at next unconverted input, and xpp to point
#line 3199
  *     at next location for converted output
#line 3199
  */
#line 3199
  long i, j, ni;
#line 3199
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3199
  ushort *xp;
#line 3199
  int nrange = 0;         /* number of range errors */
#line 3199
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3199
  long cxp = (long) *((char**)xpp);
#line 3199

#line 3199
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3199
  /* sjl: manually stripmine so we can limit amount of
#line 3199
   * vector work space reserved to LOOPCNT elements. Also
#line 3199
   * makes vectorisation easy */
#line 3199
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3199
    ni=Min(nelems-j,LOOPCNT);
#line 3199
    if (realign) {
#line 3199
      xp = tmp;
#line 3199
    } else {
#line 3199
      xp = (ushort *) *xpp;
#line 3199
    }
#line 3199
   /* copy the next block */
#line 3199
#pragma cdir loopcnt=LOOPCNT
#line 3199
#pragma cdir shortloop
#line 3199
    for (i=0; i<ni; i++) {
#line 3199
      /* the normal case: */
#line 3199
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3199
     /* test for range errors (not always needed but do it anyway) */
#line 3199
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3199
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3199
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3199
    }
#line 3199
   /* copy workspace back if necessary */
#line 3199
    if (realign) {
#line 3199
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3199
      xp = (ushort *) *xpp;
#line 3199
    }
#line 3199
   /* update xpp and tp */
#line 3199
    xp += ni;
#line 3199
    tp += ni;
#line 3199
    *xpp = (void*)xp;
#line 3199
  }
#line 3199
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3199

#line 3199
#else   /* not SX */
#line 3199

#line 3199
	char *xp = (char *) *xpp;
#line 3199
	int status = NC_NOERR;
#line 3199

#line 3199
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3199
	{
#line 3199
		int lstatus = ncx_put_ushort_float(xp, tp, fillp);
#line 3199
		if (status == NC_NOERR) /* report the first encountered error */
#line 3199
			status = lstatus;
#line 3199
	}
#line 3199

#line 3199
	*xpp = (void *)xp;
#line 3199
	return status;
#line 3199
#endif
#line 3199
}
#line 3199

int
#line 3200
ncx_putn_ushort_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3200
{
#line 3200
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3200

#line 3200
 /* basic algorithm is:
#line 3200
  *   - ensure sane alignment of output data
#line 3200
  *   - copy (conversion happens automatically) input data
#line 3200
  *     to output
#line 3200
  *   - update tp to point at next unconverted input, and xpp to point
#line 3200
  *     at next location for converted output
#line 3200
  */
#line 3200
  long i, j, ni;
#line 3200
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3200
  ushort *xp;
#line 3200
  int nrange = 0;         /* number of range errors */
#line 3200
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3200
  long cxp = (long) *((char**)xpp);
#line 3200

#line 3200
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3200
  /* sjl: manually stripmine so we can limit amount of
#line 3200
   * vector work space reserved to LOOPCNT elements. Also
#line 3200
   * makes vectorisation easy */
#line 3200
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3200
    ni=Min(nelems-j,LOOPCNT);
#line 3200
    if (realign) {
#line 3200
      xp = tmp;
#line 3200
    } else {
#line 3200
      xp = (ushort *) *xpp;
#line 3200
    }
#line 3200
   /* copy the next block */
#line 3200
#pragma cdir loopcnt=LOOPCNT
#line 3200
#pragma cdir shortloop
#line 3200
    for (i=0; i<ni; i++) {
#line 3200
      /* the normal case: */
#line 3200
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3200
     /* test for range errors (not always needed but do it anyway) */
#line 3200
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3200
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3200
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3200
    }
#line 3200
   /* copy workspace back if necessary */
#line 3200
    if (realign) {
#line 3200
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3200
      xp = (ushort *) *xpp;
#line 3200
    }
#line 3200
   /* update xpp and tp */
#line 3200
    xp += ni;
#line 3200
    tp += ni;
#line 3200
    *xpp = (void*)xp;
#line 3200
  }
#line 3200
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3200

#line 3200
#else   /* not SX */
#line 3200

#line 3200
	char *xp = (char *) *xpp;
#line 3200
	int status = NC_NOERR;
#line 3200

#line 3200
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3200
	{
#line 3200
		int lstatus = ncx_put_ushort_double(xp, tp, fillp);
#line 3200
		if (status == NC_NOERR) /* report the first encountered error */
#line 3200
			status = lstatus;
#line 3200
	}
#line 3200

#line 3200
	*xpp = (void *)xp;
#line 3200
	return status;
#line 3200
#endif
#line 3200
}
#line 3200

int
#line 3201
ncx_putn_ushort_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3201
{
#line 3201
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3201

#line 3201
 /* basic algorithm is:
#line 3201
  *   - ensure sane alignment of output data
#line 3201
  *   - copy (conversion happens automatically) input data
#line 3201
  *     to output
#line 3201
  *   - update tp to point at next unconverted input, and xpp to point
#line 3201
  *     at next location for converted output
#line 3201
  */
#line 3201
  long i, j, ni;
#line 3201
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3201
  ushort *xp;
#line 3201
  int nrange = 0;         /* number of range errors */
#line 3201
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3201
  long cxp = (long) *((char**)xpp);
#line 3201

#line 3201
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3201
  /* sjl: manually stripmine so we can limit amount of
#line 3201
   * vector work space reserved to LOOPCNT elements. Also
#line 3201
   * makes vectorisation easy */
#line 3201
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3201
    ni=Min(nelems-j,LOOPCNT);
#line 3201
    if (realign) {
#line 3201
      xp = tmp;
#line 3201
    } else {
#line 3201
      xp = (ushort *) *xpp;
#line 3201
    }
#line 3201
   /* copy the next block */
#line 3201
#pragma cdir loopcnt=LOOPCNT
#line 3201
#pragma cdir shortloop
#line 3201
    for (i=0; i<ni; i++) {
#line 3201
      /* the normal case: */
#line 3201
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3201
     /* test for range errors (not always needed but do it anyway) */
#line 3201
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3201
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3201
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 3201
    }
#line 3201
   /* copy workspace back if necessary */
#line 3201
    if (realign) {
#line 3201
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3201
      xp = (ushort *) *xpp;
#line 3201
    }
#line 3201
   /* update xpp and tp */
#line 3201
    xp += ni;
#line 3201
    tp += ni;
#line 3201
    *xpp = (void*)xp;
#line 3201
  }
#line 3201
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3201

#line 3201
#else   /* not SX */
#line 3201

#line 3201
	char *xp = (char *) *xpp;
#line 3201
	int status = NC_NOERR;
#line 3201

#line 3201
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3201
	{
#line 3201
		int lstatus = ncx_put_ushort_longlong(xp, tp, fillp);
#line 3201
		if (status == NC_NOERR) /* report the first encountered error */
#line 3201
			status = lstatus;
#line 3201
	}
#line 3201

#line 3201
	*xpp = (void *)xp;
#line 3201
	return status;
#line 3201
#endif
#line 3201
}
#line 3201

int
#line 3202
ncx_putn_ushort_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3202
{
#line 3202
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3202

#line 3202
 /* basic algorithm is:
#line 3202
  *   - ensure sane alignment of output data
#line 3202
  *   - copy (conversion happens automatically) input data
#line 3202
  *     to output
#line 3202
  *   - update tp to point at next unconverted input, and xpp to point
#line 3202
  *     at next location for converted output
#line 3202
  */
#line 3202
  long i, j, ni;
#line 3202
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3202
  ushort *xp;
#line 3202
  int nrange = 0;         /* number of range errors */
#line 3202
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3202
  long cxp = (long) *((char**)xpp);
#line 3202

#line 3202
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3202
  /* sjl: manually stripmine so we can limit amount of
#line 3202
   * vector work space reserved to LOOPCNT elements. Also
#line 3202
   * makes vectorisation easy */
#line 3202
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3202
    ni=Min(nelems-j,LOOPCNT);
#line 3202
    if (realign) {
#line 3202
      xp = tmp;
#line 3202
    } else {
#line 3202
      xp = (ushort *) *xpp;
#line 3202
    }
#line 3202
   /* copy the next block */
#line 3202
#pragma cdir loopcnt=LOOPCNT
#line 3202
#pragma cdir shortloop
#line 3202
    for (i=0; i<ni; i++) {
#line 3202
      /* the normal case: */
#line 3202
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3202
     /* test for range errors (not always needed but do it anyway) */
#line 3202
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3202
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3202
      nrange += tp[i] > X_USHORT_MAX ;
#line 3202
    }
#line 3202
   /* copy workspace back if necessary */
#line 3202
    if (realign) {
#line 3202
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3202
      xp = (ushort *) *xpp;
#line 3202
    }
#line 3202
   /* update xpp and tp */
#line 3202
    xp += ni;
#line 3202
    tp += ni;
#line 3202
    *xpp = (void*)xp;
#line 3202
  }
#line 3202
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3202

#line 3202
#else   /* not SX */
#line 3202

#line 3202
	char *xp = (char *) *xpp;
#line 3202
	int status = NC_NOERR;
#line 3202

#line 3202
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3202
	{
#line 3202
		int lstatus = ncx_put_ushort_uchar(xp, tp, fillp);
#line 3202
		if (status == NC_NOERR) /* report the first encountered error */
#line 3202
			status = lstatus;
#line 3202
	}
#line 3202

#line 3202
	*xpp = (void *)xp;
#line 3202
	return status;
#line 3202
#endif
#line 3202
}
#line 3202

int
#line 3203
ncx_putn_ushort_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3203
{
#line 3203
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3203

#line 3203
 /* basic algorithm is:
#line 3203
  *   - ensure sane alignment of output data
#line 3203
  *   - copy (conversion happens automatically) input data
#line 3203
  *     to output
#line 3203
  *   - update tp to point at next unconverted input, and xpp to point
#line 3203
  *     at next location for converted output
#line 3203
  */
#line 3203
  long i, j, ni;
#line 3203
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3203
  ushort *xp;
#line 3203
  int nrange = 0;         /* number of range errors */
#line 3203
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3203
  long cxp = (long) *((char**)xpp);
#line 3203

#line 3203
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3203
  /* sjl: manually stripmine so we can limit amount of
#line 3203
   * vector work space reserved to LOOPCNT elements. Also
#line 3203
   * makes vectorisation easy */
#line 3203
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3203
    ni=Min(nelems-j,LOOPCNT);
#line 3203
    if (realign) {
#line 3203
      xp = tmp;
#line 3203
    } else {
#line 3203
      xp = (ushort *) *xpp;
#line 3203
    }
#line 3203
   /* copy the next block */
#line 3203
#pragma cdir loopcnt=LOOPCNT
#line 3203
#pragma cdir shortloop
#line 3203
    for (i=0; i<ni; i++) {
#line 3203
      /* the normal case: */
#line 3203
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3203
     /* test for range errors (not always needed but do it anyway) */
#line 3203
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3203
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3203
      nrange += tp[i] > X_USHORT_MAX ;
#line 3203
    }
#line 3203
   /* copy workspace back if necessary */
#line 3203
    if (realign) {
#line 3203
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3203
      xp = (ushort *) *xpp;
#line 3203
    }
#line 3203
   /* update xpp and tp */
#line 3203
    xp += ni;
#line 3203
    tp += ni;
#line 3203
    *xpp = (void*)xp;
#line 3203
  }
#line 3203
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3203

#line 3203
#else   /* not SX */
#line 3203

#line 3203
	char *xp = (char *) *xpp;
#line 3203
	int status = NC_NOERR;
#line 3203

#line 3203
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3203
	{
#line 3203
		int lstatus = ncx_put_ushort_uint(xp, tp, fillp);
#line 3203
		if (status == NC_NOERR) /* report the first encountered error */
#line 3203
			status = lstatus;
#line 3203
	}
#line 3203

#line 3203
	*xpp = (void *)xp;
#line 3203
	return status;
#line 3203
#endif
#line 3203
}
#line 3203

int
#line 3204
ncx_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3204
{
#line 3204
#if defined(_SX) && _SX != 0 && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 3204

#line 3204
 /* basic algorithm is:
#line 3204
  *   - ensure sane alignment of output data
#line 3204
  *   - copy (conversion happens automatically) input data
#line 3204
  *     to output
#line 3204
  *   - update tp to point at next unconverted input, and xpp to point
#line 3204
  *     at next location for converted output
#line 3204
  */
#line 3204
  long i, j, ni;
#line 3204
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 3204
  ushort *xp;
#line 3204
  int nrange = 0;         /* number of range errors */
#line 3204
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3204
  long cxp = (long) *((char**)xpp);
#line 3204

#line 3204
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 3204
  /* sjl: manually stripmine so we can limit amount of
#line 3204
   * vector work space reserved to LOOPCNT elements. Also
#line 3204
   * makes vectorisation easy */
#line 3204
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3204
    ni=Min(nelems-j,LOOPCNT);
#line 3204
    if (realign) {
#line 3204
      xp = tmp;
#line 3204
    } else {
#line 3204
      xp = (ushort *) *xpp;
#line 3204
    }
#line 3204
   /* copy the next block */
#line 3204
#pragma cdir loopcnt=LOOPCNT
#line 3204
#pragma cdir shortloop
#line 3204
    for (i=0; i<ni; i++) {
#line 3204
      /* the normal case: */
#line 3204
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 3204
     /* test for range errors (not always needed but do it anyway) */
#line 3204
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3204
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3204
      nrange += tp[i] > X_USHORT_MAX ;
#line 3204
    }
#line 3204
   /* copy workspace back if necessary */
#line 3204
    if (realign) {
#line 3204
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_USHORT);
#line 3204
      xp = (ushort *) *xpp;
#line 3204
    }
#line 3204
   /* update xpp and tp */
#line 3204
    xp += ni;
#line 3204
    tp += ni;
#line 3204
    *xpp = (void*)xp;
#line 3204
  }
#line 3204
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3204

#line 3204
#else   /* not SX */
#line 3204

#line 3204
	char *xp = (char *) *xpp;
#line 3204
	int status = NC_NOERR;
#line 3204

#line 3204
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3204
	{
#line 3204
		int lstatus = ncx_put_ushort_ulonglong(xp, tp, fillp);
#line 3204
		if (status == NC_NOERR) /* report the first encountered error */
#line 3204
			status = lstatus;
#line 3204
	}
#line 3204

#line 3204
	*xpp = (void *)xp;
#line 3204
	return status;
#line 3204
#endif
#line 3204
}
#line 3204


int
#line 3206
ncx_pad_putn_ushort_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3206
{
#line 3206
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3206

#line 3206
	char *xp = (char *) *xpp;
#line 3206
	int status = NC_NOERR;
#line 3206

#line 3206
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3206
	{
#line 3206
		int lstatus = ncx_put_ushort_schar(xp, tp, fillp);
#line 3206
		if (status == NC_NOERR) /* report the first encountered error */
#line 3206
			status = lstatus;
#line 3206
	}
#line 3206

#line 3206
	if (rndup != 0)
#line 3206
	{
#line 3206
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3206
		xp += X_SIZEOF_USHORT;
#line 3206
	}
#line 3206

#line 3206
	*xpp = (void *)xp;
#line 3206
	return status;
#line 3206
}
#line 3206

int
#line 3207
ncx_pad_putn_ushort_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3207
{
#line 3207
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3207

#line 3207
	char *xp = (char *) *xpp;
#line 3207
	int status = NC_NOERR;
#line 3207

#line 3207
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3207
	{
#line 3207
		int lstatus = ncx_put_ushort_uchar(xp, tp, fillp);
#line 3207
		if (status == NC_NOERR) /* report the first encountered error */
#line 3207
			status = lstatus;
#line 3207
	}
#line 3207

#line 3207
	if (rndup != 0)
#line 3207
	{
#line 3207
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3207
		xp += X_SIZEOF_USHORT;
#line 3207
	}
#line 3207

#line 3207
	*xpp = (void *)xp;
#line 3207
	return status;
#line 3207
}
#line 3207

int
#line 3208
ncx_pad_putn_ushort_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3208
{
#line 3208
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3208

#line 3208
	char *xp = (char *) *xpp;
#line 3208
	int status = NC_NOERR;
#line 3208

#line 3208
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3208
	{
#line 3208
		int lstatus = ncx_put_ushort_short(xp, tp, fillp);
#line 3208
		if (status == NC_NOERR) /* report the first encountered error */
#line 3208
			status = lstatus;
#line 3208
	}
#line 3208

#line 3208
	if (rndup != 0)
#line 3208
	{
#line 3208
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3208
		xp += X_SIZEOF_USHORT;
#line 3208
	}
#line 3208

#line 3208
	*xpp = (void *)xp;
#line 3208
	return status;
#line 3208
}
#line 3208

int
#line 3209
ncx_pad_putn_ushort_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3209
{
#line 3209
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3209

#line 3209
	char *xp = (char *) *xpp;
#line 3209
	int status = NC_NOERR;
#line 3209

#line 3209
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3209
	{
#line 3209
		int lstatus = ncx_put_ushort_int(xp, tp, fillp);
#line 3209
		if (status == NC_NOERR) /* report the first encountered error */
#line 3209
			status = lstatus;
#line 3209
	}
#line 3209

#line 3209
	if (rndup != 0)
#line 3209
	{
#line 3209
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3209
		xp += X_SIZEOF_USHORT;
#line 3209
	}
#line 3209

#line 3209
	*xpp = (void *)xp;
#line 3209
	return status;
#line 3209
}
#line 3209

int
#line 3210
ncx_pad_putn_ushort_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3210
{
#line 3210
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3210

#line 3210
	char *xp = (char *) *xpp;
#line 3210
	int status = NC_NOERR;
#line 3210

#line 3210
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3210
	{
#line 3210
		int lstatus = ncx_put_ushort_long(xp, tp, fillp);
#line 3210
		if (status == NC_NOERR) /* report the first encountered error */
#line 3210
			status = lstatus;
#line 3210
	}
#line 3210

#line 3210
	if (rndup != 0)
#line 3210
	{
#line 3210
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3210
		xp += X_SIZEOF_USHORT;
#line 3210
	}
#line 3210

#line 3210
	*xpp = (void *)xp;
#line 3210
	return status;
#line 3210
}
#line 3210

int
#line 3211
ncx_pad_putn_ushort_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3211
{
#line 3211
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3211

#line 3211
	char *xp = (char *) *xpp;
#line 3211
	int status = NC_NOERR;
#line 3211

#line 3211
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3211
	{
#line 3211
		int lstatus = ncx_put_ushort_float(xp, tp, fillp);
#line 3211
		if (status == NC_NOERR) /* report the first encountered error */
#line 3211
			status = lstatus;
#line 3211
	}
#line 3211

#line 3211
	if (rndup != 0)
#line 3211
	{
#line 3211
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3211
		xp += X_SIZEOF_USHORT;
#line 3211
	}
#line 3211

#line 3211
	*xpp = (void *)xp;
#line 3211
	return status;
#line 3211
}
#line 3211

int
#line 3212
ncx_pad_putn_ushort_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3212
{
#line 3212
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3212

#line 3212
	char *xp = (char *) *xpp;
#line 3212
	int status = NC_NOERR;
#line 3212

#line 3212
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3212
	{
#line 3212
		int lstatus = ncx_put_ushort_double(xp, tp, fillp);
#line 3212
		if (status == NC_NOERR) /* report the first encountered error */
#line 3212
			status = lstatus;
#line 3212
	}
#line 3212

#line 3212
	if (rndup != 0)
#line 3212
	{
#line 3212
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3212
		xp += X_SIZEOF_USHORT;
#line 3212
	}
#line 3212

#line 3212
	*xpp = (void *)xp;
#line 3212
	return status;
#line 3212
}
#line 3212

int
#line 3213
ncx_pad_putn_ushort_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3213
{
#line 3213
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3213

#line 3213
	char *xp = (char *) *xpp;
#line 3213
	int status = NC_NOERR;
#line 3213

#line 3213
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3213
	{
#line 3213
		int lstatus = ncx_put_ushort_uint(xp, tp, fillp);
#line 3213
		if (status == NC_NOERR) /* report the first encountered error */
#line 3213
			status = lstatus;
#line 3213
	}
#line 3213

#line 3213
	if (rndup != 0)
#line 3213
	{
#line 3213
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3213
		xp += X_SIZEOF_USHORT;
#line 3213
	}
#line 3213

#line 3213
	*xpp = (void *)xp;
#line 3213
	return status;
#line 3213
}
#line 3213

int
#line 3214
ncx_pad_putn_ushort_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3214
{
#line 3214
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3214

#line 3214
	char *xp = (char *) *xpp;
#line 3214
	int status = NC_NOERR;
#line 3214

#line 3214
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3214
	{
#line 3214
		int lstatus = ncx_put_ushort_longlong(xp, tp, fillp);
#line 3214
		if (status == NC_NOERR) /* report the first encountered error */
#line 3214
			status = lstatus;
#line 3214
	}
#line 3214

#line 3214
	if (rndup != 0)
#line 3214
	{
#line 3214
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3214
		xp += X_SIZEOF_USHORT;
#line 3214
	}
#line 3214

#line 3214
	*xpp = (void *)xp;
#line 3214
	return status;
#line 3214
}
#line 3214

int
#line 3215
ncx_pad_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3215
{
#line 3215
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3215

#line 3215
	char *xp = (char *) *xpp;
#line 3215
	int status = NC_NOERR;
#line 3215

#line 3215
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3215
	{
#line 3215
		int lstatus = ncx_put_ushort_ulonglong(xp, tp, fillp);
#line 3215
		if (status == NC_NOERR) /* report the first encountered error */
#line 3215
			status = lstatus;
#line 3215
	}
#line 3215

#line 3215
	if (rndup != 0)
#line 3215
	{
#line 3215
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3215
		xp += X_SIZEOF_USHORT;
#line 3215
	}
#line 3215

#line 3215
	*xpp = (void *)xp;
#line 3215
	return status;
#line 3215
}
#line 3215

int
#line 3216
ncx_pad_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3216
{
#line 3216
	const size_t rndup = nelems % X_SIZEOF_SHORT;
#line 3216

#line 3216
	char *xp = (char *) *xpp;
#line 3216
	int status = NC_NOERR;
#line 3216

#line 3216
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 3216
	{
#line 3216
		int lstatus = ncx_put_ushort_ushort(xp, tp, fillp);
#line 3216
		if (status == NC_NOERR) /* report the first encountered error */
#line 3216
			status = lstatus;
#line 3216
	}
#line 3216

#line 3216
	if (rndup != 0)
#line 3216
	{
#line 3216
		(void) memcpy(xp, nada, (size_t)(X_SIZEOF_USHORT));
#line 3216
		xp += X_SIZEOF_USHORT;
#line 3216
	}
#line 3216

#line 3216
	*xpp = (void *)xp;
#line 3216
	return status;
#line 3216
}
#line 3216



/* int -----------------------------------------------------------------------*/

#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_INT);
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_INT);
	return NC_NOERR;
}
#else
int
#line 3235
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
#line 3235
{
#line 3235
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3235

#line 3235
 /* basic algorithm is:
#line 3235
  *   - ensure sane alignment of input data
#line 3235
  *   - copy (conversion happens automatically) input data
#line 3235
  *     to output
#line 3235
  *   - update xpp to point at next unconverted input, and tp to point
#line 3235
  *     at next location for converted output
#line 3235
  */
#line 3235
  long i, j, ni;
#line 3235
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3235
  int *xp;
#line 3235
  int nrange = 0;         /* number of range errors */
#line 3235
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3235
  long cxp = (long) *((char**)xpp);
#line 3235

#line 3235
  realign = (cxp & 7) % SIZEOF_INT;
#line 3235
  /* sjl: manually stripmine so we can limit amount of
#line 3235
   * vector work space reserved to LOOPCNT elements. Also
#line 3235
   * makes vectorisation easy */
#line 3235
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3235
    ni=Min(nelems-j,LOOPCNT);
#line 3235
    if (realign) {
#line 3235
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3235
      xp = tmp;
#line 3235
    } else {
#line 3235
      xp = (int *) *xpp;
#line 3235
    }
#line 3235
   /* copy the next block */
#line 3235
#pragma cdir loopcnt=LOOPCNT
#line 3235
#pragma cdir shortloop
#line 3235
    for (i=0; i<ni; i++) {
#line 3235
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3235
     /* test for range errors (not always needed but do it anyway) */
#line 3235
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3235
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3235
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3235
    }
#line 3235
   /* update xpp and tp */
#line 3235
    if (realign) xp = (int *) *xpp;
#line 3235
    xp += ni;
#line 3235
    tp += ni;
#line 3235
    *xpp = (void*)xp;
#line 3235
  }
#line 3235
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3235

#line 3235
#else   /* not SX */
#line 3235
	const char *xp = (const char *) *xpp;
#line 3235
	int status = NC_NOERR;
#line 3235

#line 3235
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3235
	{
#line 3235
		const int lstatus = ncx_get_int_int(xp, tp);
#line 3235
		if (status == NC_NOERR) /* report the first encountered error */
#line 3235
			status = lstatus;
#line 3235
	}
#line 3235

#line 3235
	*xpp = (const void *)xp;
#line 3235
	return status;
#line 3235
#endif
#line 3235
}
#line 3235

#endif
int
#line 3237
ncx_getn_int_schar(const void **xpp, size_t nelems, schar *tp)
#line 3237
{
#line 3237
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3237

#line 3237
 /* basic algorithm is:
#line 3237
  *   - ensure sane alignment of input data
#line 3237
  *   - copy (conversion happens automatically) input data
#line 3237
  *     to output
#line 3237
  *   - update xpp to point at next unconverted input, and tp to point
#line 3237
  *     at next location for converted output
#line 3237
  */
#line 3237
  long i, j, ni;
#line 3237
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3237
  int *xp;
#line 3237
  int nrange = 0;         /* number of range errors */
#line 3237
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3237
  long cxp = (long) *((char**)xpp);
#line 3237

#line 3237
  realign = (cxp & 7) % SIZEOF_INT;
#line 3237
  /* sjl: manually stripmine so we can limit amount of
#line 3237
   * vector work space reserved to LOOPCNT elements. Also
#line 3237
   * makes vectorisation easy */
#line 3237
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3237
    ni=Min(nelems-j,LOOPCNT);
#line 3237
    if (realign) {
#line 3237
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3237
      xp = tmp;
#line 3237
    } else {
#line 3237
      xp = (int *) *xpp;
#line 3237
    }
#line 3237
   /* copy the next block */
#line 3237
#pragma cdir loopcnt=LOOPCNT
#line 3237
#pragma cdir shortloop
#line 3237
    for (i=0; i<ni; i++) {
#line 3237
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3237
     /* test for range errors (not always needed but do it anyway) */
#line 3237
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3237
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3237
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3237
    }
#line 3237
   /* update xpp and tp */
#line 3237
    if (realign) xp = (int *) *xpp;
#line 3237
    xp += ni;
#line 3237
    tp += ni;
#line 3237
    *xpp = (void*)xp;
#line 3237
  }
#line 3237
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3237

#line 3237
#else   /* not SX */
#line 3237
	const char *xp = (const char *) *xpp;
#line 3237
	int status = NC_NOERR;
#line 3237

#line 3237
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3237
	{
#line 3237
		const int lstatus = ncx_get_int_schar(xp, tp);
#line 3237
		if (status == NC_NOERR) /* report the first encountered error */
#line 3237
			status = lstatus;
#line 3237
	}
#line 3237

#line 3237
	*xpp = (const void *)xp;
#line 3237
	return status;
#line 3237
#endif
#line 3237
}
#line 3237

int
#line 3238
ncx_getn_int_short(const void **xpp, size_t nelems, short *tp)
#line 3238
{
#line 3238
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3238

#line 3238
 /* basic algorithm is:
#line 3238
  *   - ensure sane alignment of input data
#line 3238
  *   - copy (conversion happens automatically) input data
#line 3238
  *     to output
#line 3238
  *   - update xpp to point at next unconverted input, and tp to point
#line 3238
  *     at next location for converted output
#line 3238
  */
#line 3238
  long i, j, ni;
#line 3238
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3238
  int *xp;
#line 3238
  int nrange = 0;         /* number of range errors */
#line 3238
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3238
  long cxp = (long) *((char**)xpp);
#line 3238

#line 3238
  realign = (cxp & 7) % SIZEOF_INT;
#line 3238
  /* sjl: manually stripmine so we can limit amount of
#line 3238
   * vector work space reserved to LOOPCNT elements. Also
#line 3238
   * makes vectorisation easy */
#line 3238
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3238
    ni=Min(nelems-j,LOOPCNT);
#line 3238
    if (realign) {
#line 3238
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3238
      xp = tmp;
#line 3238
    } else {
#line 3238
      xp = (int *) *xpp;
#line 3238
    }
#line 3238
   /* copy the next block */
#line 3238
#pragma cdir loopcnt=LOOPCNT
#line 3238
#pragma cdir shortloop
#line 3238
    for (i=0; i<ni; i++) {
#line 3238
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3238
     /* test for range errors (not always needed but do it anyway) */
#line 3238
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3238
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3238
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3238
    }
#line 3238
   /* update xpp and tp */
#line 3238
    if (realign) xp = (int *) *xpp;
#line 3238
    xp += ni;
#line 3238
    tp += ni;
#line 3238
    *xpp = (void*)xp;
#line 3238
  }
#line 3238
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3238

#line 3238
#else   /* not SX */
#line 3238
	const char *xp = (const char *) *xpp;
#line 3238
	int status = NC_NOERR;
#line 3238

#line 3238
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3238
	{
#line 3238
		const int lstatus = ncx_get_int_short(xp, tp);
#line 3238
		if (status == NC_NOERR) /* report the first encountered error */
#line 3238
			status = lstatus;
#line 3238
	}
#line 3238

#line 3238
	*xpp = (const void *)xp;
#line 3238
	return status;
#line 3238
#endif
#line 3238
}
#line 3238

int
#line 3239
ncx_getn_int_long(const void **xpp, size_t nelems, long *tp)
#line 3239
{
#line 3239
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3239

#line 3239
 /* basic algorithm is:
#line 3239
  *   - ensure sane alignment of input data
#line 3239
  *   - copy (conversion happens automatically) input data
#line 3239
  *     to output
#line 3239
  *   - update xpp to point at next unconverted input, and tp to point
#line 3239
  *     at next location for converted output
#line 3239
  */
#line 3239
  long i, j, ni;
#line 3239
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3239
  int *xp;
#line 3239
  int nrange = 0;         /* number of range errors */
#line 3239
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3239
  long cxp = (long) *((char**)xpp);
#line 3239

#line 3239
  realign = (cxp & 7) % SIZEOF_INT;
#line 3239
  /* sjl: manually stripmine so we can limit amount of
#line 3239
   * vector work space reserved to LOOPCNT elements. Also
#line 3239
   * makes vectorisation easy */
#line 3239
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3239
    ni=Min(nelems-j,LOOPCNT);
#line 3239
    if (realign) {
#line 3239
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3239
      xp = tmp;
#line 3239
    } else {
#line 3239
      xp = (int *) *xpp;
#line 3239
    }
#line 3239
   /* copy the next block */
#line 3239
#pragma cdir loopcnt=LOOPCNT
#line 3239
#pragma cdir shortloop
#line 3239
    for (i=0; i<ni; i++) {
#line 3239
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3239
     /* test for range errors (not always needed but do it anyway) */
#line 3239
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3239
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3239
      nrange += xp[i] > LONG_MAX || xp[i] < LONG_MIN;
#line 3239
    }
#line 3239
   /* update xpp and tp */
#line 3239
    if (realign) xp = (int *) *xpp;
#line 3239
    xp += ni;
#line 3239
    tp += ni;
#line 3239
    *xpp = (void*)xp;
#line 3239
  }
#line 3239
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3239

#line 3239
#else   /* not SX */
#line 3239
	const char *xp = (const char *) *xpp;
#line 3239
	int status = NC_NOERR;
#line 3239

#line 3239
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3239
	{
#line 3239
		const int lstatus = ncx_get_int_long(xp, tp);
#line 3239
		if (status == NC_NOERR) /* report the first encountered error */
#line 3239
			status = lstatus;
#line 3239
	}
#line 3239

#line 3239
	*xpp = (const void *)xp;
#line 3239
	return status;
#line 3239
#endif
#line 3239
}
#line 3239

int
#line 3240
ncx_getn_int_float(const void **xpp, size_t nelems, float *tp)
#line 3240
{
#line 3240
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3240

#line 3240
 /* basic algorithm is:
#line 3240
  *   - ensure sane alignment of input data
#line 3240
  *   - copy (conversion happens automatically) input data
#line 3240
  *     to output
#line 3240
  *   - update xpp to point at next unconverted input, and tp to point
#line 3240
  *     at next location for converted output
#line 3240
  */
#line 3240
  long i, j, ni;
#line 3240
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3240
  int *xp;
#line 3240
  int nrange = 0;         /* number of range errors */
#line 3240
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3240
  long cxp = (long) *((char**)xpp);
#line 3240

#line 3240
  realign = (cxp & 7) % SIZEOF_INT;
#line 3240
  /* sjl: manually stripmine so we can limit amount of
#line 3240
   * vector work space reserved to LOOPCNT elements. Also
#line 3240
   * makes vectorisation easy */
#line 3240
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3240
    ni=Min(nelems-j,LOOPCNT);
#line 3240
    if (realign) {
#line 3240
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3240
      xp = tmp;
#line 3240
    } else {
#line 3240
      xp = (int *) *xpp;
#line 3240
    }
#line 3240
   /* copy the next block */
#line 3240
#pragma cdir loopcnt=LOOPCNT
#line 3240
#pragma cdir shortloop
#line 3240
    for (i=0; i<ni; i++) {
#line 3240
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3240
     /* test for range errors (not always needed but do it anyway) */
#line 3240
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3240
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3240
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3240
    }
#line 3240
   /* update xpp and tp */
#line 3240
    if (realign) xp = (int *) *xpp;
#line 3240
    xp += ni;
#line 3240
    tp += ni;
#line 3240
    *xpp = (void*)xp;
#line 3240
  }
#line 3240
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3240

#line 3240
#else   /* not SX */
#line 3240
	const char *xp = (const char *) *xpp;
#line 3240
	int status = NC_NOERR;
#line 3240

#line 3240
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3240
	{
#line 3240
		const int lstatus = ncx_get_int_float(xp, tp);
#line 3240
		if (status == NC_NOERR) /* report the first encountered error */
#line 3240
			status = lstatus;
#line 3240
	}
#line 3240

#line 3240
	*xpp = (const void *)xp;
#line 3240
	return status;
#line 3240
#endif
#line 3240
}
#line 3240

int
#line 3241
ncx_getn_int_double(const void **xpp, size_t nelems, double *tp)
#line 3241
{
#line 3241
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3241

#line 3241
 /* basic algorithm is:
#line 3241
  *   - ensure sane alignment of input data
#line 3241
  *   - copy (conversion happens automatically) input data
#line 3241
  *     to output
#line 3241
  *   - update xpp to point at next unconverted input, and tp to point
#line 3241
  *     at next location for converted output
#line 3241
  */
#line 3241
  long i, j, ni;
#line 3241
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3241
  int *xp;
#line 3241
  int nrange = 0;         /* number of range errors */
#line 3241
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3241
  long cxp = (long) *((char**)xpp);
#line 3241

#line 3241
  realign = (cxp & 7) % SIZEOF_INT;
#line 3241
  /* sjl: manually stripmine so we can limit amount of
#line 3241
   * vector work space reserved to LOOPCNT elements. Also
#line 3241
   * makes vectorisation easy */
#line 3241
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3241
    ni=Min(nelems-j,LOOPCNT);
#line 3241
    if (realign) {
#line 3241
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3241
      xp = tmp;
#line 3241
    } else {
#line 3241
      xp = (int *) *xpp;
#line 3241
    }
#line 3241
   /* copy the next block */
#line 3241
#pragma cdir loopcnt=LOOPCNT
#line 3241
#pragma cdir shortloop
#line 3241
    for (i=0; i<ni; i++) {
#line 3241
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3241
     /* test for range errors (not always needed but do it anyway) */
#line 3241
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3241
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3241
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3241
    }
#line 3241
   /* update xpp and tp */
#line 3241
    if (realign) xp = (int *) *xpp;
#line 3241
    xp += ni;
#line 3241
    tp += ni;
#line 3241
    *xpp = (void*)xp;
#line 3241
  }
#line 3241
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3241

#line 3241
#else   /* not SX */
#line 3241
	const char *xp = (const char *) *xpp;
#line 3241
	int status = NC_NOERR;
#line 3241

#line 3241
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3241
	{
#line 3241
		const int lstatus = ncx_get_int_double(xp, tp);
#line 3241
		if (status == NC_NOERR) /* report the first encountered error */
#line 3241
			status = lstatus;
#line 3241
	}
#line 3241

#line 3241
	*xpp = (const void *)xp;
#line 3241
	return status;
#line 3241
#endif
#line 3241
}
#line 3241

int
#line 3242
ncx_getn_int_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3242
{
#line 3242
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3242

#line 3242
 /* basic algorithm is:
#line 3242
  *   - ensure sane alignment of input data
#line 3242
  *   - copy (conversion happens automatically) input data
#line 3242
  *     to output
#line 3242
  *   - update xpp to point at next unconverted input, and tp to point
#line 3242
  *     at next location for converted output
#line 3242
  */
#line 3242
  long i, j, ni;
#line 3242
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3242
  int *xp;
#line 3242
  int nrange = 0;         /* number of range errors */
#line 3242
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3242
  long cxp = (long) *((char**)xpp);
#line 3242

#line 3242
  realign = (cxp & 7) % SIZEOF_INT;
#line 3242
  /* sjl: manually stripmine so we can limit amount of
#line 3242
   * vector work space reserved to LOOPCNT elements. Also
#line 3242
   * makes vectorisation easy */
#line 3242
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3242
    ni=Min(nelems-j,LOOPCNT);
#line 3242
    if (realign) {
#line 3242
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3242
      xp = tmp;
#line 3242
    } else {
#line 3242
      xp = (int *) *xpp;
#line 3242
    }
#line 3242
   /* copy the next block */
#line 3242
#pragma cdir loopcnt=LOOPCNT
#line 3242
#pragma cdir shortloop
#line 3242
    for (i=0; i<ni; i++) {
#line 3242
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3242
     /* test for range errors (not always needed but do it anyway) */
#line 3242
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3242
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3242
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3242
    }
#line 3242
   /* update xpp and tp */
#line 3242
    if (realign) xp = (int *) *xpp;
#line 3242
    xp += ni;
#line 3242
    tp += ni;
#line 3242
    *xpp = (void*)xp;
#line 3242
  }
#line 3242
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3242

#line 3242
#else   /* not SX */
#line 3242
	const char *xp = (const char *) *xpp;
#line 3242
	int status = NC_NOERR;
#line 3242

#line 3242
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3242
	{
#line 3242
		const int lstatus = ncx_get_int_longlong(xp, tp);
#line 3242
		if (status == NC_NOERR) /* report the first encountered error */
#line 3242
			status = lstatus;
#line 3242
	}
#line 3242

#line 3242
	*xpp = (const void *)xp;
#line 3242
	return status;
#line 3242
#endif
#line 3242
}
#line 3242

int
#line 3243
ncx_getn_int_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3243
{
#line 3243
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3243

#line 3243
 /* basic algorithm is:
#line 3243
  *   - ensure sane alignment of input data
#line 3243
  *   - copy (conversion happens automatically) input data
#line 3243
  *     to output
#line 3243
  *   - update xpp to point at next unconverted input, and tp to point
#line 3243
  *     at next location for converted output
#line 3243
  */
#line 3243
  long i, j, ni;
#line 3243
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3243
  int *xp;
#line 3243
  int nrange = 0;         /* number of range errors */
#line 3243
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3243
  long cxp = (long) *((char**)xpp);
#line 3243

#line 3243
  realign = (cxp & 7) % SIZEOF_INT;
#line 3243
  /* sjl: manually stripmine so we can limit amount of
#line 3243
   * vector work space reserved to LOOPCNT elements. Also
#line 3243
   * makes vectorisation easy */
#line 3243
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3243
    ni=Min(nelems-j,LOOPCNT);
#line 3243
    if (realign) {
#line 3243
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3243
      xp = tmp;
#line 3243
    } else {
#line 3243
      xp = (int *) *xpp;
#line 3243
    }
#line 3243
   /* copy the next block */
#line 3243
#pragma cdir loopcnt=LOOPCNT
#line 3243
#pragma cdir shortloop
#line 3243
    for (i=0; i<ni; i++) {
#line 3243
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3243
     /* test for range errors (not always needed but do it anyway) */
#line 3243
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3243
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3243
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3243
    }
#line 3243
   /* update xpp and tp */
#line 3243
    if (realign) xp = (int *) *xpp;
#line 3243
    xp += ni;
#line 3243
    tp += ni;
#line 3243
    *xpp = (void*)xp;
#line 3243
  }
#line 3243
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3243

#line 3243
#else   /* not SX */
#line 3243
	const char *xp = (const char *) *xpp;
#line 3243
	int status = NC_NOERR;
#line 3243

#line 3243
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3243
	{
#line 3243
		const int lstatus = ncx_get_int_uchar(xp, tp);
#line 3243
		if (status == NC_NOERR) /* report the first encountered error */
#line 3243
			status = lstatus;
#line 3243
	}
#line 3243

#line 3243
	*xpp = (const void *)xp;
#line 3243
	return status;
#line 3243
#endif
#line 3243
}
#line 3243

int
#line 3244
ncx_getn_int_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3244
{
#line 3244
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3244

#line 3244
 /* basic algorithm is:
#line 3244
  *   - ensure sane alignment of input data
#line 3244
  *   - copy (conversion happens automatically) input data
#line 3244
  *     to output
#line 3244
  *   - update xpp to point at next unconverted input, and tp to point
#line 3244
  *     at next location for converted output
#line 3244
  */
#line 3244
  long i, j, ni;
#line 3244
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3244
  int *xp;
#line 3244
  int nrange = 0;         /* number of range errors */
#line 3244
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3244
  long cxp = (long) *((char**)xpp);
#line 3244

#line 3244
  realign = (cxp & 7) % SIZEOF_INT;
#line 3244
  /* sjl: manually stripmine so we can limit amount of
#line 3244
   * vector work space reserved to LOOPCNT elements. Also
#line 3244
   * makes vectorisation easy */
#line 3244
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3244
    ni=Min(nelems-j,LOOPCNT);
#line 3244
    if (realign) {
#line 3244
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3244
      xp = tmp;
#line 3244
    } else {
#line 3244
      xp = (int *) *xpp;
#line 3244
    }
#line 3244
   /* copy the next block */
#line 3244
#pragma cdir loopcnt=LOOPCNT
#line 3244
#pragma cdir shortloop
#line 3244
    for (i=0; i<ni; i++) {
#line 3244
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3244
     /* test for range errors (not always needed but do it anyway) */
#line 3244
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3244
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3244
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3244
    }
#line 3244
   /* update xpp and tp */
#line 3244
    if (realign) xp = (int *) *xpp;
#line 3244
    xp += ni;
#line 3244
    tp += ni;
#line 3244
    *xpp = (void*)xp;
#line 3244
  }
#line 3244
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3244

#line 3244
#else   /* not SX */
#line 3244
	const char *xp = (const char *) *xpp;
#line 3244
	int status = NC_NOERR;
#line 3244

#line 3244
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3244
	{
#line 3244
		const int lstatus = ncx_get_int_ushort(xp, tp);
#line 3244
		if (status == NC_NOERR) /* report the first encountered error */
#line 3244
			status = lstatus;
#line 3244
	}
#line 3244

#line 3244
	*xpp = (const void *)xp;
#line 3244
	return status;
#line 3244
#endif
#line 3244
}
#line 3244

int
#line 3245
ncx_getn_int_uint(const void **xpp, size_t nelems, uint *tp)
#line 3245
{
#line 3245
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3245

#line 3245
 /* basic algorithm is:
#line 3245
  *   - ensure sane alignment of input data
#line 3245
  *   - copy (conversion happens automatically) input data
#line 3245
  *     to output
#line 3245
  *   - update xpp to point at next unconverted input, and tp to point
#line 3245
  *     at next location for converted output
#line 3245
  */
#line 3245
  long i, j, ni;
#line 3245
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3245
  int *xp;
#line 3245
  int nrange = 0;         /* number of range errors */
#line 3245
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3245
  long cxp = (long) *((char**)xpp);
#line 3245

#line 3245
  realign = (cxp & 7) % SIZEOF_INT;
#line 3245
  /* sjl: manually stripmine so we can limit amount of
#line 3245
   * vector work space reserved to LOOPCNT elements. Also
#line 3245
   * makes vectorisation easy */
#line 3245
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3245
    ni=Min(nelems-j,LOOPCNT);
#line 3245
    if (realign) {
#line 3245
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3245
      xp = tmp;
#line 3245
    } else {
#line 3245
      xp = (int *) *xpp;
#line 3245
    }
#line 3245
   /* copy the next block */
#line 3245
#pragma cdir loopcnt=LOOPCNT
#line 3245
#pragma cdir shortloop
#line 3245
    for (i=0; i<ni; i++) {
#line 3245
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3245
     /* test for range errors (not always needed but do it anyway) */
#line 3245
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3245
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3245
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3245
    }
#line 3245
   /* update xpp and tp */
#line 3245
    if (realign) xp = (int *) *xpp;
#line 3245
    xp += ni;
#line 3245
    tp += ni;
#line 3245
    *xpp = (void*)xp;
#line 3245
  }
#line 3245
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3245

#line 3245
#else   /* not SX */
#line 3245
	const char *xp = (const char *) *xpp;
#line 3245
	int status = NC_NOERR;
#line 3245

#line 3245
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3245
	{
#line 3245
		const int lstatus = ncx_get_int_uint(xp, tp);
#line 3245
		if (status == NC_NOERR) /* report the first encountered error */
#line 3245
			status = lstatus;
#line 3245
	}
#line 3245

#line 3245
	*xpp = (const void *)xp;
#line 3245
	return status;
#line 3245
#endif
#line 3245
}
#line 3245

int
#line 3246
ncx_getn_int_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3246
{
#line 3246
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3246

#line 3246
 /* basic algorithm is:
#line 3246
  *   - ensure sane alignment of input data
#line 3246
  *   - copy (conversion happens automatically) input data
#line 3246
  *     to output
#line 3246
  *   - update xpp to point at next unconverted input, and tp to point
#line 3246
  *     at next location for converted output
#line 3246
  */
#line 3246
  long i, j, ni;
#line 3246
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3246
  int *xp;
#line 3246
  int nrange = 0;         /* number of range errors */
#line 3246
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3246
  long cxp = (long) *((char**)xpp);
#line 3246

#line 3246
  realign = (cxp & 7) % SIZEOF_INT;
#line 3246
  /* sjl: manually stripmine so we can limit amount of
#line 3246
   * vector work space reserved to LOOPCNT elements. Also
#line 3246
   * makes vectorisation easy */
#line 3246
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3246
    ni=Min(nelems-j,LOOPCNT);
#line 3246
    if (realign) {
#line 3246
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT));
#line 3246
      xp = tmp;
#line 3246
    } else {
#line 3246
      xp = (int *) *xpp;
#line 3246
    }
#line 3246
   /* copy the next block */
#line 3246
#pragma cdir loopcnt=LOOPCNT
#line 3246
#pragma cdir shortloop
#line 3246
    for (i=0; i<ni; i++) {
#line 3246
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3246
     /* test for range errors (not always needed but do it anyway) */
#line 3246
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3246
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3246
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3246
    }
#line 3246
   /* update xpp and tp */
#line 3246
    if (realign) xp = (int *) *xpp;
#line 3246
    xp += ni;
#line 3246
    tp += ni;
#line 3246
    *xpp = (void*)xp;
#line 3246
  }
#line 3246
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3246

#line 3246
#else   /* not SX */
#line 3246
	const char *xp = (const char *) *xpp;
#line 3246
	int status = NC_NOERR;
#line 3246

#line 3246
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3246
	{
#line 3246
		const int lstatus = ncx_get_int_ulonglong(xp, tp);
#line 3246
		if (status == NC_NOERR) /* report the first encountered error */
#line 3246
			status = lstatus;
#line 3246
	}
#line 3246

#line 3246
	*xpp = (const void *)xp;
#line 3246
	return status;
#line 3246
#endif
#line 3246
}
#line 3246


#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_INT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT);
	return NC_NOERR;
}
#else
int
#line 3262
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3262
{
#line 3262
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3262

#line 3262
 /* basic algorithm is:
#line 3262
  *   - ensure sane alignment of output data
#line 3262
  *   - copy (conversion happens automatically) input data
#line 3262
  *     to output
#line 3262
  *   - update tp to point at next unconverted input, and xpp to point
#line 3262
  *     at next location for converted output
#line 3262
  */
#line 3262
  long i, j, ni;
#line 3262
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3262
  int *xp;
#line 3262
  int nrange = 0;         /* number of range errors */
#line 3262
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3262
  long cxp = (long) *((char**)xpp);
#line 3262

#line 3262
  realign = (cxp & 7) % SIZEOF_INT;
#line 3262
  /* sjl: manually stripmine so we can limit amount of
#line 3262
   * vector work space reserved to LOOPCNT elements. Also
#line 3262
   * makes vectorisation easy */
#line 3262
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3262
    ni=Min(nelems-j,LOOPCNT);
#line 3262
    if (realign) {
#line 3262
      xp = tmp;
#line 3262
    } else {
#line 3262
      xp = (int *) *xpp;
#line 3262
    }
#line 3262
   /* copy the next block */
#line 3262
#pragma cdir loopcnt=LOOPCNT
#line 3262
#pragma cdir shortloop
#line 3262
    for (i=0; i<ni; i++) {
#line 3262
      /* the normal case: */
#line 3262
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3262
     /* test for range errors (not always needed but do it anyway) */
#line 3262
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3262
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3262
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3262
    }
#line 3262
   /* copy workspace back if necessary */
#line 3262
    if (realign) {
#line 3262
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3262
      xp = (int *) *xpp;
#line 3262
    }
#line 3262
   /* update xpp and tp */
#line 3262
    xp += ni;
#line 3262
    tp += ni;
#line 3262
    *xpp = (void*)xp;
#line 3262
  }
#line 3262
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3262

#line 3262
#else   /* not SX */
#line 3262

#line 3262
	char *xp = (char *) *xpp;
#line 3262
	int status = NC_NOERR;
#line 3262

#line 3262
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3262
	{
#line 3262
		int lstatus = ncx_put_int_int(xp, tp, fillp);
#line 3262
		if (status == NC_NOERR) /* report the first encountered error */
#line 3262
			status = lstatus;
#line 3262
	}
#line 3262

#line 3262
	*xpp = (void *)xp;
#line 3262
	return status;
#line 3262
#endif
#line 3262
}
#line 3262

#endif
int
#line 3264
ncx_putn_int_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3264
{
#line 3264
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3264

#line 3264
 /* basic algorithm is:
#line 3264
  *   - ensure sane alignment of output data
#line 3264
  *   - copy (conversion happens automatically) input data
#line 3264
  *     to output
#line 3264
  *   - update tp to point at next unconverted input, and xpp to point
#line 3264
  *     at next location for converted output
#line 3264
  */
#line 3264
  long i, j, ni;
#line 3264
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3264
  int *xp;
#line 3264
  int nrange = 0;         /* number of range errors */
#line 3264
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3264
  long cxp = (long) *((char**)xpp);
#line 3264

#line 3264
  realign = (cxp & 7) % SIZEOF_INT;
#line 3264
  /* sjl: manually stripmine so we can limit amount of
#line 3264
   * vector work space reserved to LOOPCNT elements. Also
#line 3264
   * makes vectorisation easy */
#line 3264
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3264
    ni=Min(nelems-j,LOOPCNT);
#line 3264
    if (realign) {
#line 3264
      xp = tmp;
#line 3264
    } else {
#line 3264
      xp = (int *) *xpp;
#line 3264
    }
#line 3264
   /* copy the next block */
#line 3264
#pragma cdir loopcnt=LOOPCNT
#line 3264
#pragma cdir shortloop
#line 3264
    for (i=0; i<ni; i++) {
#line 3264
      /* the normal case: */
#line 3264
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3264
     /* test for range errors (not always needed but do it anyway) */
#line 3264
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3264
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3264
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3264
    }
#line 3264
   /* copy workspace back if necessary */
#line 3264
    if (realign) {
#line 3264
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3264
      xp = (int *) *xpp;
#line 3264
    }
#line 3264
   /* update xpp and tp */
#line 3264
    xp += ni;
#line 3264
    tp += ni;
#line 3264
    *xpp = (void*)xp;
#line 3264
  }
#line 3264
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3264

#line 3264
#else   /* not SX */
#line 3264

#line 3264
	char *xp = (char *) *xpp;
#line 3264
	int status = NC_NOERR;
#line 3264

#line 3264
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3264
	{
#line 3264
		int lstatus = ncx_put_int_schar(xp, tp, fillp);
#line 3264
		if (status == NC_NOERR) /* report the first encountered error */
#line 3264
			status = lstatus;
#line 3264
	}
#line 3264

#line 3264
	*xpp = (void *)xp;
#line 3264
	return status;
#line 3264
#endif
#line 3264
}
#line 3264

int
#line 3265
ncx_putn_int_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3265
{
#line 3265
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3265

#line 3265
 /* basic algorithm is:
#line 3265
  *   - ensure sane alignment of output data
#line 3265
  *   - copy (conversion happens automatically) input data
#line 3265
  *     to output
#line 3265
  *   - update tp to point at next unconverted input, and xpp to point
#line 3265
  *     at next location for converted output
#line 3265
  */
#line 3265
  long i, j, ni;
#line 3265
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3265
  int *xp;
#line 3265
  int nrange = 0;         /* number of range errors */
#line 3265
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3265
  long cxp = (long) *((char**)xpp);
#line 3265

#line 3265
  realign = (cxp & 7) % SIZEOF_INT;
#line 3265
  /* sjl: manually stripmine so we can limit amount of
#line 3265
   * vector work space reserved to LOOPCNT elements. Also
#line 3265
   * makes vectorisation easy */
#line 3265
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3265
    ni=Min(nelems-j,LOOPCNT);
#line 3265
    if (realign) {
#line 3265
      xp = tmp;
#line 3265
    } else {
#line 3265
      xp = (int *) *xpp;
#line 3265
    }
#line 3265
   /* copy the next block */
#line 3265
#pragma cdir loopcnt=LOOPCNT
#line 3265
#pragma cdir shortloop
#line 3265
    for (i=0; i<ni; i++) {
#line 3265
      /* the normal case: */
#line 3265
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3265
     /* test for range errors (not always needed but do it anyway) */
#line 3265
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3265
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3265
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3265
    }
#line 3265
   /* copy workspace back if necessary */
#line 3265
    if (realign) {
#line 3265
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3265
      xp = (int *) *xpp;
#line 3265
    }
#line 3265
   /* update xpp and tp */
#line 3265
    xp += ni;
#line 3265
    tp += ni;
#line 3265
    *xpp = (void*)xp;
#line 3265
  }
#line 3265
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3265

#line 3265
#else   /* not SX */
#line 3265

#line 3265
	char *xp = (char *) *xpp;
#line 3265
	int status = NC_NOERR;
#line 3265

#line 3265
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3265
	{
#line 3265
		int lstatus = ncx_put_int_short(xp, tp, fillp);
#line 3265
		if (status == NC_NOERR) /* report the first encountered error */
#line 3265
			status = lstatus;
#line 3265
	}
#line 3265

#line 3265
	*xpp = (void *)xp;
#line 3265
	return status;
#line 3265
#endif
#line 3265
}
#line 3265

int
#line 3266
ncx_putn_int_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3266
{
#line 3266
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3266

#line 3266
 /* basic algorithm is:
#line 3266
  *   - ensure sane alignment of output data
#line 3266
  *   - copy (conversion happens automatically) input data
#line 3266
  *     to output
#line 3266
  *   - update tp to point at next unconverted input, and xpp to point
#line 3266
  *     at next location for converted output
#line 3266
  */
#line 3266
  long i, j, ni;
#line 3266
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3266
  int *xp;
#line 3266
  int nrange = 0;         /* number of range errors */
#line 3266
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3266
  long cxp = (long) *((char**)xpp);
#line 3266

#line 3266
  realign = (cxp & 7) % SIZEOF_INT;
#line 3266
  /* sjl: manually stripmine so we can limit amount of
#line 3266
   * vector work space reserved to LOOPCNT elements. Also
#line 3266
   * makes vectorisation easy */
#line 3266
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3266
    ni=Min(nelems-j,LOOPCNT);
#line 3266
    if (realign) {
#line 3266
      xp = tmp;
#line 3266
    } else {
#line 3266
      xp = (int *) *xpp;
#line 3266
    }
#line 3266
   /* copy the next block */
#line 3266
#pragma cdir loopcnt=LOOPCNT
#line 3266
#pragma cdir shortloop
#line 3266
    for (i=0; i<ni; i++) {
#line 3266
      /* the normal case: */
#line 3266
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3266
     /* test for range errors (not always needed but do it anyway) */
#line 3266
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3266
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3266
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3266
    }
#line 3266
   /* copy workspace back if necessary */
#line 3266
    if (realign) {
#line 3266
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3266
      xp = (int *) *xpp;
#line 3266
    }
#line 3266
   /* update xpp and tp */
#line 3266
    xp += ni;
#line 3266
    tp += ni;
#line 3266
    *xpp = (void*)xp;
#line 3266
  }
#line 3266
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3266

#line 3266
#else   /* not SX */
#line 3266

#line 3266
	char *xp = (char *) *xpp;
#line 3266
	int status = NC_NOERR;
#line 3266

#line 3266
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3266
	{
#line 3266
		int lstatus = ncx_put_int_long(xp, tp, fillp);
#line 3266
		if (status == NC_NOERR) /* report the first encountered error */
#line 3266
			status = lstatus;
#line 3266
	}
#line 3266

#line 3266
	*xpp = (void *)xp;
#line 3266
	return status;
#line 3266
#endif
#line 3266
}
#line 3266

int
#line 3267
ncx_putn_int_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3267
{
#line 3267
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3267

#line 3267
 /* basic algorithm is:
#line 3267
  *   - ensure sane alignment of output data
#line 3267
  *   - copy (conversion happens automatically) input data
#line 3267
  *     to output
#line 3267
  *   - update tp to point at next unconverted input, and xpp to point
#line 3267
  *     at next location for converted output
#line 3267
  */
#line 3267
  long i, j, ni;
#line 3267
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3267
  int *xp;
#line 3267
  double d;               /* special case for ncx_putn_int_float */
#line 3267
  int nrange = 0;         /* number of range errors */
#line 3267
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3267
  long cxp = (long) *((char**)xpp);
#line 3267

#line 3267
  realign = (cxp & 7) % SIZEOF_INT;
#line 3267
  /* sjl: manually stripmine so we can limit amount of
#line 3267
   * vector work space reserved to LOOPCNT elements. Also
#line 3267
   * makes vectorisation easy */
#line 3267
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3267
    ni=Min(nelems-j,LOOPCNT);
#line 3267
    if (realign) {
#line 3267
      xp = tmp;
#line 3267
    } else {
#line 3267
      xp = (int *) *xpp;
#line 3267
    }
#line 3267
   /* copy the next block */
#line 3267
#pragma cdir loopcnt=LOOPCNT
#line 3267
#pragma cdir shortloop
#line 3267
    for (i=0; i<ni; i++) {
#line 3267
      /* for some reason int to float, for putn, requires a special case */
#line 3267
      d = tp[i];
#line 3267
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) d));
#line 3267
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3267
    }
#line 3267
   /* copy workspace back if necessary */
#line 3267
    if (realign) {
#line 3267
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3267
      xp = (int *) *xpp;
#line 3267
    }
#line 3267
   /* update xpp and tp */
#line 3267
    xp += ni;
#line 3267
    tp += ni;
#line 3267
    *xpp = (void*)xp;
#line 3267
  }
#line 3267
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3267

#line 3267
#else   /* not SX */
#line 3267

#line 3267
	char *xp = (char *) *xpp;
#line 3267
	int status = NC_NOERR;
#line 3267

#line 3267
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3267
	{
#line 3267
		int lstatus = ncx_put_int_float(xp, tp, fillp);
#line 3267
		if (status == NC_NOERR) /* report the first encountered error */
#line 3267
			status = lstatus;
#line 3267
	}
#line 3267

#line 3267
	*xpp = (void *)xp;
#line 3267
	return status;
#line 3267
#endif
#line 3267
}
#line 3267

int
#line 3268
ncx_putn_int_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3268
{
#line 3268
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3268

#line 3268
 /* basic algorithm is:
#line 3268
  *   - ensure sane alignment of output data
#line 3268
  *   - copy (conversion happens automatically) input data
#line 3268
  *     to output
#line 3268
  *   - update tp to point at next unconverted input, and xpp to point
#line 3268
  *     at next location for converted output
#line 3268
  */
#line 3268
  long i, j, ni;
#line 3268
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3268
  int *xp;
#line 3268
  int nrange = 0;         /* number of range errors */
#line 3268
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3268
  long cxp = (long) *((char**)xpp);
#line 3268

#line 3268
  realign = (cxp & 7) % SIZEOF_INT;
#line 3268
  /* sjl: manually stripmine so we can limit amount of
#line 3268
   * vector work space reserved to LOOPCNT elements. Also
#line 3268
   * makes vectorisation easy */
#line 3268
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3268
    ni=Min(nelems-j,LOOPCNT);
#line 3268
    if (realign) {
#line 3268
      xp = tmp;
#line 3268
    } else {
#line 3268
      xp = (int *) *xpp;
#line 3268
    }
#line 3268
   /* copy the next block */
#line 3268
#pragma cdir loopcnt=LOOPCNT
#line 3268
#pragma cdir shortloop
#line 3268
    for (i=0; i<ni; i++) {
#line 3268
      /* the normal case: */
#line 3268
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3268
     /* test for range errors (not always needed but do it anyway) */
#line 3268
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3268
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3268
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3268
    }
#line 3268
   /* copy workspace back if necessary */
#line 3268
    if (realign) {
#line 3268
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3268
      xp = (int *) *xpp;
#line 3268
    }
#line 3268
   /* update xpp and tp */
#line 3268
    xp += ni;
#line 3268
    tp += ni;
#line 3268
    *xpp = (void*)xp;
#line 3268
  }
#line 3268
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3268

#line 3268
#else   /* not SX */
#line 3268

#line 3268
	char *xp = (char *) *xpp;
#line 3268
	int status = NC_NOERR;
#line 3268

#line 3268
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3268
	{
#line 3268
		int lstatus = ncx_put_int_double(xp, tp, fillp);
#line 3268
		if (status == NC_NOERR) /* report the first encountered error */
#line 3268
			status = lstatus;
#line 3268
	}
#line 3268

#line 3268
	*xpp = (void *)xp;
#line 3268
	return status;
#line 3268
#endif
#line 3268
}
#line 3268

int
#line 3269
ncx_putn_int_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3269
{
#line 3269
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3269

#line 3269
 /* basic algorithm is:
#line 3269
  *   - ensure sane alignment of output data
#line 3269
  *   - copy (conversion happens automatically) input data
#line 3269
  *     to output
#line 3269
  *   - update tp to point at next unconverted input, and xpp to point
#line 3269
  *     at next location for converted output
#line 3269
  */
#line 3269
  long i, j, ni;
#line 3269
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3269
  int *xp;
#line 3269
  int nrange = 0;         /* number of range errors */
#line 3269
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3269
  long cxp = (long) *((char**)xpp);
#line 3269

#line 3269
  realign = (cxp & 7) % SIZEOF_INT;
#line 3269
  /* sjl: manually stripmine so we can limit amount of
#line 3269
   * vector work space reserved to LOOPCNT elements. Also
#line 3269
   * makes vectorisation easy */
#line 3269
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3269
    ni=Min(nelems-j,LOOPCNT);
#line 3269
    if (realign) {
#line 3269
      xp = tmp;
#line 3269
    } else {
#line 3269
      xp = (int *) *xpp;
#line 3269
    }
#line 3269
   /* copy the next block */
#line 3269
#pragma cdir loopcnt=LOOPCNT
#line 3269
#pragma cdir shortloop
#line 3269
    for (i=0; i<ni; i++) {
#line 3269
      /* the normal case: */
#line 3269
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3269
     /* test for range errors (not always needed but do it anyway) */
#line 3269
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3269
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3269
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3269
    }
#line 3269
   /* copy workspace back if necessary */
#line 3269
    if (realign) {
#line 3269
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3269
      xp = (int *) *xpp;
#line 3269
    }
#line 3269
   /* update xpp and tp */
#line 3269
    xp += ni;
#line 3269
    tp += ni;
#line 3269
    *xpp = (void*)xp;
#line 3269
  }
#line 3269
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3269

#line 3269
#else   /* not SX */
#line 3269

#line 3269
	char *xp = (char *) *xpp;
#line 3269
	int status = NC_NOERR;
#line 3269

#line 3269
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3269
	{
#line 3269
		int lstatus = ncx_put_int_longlong(xp, tp, fillp);
#line 3269
		if (status == NC_NOERR) /* report the first encountered error */
#line 3269
			status = lstatus;
#line 3269
	}
#line 3269

#line 3269
	*xpp = (void *)xp;
#line 3269
	return status;
#line 3269
#endif
#line 3269
}
#line 3269

int
#line 3270
ncx_putn_int_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3270
{
#line 3270
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3270

#line 3270
 /* basic algorithm is:
#line 3270
  *   - ensure sane alignment of output data
#line 3270
  *   - copy (conversion happens automatically) input data
#line 3270
  *     to output
#line 3270
  *   - update tp to point at next unconverted input, and xpp to point
#line 3270
  *     at next location for converted output
#line 3270
  */
#line 3270
  long i, j, ni;
#line 3270
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3270
  int *xp;
#line 3270
  int nrange = 0;         /* number of range errors */
#line 3270
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3270
  long cxp = (long) *((char**)xpp);
#line 3270

#line 3270
  realign = (cxp & 7) % SIZEOF_INT;
#line 3270
  /* sjl: manually stripmine so we can limit amount of
#line 3270
   * vector work space reserved to LOOPCNT elements. Also
#line 3270
   * makes vectorisation easy */
#line 3270
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3270
    ni=Min(nelems-j,LOOPCNT);
#line 3270
    if (realign) {
#line 3270
      xp = tmp;
#line 3270
    } else {
#line 3270
      xp = (int *) *xpp;
#line 3270
    }
#line 3270
   /* copy the next block */
#line 3270
#pragma cdir loopcnt=LOOPCNT
#line 3270
#pragma cdir shortloop
#line 3270
    for (i=0; i<ni; i++) {
#line 3270
      /* the normal case: */
#line 3270
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3270
     /* test for range errors (not always needed but do it anyway) */
#line 3270
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3270
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3270
      nrange += tp[i] > X_INT_MAX ;
#line 3270
    }
#line 3270
   /* copy workspace back if necessary */
#line 3270
    if (realign) {
#line 3270
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3270
      xp = (int *) *xpp;
#line 3270
    }
#line 3270
   /* update xpp and tp */
#line 3270
    xp += ni;
#line 3270
    tp += ni;
#line 3270
    *xpp = (void*)xp;
#line 3270
  }
#line 3270
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3270

#line 3270
#else   /* not SX */
#line 3270

#line 3270
	char *xp = (char *) *xpp;
#line 3270
	int status = NC_NOERR;
#line 3270

#line 3270
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3270
	{
#line 3270
		int lstatus = ncx_put_int_uchar(xp, tp, fillp);
#line 3270
		if (status == NC_NOERR) /* report the first encountered error */
#line 3270
			status = lstatus;
#line 3270
	}
#line 3270

#line 3270
	*xpp = (void *)xp;
#line 3270
	return status;
#line 3270
#endif
#line 3270
}
#line 3270

int
#line 3271
ncx_putn_int_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3271
{
#line 3271
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3271

#line 3271
 /* basic algorithm is:
#line 3271
  *   - ensure sane alignment of output data
#line 3271
  *   - copy (conversion happens automatically) input data
#line 3271
  *     to output
#line 3271
  *   - update tp to point at next unconverted input, and xpp to point
#line 3271
  *     at next location for converted output
#line 3271
  */
#line 3271
  long i, j, ni;
#line 3271
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3271
  int *xp;
#line 3271
  int nrange = 0;         /* number of range errors */
#line 3271
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3271
  long cxp = (long) *((char**)xpp);
#line 3271

#line 3271
  realign = (cxp & 7) % SIZEOF_INT;
#line 3271
  /* sjl: manually stripmine so we can limit amount of
#line 3271
   * vector work space reserved to LOOPCNT elements. Also
#line 3271
   * makes vectorisation easy */
#line 3271
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3271
    ni=Min(nelems-j,LOOPCNT);
#line 3271
    if (realign) {
#line 3271
      xp = tmp;
#line 3271
    } else {
#line 3271
      xp = (int *) *xpp;
#line 3271
    }
#line 3271
   /* copy the next block */
#line 3271
#pragma cdir loopcnt=LOOPCNT
#line 3271
#pragma cdir shortloop
#line 3271
    for (i=0; i<ni; i++) {
#line 3271
      /* the normal case: */
#line 3271
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3271
     /* test for range errors (not always needed but do it anyway) */
#line 3271
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3271
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3271
      nrange += tp[i] > X_INT_MAX ;
#line 3271
    }
#line 3271
   /* copy workspace back if necessary */
#line 3271
    if (realign) {
#line 3271
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3271
      xp = (int *) *xpp;
#line 3271
    }
#line 3271
   /* update xpp and tp */
#line 3271
    xp += ni;
#line 3271
    tp += ni;
#line 3271
    *xpp = (void*)xp;
#line 3271
  }
#line 3271
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3271

#line 3271
#else   /* not SX */
#line 3271

#line 3271
	char *xp = (char *) *xpp;
#line 3271
	int status = NC_NOERR;
#line 3271

#line 3271
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3271
	{
#line 3271
		int lstatus = ncx_put_int_ushort(xp, tp, fillp);
#line 3271
		if (status == NC_NOERR) /* report the first encountered error */
#line 3271
			status = lstatus;
#line 3271
	}
#line 3271

#line 3271
	*xpp = (void *)xp;
#line 3271
	return status;
#line 3271
#endif
#line 3271
}
#line 3271

int
#line 3272
ncx_putn_int_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3272
{
#line 3272
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3272

#line 3272
 /* basic algorithm is:
#line 3272
  *   - ensure sane alignment of output data
#line 3272
  *   - copy (conversion happens automatically) input data
#line 3272
  *     to output
#line 3272
  *   - update tp to point at next unconverted input, and xpp to point
#line 3272
  *     at next location for converted output
#line 3272
  */
#line 3272
  long i, j, ni;
#line 3272
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3272
  int *xp;
#line 3272
  int nrange = 0;         /* number of range errors */
#line 3272
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3272
  long cxp = (long) *((char**)xpp);
#line 3272

#line 3272
  realign = (cxp & 7) % SIZEOF_INT;
#line 3272
  /* sjl: manually stripmine so we can limit amount of
#line 3272
   * vector work space reserved to LOOPCNT elements. Also
#line 3272
   * makes vectorisation easy */
#line 3272
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3272
    ni=Min(nelems-j,LOOPCNT);
#line 3272
    if (realign) {
#line 3272
      xp = tmp;
#line 3272
    } else {
#line 3272
      xp = (int *) *xpp;
#line 3272
    }
#line 3272
   /* copy the next block */
#line 3272
#pragma cdir loopcnt=LOOPCNT
#line 3272
#pragma cdir shortloop
#line 3272
    for (i=0; i<ni; i++) {
#line 3272
      /* the normal case: */
#line 3272
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3272
     /* test for range errors (not always needed but do it anyway) */
#line 3272
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3272
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3272
      nrange += tp[i] > X_INT_MAX ;
#line 3272
    }
#line 3272
   /* copy workspace back if necessary */
#line 3272
    if (realign) {
#line 3272
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3272
      xp = (int *) *xpp;
#line 3272
    }
#line 3272
   /* update xpp and tp */
#line 3272
    xp += ni;
#line 3272
    tp += ni;
#line 3272
    *xpp = (void*)xp;
#line 3272
  }
#line 3272
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3272

#line 3272
#else   /* not SX */
#line 3272

#line 3272
	char *xp = (char *) *xpp;
#line 3272
	int status = NC_NOERR;
#line 3272

#line 3272
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3272
	{
#line 3272
		int lstatus = ncx_put_int_uint(xp, tp, fillp);
#line 3272
		if (status == NC_NOERR) /* report the first encountered error */
#line 3272
			status = lstatus;
#line 3272
	}
#line 3272

#line 3272
	*xpp = (void *)xp;
#line 3272
	return status;
#line 3272
#endif
#line 3272
}
#line 3272

int
#line 3273
ncx_putn_int_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3273
{
#line 3273
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT == SIZEOF_INT
#line 3273

#line 3273
 /* basic algorithm is:
#line 3273
  *   - ensure sane alignment of output data
#line 3273
  *   - copy (conversion happens automatically) input data
#line 3273
  *     to output
#line 3273
  *   - update tp to point at next unconverted input, and xpp to point
#line 3273
  *     at next location for converted output
#line 3273
  */
#line 3273
  long i, j, ni;
#line 3273
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3273
  int *xp;
#line 3273
  int nrange = 0;         /* number of range errors */
#line 3273
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3273
  long cxp = (long) *((char**)xpp);
#line 3273

#line 3273
  realign = (cxp & 7) % SIZEOF_INT;
#line 3273
  /* sjl: manually stripmine so we can limit amount of
#line 3273
   * vector work space reserved to LOOPCNT elements. Also
#line 3273
   * makes vectorisation easy */
#line 3273
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3273
    ni=Min(nelems-j,LOOPCNT);
#line 3273
    if (realign) {
#line 3273
      xp = tmp;
#line 3273
    } else {
#line 3273
      xp = (int *) *xpp;
#line 3273
    }
#line 3273
   /* copy the next block */
#line 3273
#pragma cdir loopcnt=LOOPCNT
#line 3273
#pragma cdir shortloop
#line 3273
    for (i=0; i<ni; i++) {
#line 3273
      /* the normal case: */
#line 3273
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3273
     /* test for range errors (not always needed but do it anyway) */
#line 3273
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3273
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3273
      nrange += tp[i] > X_INT_MAX ;
#line 3273
    }
#line 3273
   /* copy workspace back if necessary */
#line 3273
    if (realign) {
#line 3273
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT);
#line 3273
      xp = (int *) *xpp;
#line 3273
    }
#line 3273
   /* update xpp and tp */
#line 3273
    xp += ni;
#line 3273
    tp += ni;
#line 3273
    *xpp = (void*)xp;
#line 3273
  }
#line 3273
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3273

#line 3273
#else   /* not SX */
#line 3273

#line 3273
	char *xp = (char *) *xpp;
#line 3273
	int status = NC_NOERR;
#line 3273

#line 3273
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3273
	{
#line 3273
		int lstatus = ncx_put_int_ulonglong(xp, tp, fillp);
#line 3273
		if (status == NC_NOERR) /* report the first encountered error */
#line 3273
			status = lstatus;
#line 3273
	}
#line 3273

#line 3273
	*xpp = (void *)xp;
#line 3273
	return status;
#line 3273
#endif
#line 3273
}
#line 3273


/* uint ----------------------------------------------------------------------*/

#if X_SIZEOF_UINT == SIZEOF_UINT
/* optimized version */
int
ncx_getn_uint_uint(const void **xpp, size_t nelems, unsigned int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_UINT);
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_UINT);
	return NC_NOERR;
}
#else
int
#line 3291
ncx_getn_uint_uint(const void **xpp, size_t nelems, uint *tp)
#line 3291
{
#line 3291
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3291

#line 3291
 /* basic algorithm is:
#line 3291
  *   - ensure sane alignment of input data
#line 3291
  *   - copy (conversion happens automatically) input data
#line 3291
  *     to output
#line 3291
  *   - update xpp to point at next unconverted input, and tp to point
#line 3291
  *     at next location for converted output
#line 3291
  */
#line 3291
  long i, j, ni;
#line 3291
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3291
  uint *xp;
#line 3291
  int nrange = 0;         /* number of range errors */
#line 3291
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3291
  long cxp = (long) *((char**)xpp);
#line 3291

#line 3291
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3291
  /* sjl: manually stripmine so we can limit amount of
#line 3291
   * vector work space reserved to LOOPCNT elements. Also
#line 3291
   * makes vectorisation easy */
#line 3291
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3291
    ni=Min(nelems-j,LOOPCNT);
#line 3291
    if (realign) {
#line 3291
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3291
      xp = tmp;
#line 3291
    } else {
#line 3291
      xp = (uint *) *xpp;
#line 3291
    }
#line 3291
   /* copy the next block */
#line 3291
#pragma cdir loopcnt=LOOPCNT
#line 3291
#pragma cdir shortloop
#line 3291
    for (i=0; i<ni; i++) {
#line 3291
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3291
     /* test for range errors (not always needed but do it anyway) */
#line 3291
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3291
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3291
      nrange += xp[i] > UINT_MAX ;
#line 3291
    }
#line 3291
   /* update xpp and tp */
#line 3291
    if (realign) xp = (uint *) *xpp;
#line 3291
    xp += ni;
#line 3291
    tp += ni;
#line 3291
    *xpp = (void*)xp;
#line 3291
  }
#line 3291
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3291

#line 3291
#else   /* not SX */
#line 3291
	const char *xp = (const char *) *xpp;
#line 3291
	int status = NC_NOERR;
#line 3291

#line 3291
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3291
	{
#line 3291
		const int lstatus = ncx_get_uint_uint(xp, tp);
#line 3291
		if (status == NC_NOERR) /* report the first encountered error */
#line 3291
			status = lstatus;
#line 3291
	}
#line 3291

#line 3291
	*xpp = (const void *)xp;
#line 3291
	return status;
#line 3291
#endif
#line 3291
}
#line 3291

#endif
int
#line 3293
ncx_getn_uint_schar(const void **xpp, size_t nelems, schar *tp)
#line 3293
{
#line 3293
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3293

#line 3293
 /* basic algorithm is:
#line 3293
  *   - ensure sane alignment of input data
#line 3293
  *   - copy (conversion happens automatically) input data
#line 3293
  *     to output
#line 3293
  *   - update xpp to point at next unconverted input, and tp to point
#line 3293
  *     at next location for converted output
#line 3293
  */
#line 3293
  long i, j, ni;
#line 3293
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3293
  uint *xp;
#line 3293
  int nrange = 0;         /* number of range errors */
#line 3293
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3293
  long cxp = (long) *((char**)xpp);
#line 3293

#line 3293
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3293
  /* sjl: manually stripmine so we can limit amount of
#line 3293
   * vector work space reserved to LOOPCNT elements. Also
#line 3293
   * makes vectorisation easy */
#line 3293
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3293
    ni=Min(nelems-j,LOOPCNT);
#line 3293
    if (realign) {
#line 3293
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3293
      xp = tmp;
#line 3293
    } else {
#line 3293
      xp = (uint *) *xpp;
#line 3293
    }
#line 3293
   /* copy the next block */
#line 3293
#pragma cdir loopcnt=LOOPCNT
#line 3293
#pragma cdir shortloop
#line 3293
    for (i=0; i<ni; i++) {
#line 3293
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3293
     /* test for range errors (not always needed but do it anyway) */
#line 3293
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3293
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3293
      nrange += xp[i] > SCHAR_MAX ;
#line 3293
    }
#line 3293
   /* update xpp and tp */
#line 3293
    if (realign) xp = (uint *) *xpp;
#line 3293
    xp += ni;
#line 3293
    tp += ni;
#line 3293
    *xpp = (void*)xp;
#line 3293
  }
#line 3293
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3293

#line 3293
#else   /* not SX */
#line 3293
	const char *xp = (const char *) *xpp;
#line 3293
	int status = NC_NOERR;
#line 3293

#line 3293
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3293
	{
#line 3293
		const int lstatus = ncx_get_uint_schar(xp, tp);
#line 3293
		if (status == NC_NOERR) /* report the first encountered error */
#line 3293
			status = lstatus;
#line 3293
	}
#line 3293

#line 3293
	*xpp = (const void *)xp;
#line 3293
	return status;
#line 3293
#endif
#line 3293
}
#line 3293

int
#line 3294
ncx_getn_uint_short(const void **xpp, size_t nelems, short *tp)
#line 3294
{
#line 3294
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3294

#line 3294
 /* basic algorithm is:
#line 3294
  *   - ensure sane alignment of input data
#line 3294
  *   - copy (conversion happens automatically) input data
#line 3294
  *     to output
#line 3294
  *   - update xpp to point at next unconverted input, and tp to point
#line 3294
  *     at next location for converted output
#line 3294
  */
#line 3294
  long i, j, ni;
#line 3294
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3294
  uint *xp;
#line 3294
  int nrange = 0;         /* number of range errors */
#line 3294
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3294
  long cxp = (long) *((char**)xpp);
#line 3294

#line 3294
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3294
  /* sjl: manually stripmine so we can limit amount of
#line 3294
   * vector work space reserved to LOOPCNT elements. Also
#line 3294
   * makes vectorisation easy */
#line 3294
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3294
    ni=Min(nelems-j,LOOPCNT);
#line 3294
    if (realign) {
#line 3294
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3294
      xp = tmp;
#line 3294
    } else {
#line 3294
      xp = (uint *) *xpp;
#line 3294
    }
#line 3294
   /* copy the next block */
#line 3294
#pragma cdir loopcnt=LOOPCNT
#line 3294
#pragma cdir shortloop
#line 3294
    for (i=0; i<ni; i++) {
#line 3294
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3294
     /* test for range errors (not always needed but do it anyway) */
#line 3294
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3294
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3294
      nrange += xp[i] > SHORT_MAX ;
#line 3294
    }
#line 3294
   /* update xpp and tp */
#line 3294
    if (realign) xp = (uint *) *xpp;
#line 3294
    xp += ni;
#line 3294
    tp += ni;
#line 3294
    *xpp = (void*)xp;
#line 3294
  }
#line 3294
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3294

#line 3294
#else   /* not SX */
#line 3294
	const char *xp = (const char *) *xpp;
#line 3294
	int status = NC_NOERR;
#line 3294

#line 3294
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3294
	{
#line 3294
		const int lstatus = ncx_get_uint_short(xp, tp);
#line 3294
		if (status == NC_NOERR) /* report the first encountered error */
#line 3294
			status = lstatus;
#line 3294
	}
#line 3294

#line 3294
	*xpp = (const void *)xp;
#line 3294
	return status;
#line 3294
#endif
#line 3294
}
#line 3294

int
#line 3295
ncx_getn_uint_int(const void **xpp, size_t nelems, int *tp)
#line 3295
{
#line 3295
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3295

#line 3295
 /* basic algorithm is:
#line 3295
  *   - ensure sane alignment of input data
#line 3295
  *   - copy (conversion happens automatically) input data
#line 3295
  *     to output
#line 3295
  *   - update xpp to point at next unconverted input, and tp to point
#line 3295
  *     at next location for converted output
#line 3295
  */
#line 3295
  long i, j, ni;
#line 3295
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3295
  uint *xp;
#line 3295
  int nrange = 0;         /* number of range errors */
#line 3295
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3295
  long cxp = (long) *((char**)xpp);
#line 3295

#line 3295
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3295
  /* sjl: manually stripmine so we can limit amount of
#line 3295
   * vector work space reserved to LOOPCNT elements. Also
#line 3295
   * makes vectorisation easy */
#line 3295
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3295
    ni=Min(nelems-j,LOOPCNT);
#line 3295
    if (realign) {
#line 3295
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3295
      xp = tmp;
#line 3295
    } else {
#line 3295
      xp = (uint *) *xpp;
#line 3295
    }
#line 3295
   /* copy the next block */
#line 3295
#pragma cdir loopcnt=LOOPCNT
#line 3295
#pragma cdir shortloop
#line 3295
    for (i=0; i<ni; i++) {
#line 3295
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3295
     /* test for range errors (not always needed but do it anyway) */
#line 3295
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3295
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3295
      nrange += xp[i] > INT_MAX ;
#line 3295
    }
#line 3295
   /* update xpp and tp */
#line 3295
    if (realign) xp = (uint *) *xpp;
#line 3295
    xp += ni;
#line 3295
    tp += ni;
#line 3295
    *xpp = (void*)xp;
#line 3295
  }
#line 3295
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3295

#line 3295
#else   /* not SX */
#line 3295
	const char *xp = (const char *) *xpp;
#line 3295
	int status = NC_NOERR;
#line 3295

#line 3295
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3295
	{
#line 3295
		const int lstatus = ncx_get_uint_int(xp, tp);
#line 3295
		if (status == NC_NOERR) /* report the first encountered error */
#line 3295
			status = lstatus;
#line 3295
	}
#line 3295

#line 3295
	*xpp = (const void *)xp;
#line 3295
	return status;
#line 3295
#endif
#line 3295
}
#line 3295

int
#line 3296
ncx_getn_uint_long(const void **xpp, size_t nelems, long *tp)
#line 3296
{
#line 3296
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3296

#line 3296
 /* basic algorithm is:
#line 3296
  *   - ensure sane alignment of input data
#line 3296
  *   - copy (conversion happens automatically) input data
#line 3296
  *     to output
#line 3296
  *   - update xpp to point at next unconverted input, and tp to point
#line 3296
  *     at next location for converted output
#line 3296
  */
#line 3296
  long i, j, ni;
#line 3296
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3296
  uint *xp;
#line 3296
  int nrange = 0;         /* number of range errors */
#line 3296
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3296
  long cxp = (long) *((char**)xpp);
#line 3296

#line 3296
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3296
  /* sjl: manually stripmine so we can limit amount of
#line 3296
   * vector work space reserved to LOOPCNT elements. Also
#line 3296
   * makes vectorisation easy */
#line 3296
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3296
    ni=Min(nelems-j,LOOPCNT);
#line 3296
    if (realign) {
#line 3296
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3296
      xp = tmp;
#line 3296
    } else {
#line 3296
      xp = (uint *) *xpp;
#line 3296
    }
#line 3296
   /* copy the next block */
#line 3296
#pragma cdir loopcnt=LOOPCNT
#line 3296
#pragma cdir shortloop
#line 3296
    for (i=0; i<ni; i++) {
#line 3296
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3296
     /* test for range errors (not always needed but do it anyway) */
#line 3296
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3296
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3296
      nrange += xp[i] > LONG_MAX ;
#line 3296
    }
#line 3296
   /* update xpp and tp */
#line 3296
    if (realign) xp = (uint *) *xpp;
#line 3296
    xp += ni;
#line 3296
    tp += ni;
#line 3296
    *xpp = (void*)xp;
#line 3296
  }
#line 3296
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3296

#line 3296
#else   /* not SX */
#line 3296
	const char *xp = (const char *) *xpp;
#line 3296
	int status = NC_NOERR;
#line 3296

#line 3296
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3296
	{
#line 3296
		const int lstatus = ncx_get_uint_long(xp, tp);
#line 3296
		if (status == NC_NOERR) /* report the first encountered error */
#line 3296
			status = lstatus;
#line 3296
	}
#line 3296

#line 3296
	*xpp = (const void *)xp;
#line 3296
	return status;
#line 3296
#endif
#line 3296
}
#line 3296

int
#line 3297
ncx_getn_uint_float(const void **xpp, size_t nelems, float *tp)
#line 3297
{
#line 3297
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3297

#line 3297
 /* basic algorithm is:
#line 3297
  *   - ensure sane alignment of input data
#line 3297
  *   - copy (conversion happens automatically) input data
#line 3297
  *     to output
#line 3297
  *   - update xpp to point at next unconverted input, and tp to point
#line 3297
  *     at next location for converted output
#line 3297
  */
#line 3297
  long i, j, ni;
#line 3297
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3297
  uint *xp;
#line 3297
  int nrange = 0;         /* number of range errors */
#line 3297
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3297
  long cxp = (long) *((char**)xpp);
#line 3297

#line 3297
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3297
  /* sjl: manually stripmine so we can limit amount of
#line 3297
   * vector work space reserved to LOOPCNT elements. Also
#line 3297
   * makes vectorisation easy */
#line 3297
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3297
    ni=Min(nelems-j,LOOPCNT);
#line 3297
    if (realign) {
#line 3297
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3297
      xp = tmp;
#line 3297
    } else {
#line 3297
      xp = (uint *) *xpp;
#line 3297
    }
#line 3297
   /* copy the next block */
#line 3297
#pragma cdir loopcnt=LOOPCNT
#line 3297
#pragma cdir shortloop
#line 3297
    for (i=0; i<ni; i++) {
#line 3297
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3297
     /* test for range errors (not always needed but do it anyway) */
#line 3297
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3297
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3297
      nrange += xp[i] > FLOAT_MAX ;
#line 3297
    }
#line 3297
   /* update xpp and tp */
#line 3297
    if (realign) xp = (uint *) *xpp;
#line 3297
    xp += ni;
#line 3297
    tp += ni;
#line 3297
    *xpp = (void*)xp;
#line 3297
  }
#line 3297
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3297

#line 3297
#else   /* not SX */
#line 3297
	const char *xp = (const char *) *xpp;
#line 3297
	int status = NC_NOERR;
#line 3297

#line 3297
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3297
	{
#line 3297
		const int lstatus = ncx_get_uint_float(xp, tp);
#line 3297
		if (status == NC_NOERR) /* report the first encountered error */
#line 3297
			status = lstatus;
#line 3297
	}
#line 3297

#line 3297
	*xpp = (const void *)xp;
#line 3297
	return status;
#line 3297
#endif
#line 3297
}
#line 3297

int
#line 3298
ncx_getn_uint_double(const void **xpp, size_t nelems, double *tp)
#line 3298
{
#line 3298
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3298

#line 3298
 /* basic algorithm is:
#line 3298
  *   - ensure sane alignment of input data
#line 3298
  *   - copy (conversion happens automatically) input data
#line 3298
  *     to output
#line 3298
  *   - update xpp to point at next unconverted input, and tp to point
#line 3298
  *     at next location for converted output
#line 3298
  */
#line 3298
  long i, j, ni;
#line 3298
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3298
  uint *xp;
#line 3298
  int nrange = 0;         /* number of range errors */
#line 3298
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3298
  long cxp = (long) *((char**)xpp);
#line 3298

#line 3298
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3298
  /* sjl: manually stripmine so we can limit amount of
#line 3298
   * vector work space reserved to LOOPCNT elements. Also
#line 3298
   * makes vectorisation easy */
#line 3298
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3298
    ni=Min(nelems-j,LOOPCNT);
#line 3298
    if (realign) {
#line 3298
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3298
      xp = tmp;
#line 3298
    } else {
#line 3298
      xp = (uint *) *xpp;
#line 3298
    }
#line 3298
   /* copy the next block */
#line 3298
#pragma cdir loopcnt=LOOPCNT
#line 3298
#pragma cdir shortloop
#line 3298
    for (i=0; i<ni; i++) {
#line 3298
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3298
     /* test for range errors (not always needed but do it anyway) */
#line 3298
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3298
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3298
      nrange += xp[i] > DOUBLE_MAX ;
#line 3298
    }
#line 3298
   /* update xpp and tp */
#line 3298
    if (realign) xp = (uint *) *xpp;
#line 3298
    xp += ni;
#line 3298
    tp += ni;
#line 3298
    *xpp = (void*)xp;
#line 3298
  }
#line 3298
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3298

#line 3298
#else   /* not SX */
#line 3298
	const char *xp = (const char *) *xpp;
#line 3298
	int status = NC_NOERR;
#line 3298

#line 3298
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3298
	{
#line 3298
		const int lstatus = ncx_get_uint_double(xp, tp);
#line 3298
		if (status == NC_NOERR) /* report the first encountered error */
#line 3298
			status = lstatus;
#line 3298
	}
#line 3298

#line 3298
	*xpp = (const void *)xp;
#line 3298
	return status;
#line 3298
#endif
#line 3298
}
#line 3298

int
#line 3299
ncx_getn_uint_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3299
{
#line 3299
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3299

#line 3299
 /* basic algorithm is:
#line 3299
  *   - ensure sane alignment of input data
#line 3299
  *   - copy (conversion happens automatically) input data
#line 3299
  *     to output
#line 3299
  *   - update xpp to point at next unconverted input, and tp to point
#line 3299
  *     at next location for converted output
#line 3299
  */
#line 3299
  long i, j, ni;
#line 3299
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3299
  uint *xp;
#line 3299
  int nrange = 0;         /* number of range errors */
#line 3299
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3299
  long cxp = (long) *((char**)xpp);
#line 3299

#line 3299
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3299
  /* sjl: manually stripmine so we can limit amount of
#line 3299
   * vector work space reserved to LOOPCNT elements. Also
#line 3299
   * makes vectorisation easy */
#line 3299
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3299
    ni=Min(nelems-j,LOOPCNT);
#line 3299
    if (realign) {
#line 3299
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3299
      xp = tmp;
#line 3299
    } else {
#line 3299
      xp = (uint *) *xpp;
#line 3299
    }
#line 3299
   /* copy the next block */
#line 3299
#pragma cdir loopcnt=LOOPCNT
#line 3299
#pragma cdir shortloop
#line 3299
    for (i=0; i<ni; i++) {
#line 3299
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3299
     /* test for range errors (not always needed but do it anyway) */
#line 3299
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3299
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3299
      nrange += xp[i] > LONGLONG_MAX ;
#line 3299
    }
#line 3299
   /* update xpp and tp */
#line 3299
    if (realign) xp = (uint *) *xpp;
#line 3299
    xp += ni;
#line 3299
    tp += ni;
#line 3299
    *xpp = (void*)xp;
#line 3299
  }
#line 3299
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3299

#line 3299
#else   /* not SX */
#line 3299
	const char *xp = (const char *) *xpp;
#line 3299
	int status = NC_NOERR;
#line 3299

#line 3299
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3299
	{
#line 3299
		const int lstatus = ncx_get_uint_longlong(xp, tp);
#line 3299
		if (status == NC_NOERR) /* report the first encountered error */
#line 3299
			status = lstatus;
#line 3299
	}
#line 3299

#line 3299
	*xpp = (const void *)xp;
#line 3299
	return status;
#line 3299
#endif
#line 3299
}
#line 3299

int
#line 3300
ncx_getn_uint_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3300
{
#line 3300
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3300

#line 3300
 /* basic algorithm is:
#line 3300
  *   - ensure sane alignment of input data
#line 3300
  *   - copy (conversion happens automatically) input data
#line 3300
  *     to output
#line 3300
  *   - update xpp to point at next unconverted input, and tp to point
#line 3300
  *     at next location for converted output
#line 3300
  */
#line 3300
  long i, j, ni;
#line 3300
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3300
  uint *xp;
#line 3300
  int nrange = 0;         /* number of range errors */
#line 3300
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3300
  long cxp = (long) *((char**)xpp);
#line 3300

#line 3300
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3300
  /* sjl: manually stripmine so we can limit amount of
#line 3300
   * vector work space reserved to LOOPCNT elements. Also
#line 3300
   * makes vectorisation easy */
#line 3300
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3300
    ni=Min(nelems-j,LOOPCNT);
#line 3300
    if (realign) {
#line 3300
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3300
      xp = tmp;
#line 3300
    } else {
#line 3300
      xp = (uint *) *xpp;
#line 3300
    }
#line 3300
   /* copy the next block */
#line 3300
#pragma cdir loopcnt=LOOPCNT
#line 3300
#pragma cdir shortloop
#line 3300
    for (i=0; i<ni; i++) {
#line 3300
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3300
     /* test for range errors (not always needed but do it anyway) */
#line 3300
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3300
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3300
      nrange += xp[i] > UCHAR_MAX ;
#line 3300
    }
#line 3300
   /* update xpp and tp */
#line 3300
    if (realign) xp = (uint *) *xpp;
#line 3300
    xp += ni;
#line 3300
    tp += ni;
#line 3300
    *xpp = (void*)xp;
#line 3300
  }
#line 3300
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3300

#line 3300
#else   /* not SX */
#line 3300
	const char *xp = (const char *) *xpp;
#line 3300
	int status = NC_NOERR;
#line 3300

#line 3300
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3300
	{
#line 3300
		const int lstatus = ncx_get_uint_uchar(xp, tp);
#line 3300
		if (status == NC_NOERR) /* report the first encountered error */
#line 3300
			status = lstatus;
#line 3300
	}
#line 3300

#line 3300
	*xpp = (const void *)xp;
#line 3300
	return status;
#line 3300
#endif
#line 3300
}
#line 3300

int
#line 3301
ncx_getn_uint_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3301
{
#line 3301
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3301

#line 3301
 /* basic algorithm is:
#line 3301
  *   - ensure sane alignment of input data
#line 3301
  *   - copy (conversion happens automatically) input data
#line 3301
  *     to output
#line 3301
  *   - update xpp to point at next unconverted input, and tp to point
#line 3301
  *     at next location for converted output
#line 3301
  */
#line 3301
  long i, j, ni;
#line 3301
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3301
  uint *xp;
#line 3301
  int nrange = 0;         /* number of range errors */
#line 3301
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3301
  long cxp = (long) *((char**)xpp);
#line 3301

#line 3301
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3301
  /* sjl: manually stripmine so we can limit amount of
#line 3301
   * vector work space reserved to LOOPCNT elements. Also
#line 3301
   * makes vectorisation easy */
#line 3301
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3301
    ni=Min(nelems-j,LOOPCNT);
#line 3301
    if (realign) {
#line 3301
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3301
      xp = tmp;
#line 3301
    } else {
#line 3301
      xp = (uint *) *xpp;
#line 3301
    }
#line 3301
   /* copy the next block */
#line 3301
#pragma cdir loopcnt=LOOPCNT
#line 3301
#pragma cdir shortloop
#line 3301
    for (i=0; i<ni; i++) {
#line 3301
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3301
     /* test for range errors (not always needed but do it anyway) */
#line 3301
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3301
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3301
      nrange += xp[i] > USHORT_MAX ;
#line 3301
    }
#line 3301
   /* update xpp and tp */
#line 3301
    if (realign) xp = (uint *) *xpp;
#line 3301
    xp += ni;
#line 3301
    tp += ni;
#line 3301
    *xpp = (void*)xp;
#line 3301
  }
#line 3301
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3301

#line 3301
#else   /* not SX */
#line 3301
	const char *xp = (const char *) *xpp;
#line 3301
	int status = NC_NOERR;
#line 3301

#line 3301
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3301
	{
#line 3301
		const int lstatus = ncx_get_uint_ushort(xp, tp);
#line 3301
		if (status == NC_NOERR) /* report the first encountered error */
#line 3301
			status = lstatus;
#line 3301
	}
#line 3301

#line 3301
	*xpp = (const void *)xp;
#line 3301
	return status;
#line 3301
#endif
#line 3301
}
#line 3301

int
#line 3302
ncx_getn_uint_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3302
{
#line 3302
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3302

#line 3302
 /* basic algorithm is:
#line 3302
  *   - ensure sane alignment of input data
#line 3302
  *   - copy (conversion happens automatically) input data
#line 3302
  *     to output
#line 3302
  *   - update xpp to point at next unconverted input, and tp to point
#line 3302
  *     at next location for converted output
#line 3302
  */
#line 3302
  long i, j, ni;
#line 3302
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3302
  uint *xp;
#line 3302
  int nrange = 0;         /* number of range errors */
#line 3302
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3302
  long cxp = (long) *((char**)xpp);
#line 3302

#line 3302
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3302
  /* sjl: manually stripmine so we can limit amount of
#line 3302
   * vector work space reserved to LOOPCNT elements. Also
#line 3302
   * makes vectorisation easy */
#line 3302
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3302
    ni=Min(nelems-j,LOOPCNT);
#line 3302
    if (realign) {
#line 3302
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT));
#line 3302
      xp = tmp;
#line 3302
    } else {
#line 3302
      xp = (uint *) *xpp;
#line 3302
    }
#line 3302
   /* copy the next block */
#line 3302
#pragma cdir loopcnt=LOOPCNT
#line 3302
#pragma cdir shortloop
#line 3302
    for (i=0; i<ni; i++) {
#line 3302
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3302
     /* test for range errors (not always needed but do it anyway) */
#line 3302
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3302
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3302
      nrange += xp[i] > ULONGLONG_MAX ;
#line 3302
    }
#line 3302
   /* update xpp and tp */
#line 3302
    if (realign) xp = (uint *) *xpp;
#line 3302
    xp += ni;
#line 3302
    tp += ni;
#line 3302
    *xpp = (void*)xp;
#line 3302
  }
#line 3302
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3302

#line 3302
#else   /* not SX */
#line 3302
	const char *xp = (const char *) *xpp;
#line 3302
	int status = NC_NOERR;
#line 3302

#line 3302
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3302
	{
#line 3302
		const int lstatus = ncx_get_uint_ulonglong(xp, tp);
#line 3302
		if (status == NC_NOERR) /* report the first encountered error */
#line 3302
			status = lstatus;
#line 3302
	}
#line 3302

#line 3302
	*xpp = (const void *)xp;
#line 3302
	return status;
#line 3302
#endif
#line 3302
}
#line 3302


#if X_SIZEOF_UINT == SIZEOF_UINT
/* optimized version */
int
ncx_putn_uint_uint(void **xpp, size_t nelems, const unsigned int *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_UINT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_UINT);
	return NC_NOERR;
}
#else
int
#line 3318
ncx_putn_uint_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3318
{
#line 3318
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3318

#line 3318
 /* basic algorithm is:
#line 3318
  *   - ensure sane alignment of output data
#line 3318
  *   - copy (conversion happens automatically) input data
#line 3318
  *     to output
#line 3318
  *   - update tp to point at next unconverted input, and xpp to point
#line 3318
  *     at next location for converted output
#line 3318
  */
#line 3318
  long i, j, ni;
#line 3318
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3318
  uint *xp;
#line 3318
  int nrange = 0;         /* number of range errors */
#line 3318
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3318
  long cxp = (long) *((char**)xpp);
#line 3318

#line 3318
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3318
  /* sjl: manually stripmine so we can limit amount of
#line 3318
   * vector work space reserved to LOOPCNT elements. Also
#line 3318
   * makes vectorisation easy */
#line 3318
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3318
    ni=Min(nelems-j,LOOPCNT);
#line 3318
    if (realign) {
#line 3318
      xp = tmp;
#line 3318
    } else {
#line 3318
      xp = (uint *) *xpp;
#line 3318
    }
#line 3318
   /* copy the next block */
#line 3318
#pragma cdir loopcnt=LOOPCNT
#line 3318
#pragma cdir shortloop
#line 3318
    for (i=0; i<ni; i++) {
#line 3318
      /* the normal case: */
#line 3318
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3318
     /* test for range errors (not always needed but do it anyway) */
#line 3318
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3318
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3318
      nrange += tp[i] > X_UINT_MAX ;
#line 3318
    }
#line 3318
   /* copy workspace back if necessary */
#line 3318
    if (realign) {
#line 3318
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3318
      xp = (uint *) *xpp;
#line 3318
    }
#line 3318
   /* update xpp and tp */
#line 3318
    xp += ni;
#line 3318
    tp += ni;
#line 3318
    *xpp = (void*)xp;
#line 3318
  }
#line 3318
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3318

#line 3318
#else   /* not SX */
#line 3318

#line 3318
	char *xp = (char *) *xpp;
#line 3318
	int status = NC_NOERR;
#line 3318

#line 3318
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3318
	{
#line 3318
		int lstatus = ncx_put_uint_uint(xp, tp, fillp);
#line 3318
		if (status == NC_NOERR) /* report the first encountered error */
#line 3318
			status = lstatus;
#line 3318
	}
#line 3318

#line 3318
	*xpp = (void *)xp;
#line 3318
	return status;
#line 3318
#endif
#line 3318
}
#line 3318

#endif
int
#line 3320
ncx_putn_uint_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3320
{
#line 3320
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3320

#line 3320
 /* basic algorithm is:
#line 3320
  *   - ensure sane alignment of output data
#line 3320
  *   - copy (conversion happens automatically) input data
#line 3320
  *     to output
#line 3320
  *   - update tp to point at next unconverted input, and xpp to point
#line 3320
  *     at next location for converted output
#line 3320
  */
#line 3320
  long i, j, ni;
#line 3320
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3320
  uint *xp;
#line 3320
  int nrange = 0;         /* number of range errors */
#line 3320
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3320
  long cxp = (long) *((char**)xpp);
#line 3320

#line 3320
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3320
  /* sjl: manually stripmine so we can limit amount of
#line 3320
   * vector work space reserved to LOOPCNT elements. Also
#line 3320
   * makes vectorisation easy */
#line 3320
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3320
    ni=Min(nelems-j,LOOPCNT);
#line 3320
    if (realign) {
#line 3320
      xp = tmp;
#line 3320
    } else {
#line 3320
      xp = (uint *) *xpp;
#line 3320
    }
#line 3320
   /* copy the next block */
#line 3320
#pragma cdir loopcnt=LOOPCNT
#line 3320
#pragma cdir shortloop
#line 3320
    for (i=0; i<ni; i++) {
#line 3320
      /* the normal case: */
#line 3320
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3320
     /* test for range errors (not always needed but do it anyway) */
#line 3320
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3320
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3320
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3320
    }
#line 3320
   /* copy workspace back if necessary */
#line 3320
    if (realign) {
#line 3320
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3320
      xp = (uint *) *xpp;
#line 3320
    }
#line 3320
   /* update xpp and tp */
#line 3320
    xp += ni;
#line 3320
    tp += ni;
#line 3320
    *xpp = (void*)xp;
#line 3320
  }
#line 3320
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3320

#line 3320
#else   /* not SX */
#line 3320

#line 3320
	char *xp = (char *) *xpp;
#line 3320
	int status = NC_NOERR;
#line 3320

#line 3320
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3320
	{
#line 3320
		int lstatus = ncx_put_uint_schar(xp, tp, fillp);
#line 3320
		if (status == NC_NOERR) /* report the first encountered error */
#line 3320
			status = lstatus;
#line 3320
	}
#line 3320

#line 3320
	*xpp = (void *)xp;
#line 3320
	return status;
#line 3320
#endif
#line 3320
}
#line 3320

int
#line 3321
ncx_putn_uint_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3321
{
#line 3321
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3321

#line 3321
 /* basic algorithm is:
#line 3321
  *   - ensure sane alignment of output data
#line 3321
  *   - copy (conversion happens automatically) input data
#line 3321
  *     to output
#line 3321
  *   - update tp to point at next unconverted input, and xpp to point
#line 3321
  *     at next location for converted output
#line 3321
  */
#line 3321
  long i, j, ni;
#line 3321
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3321
  uint *xp;
#line 3321
  int nrange = 0;         /* number of range errors */
#line 3321
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3321
  long cxp = (long) *((char**)xpp);
#line 3321

#line 3321
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3321
  /* sjl: manually stripmine so we can limit amount of
#line 3321
   * vector work space reserved to LOOPCNT elements. Also
#line 3321
   * makes vectorisation easy */
#line 3321
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3321
    ni=Min(nelems-j,LOOPCNT);
#line 3321
    if (realign) {
#line 3321
      xp = tmp;
#line 3321
    } else {
#line 3321
      xp = (uint *) *xpp;
#line 3321
    }
#line 3321
   /* copy the next block */
#line 3321
#pragma cdir loopcnt=LOOPCNT
#line 3321
#pragma cdir shortloop
#line 3321
    for (i=0; i<ni; i++) {
#line 3321
      /* the normal case: */
#line 3321
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3321
     /* test for range errors (not always needed but do it anyway) */
#line 3321
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3321
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3321
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3321
    }
#line 3321
   /* copy workspace back if necessary */
#line 3321
    if (realign) {
#line 3321
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3321
      xp = (uint *) *xpp;
#line 3321
    }
#line 3321
   /* update xpp and tp */
#line 3321
    xp += ni;
#line 3321
    tp += ni;
#line 3321
    *xpp = (void*)xp;
#line 3321
  }
#line 3321
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3321

#line 3321
#else   /* not SX */
#line 3321

#line 3321
	char *xp = (char *) *xpp;
#line 3321
	int status = NC_NOERR;
#line 3321

#line 3321
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3321
	{
#line 3321
		int lstatus = ncx_put_uint_short(xp, tp, fillp);
#line 3321
		if (status == NC_NOERR) /* report the first encountered error */
#line 3321
			status = lstatus;
#line 3321
	}
#line 3321

#line 3321
	*xpp = (void *)xp;
#line 3321
	return status;
#line 3321
#endif
#line 3321
}
#line 3321

int
#line 3322
ncx_putn_uint_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3322
{
#line 3322
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3322

#line 3322
 /* basic algorithm is:
#line 3322
  *   - ensure sane alignment of output data
#line 3322
  *   - copy (conversion happens automatically) input data
#line 3322
  *     to output
#line 3322
  *   - update tp to point at next unconverted input, and xpp to point
#line 3322
  *     at next location for converted output
#line 3322
  */
#line 3322
  long i, j, ni;
#line 3322
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3322
  uint *xp;
#line 3322
  int nrange = 0;         /* number of range errors */
#line 3322
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3322
  long cxp = (long) *((char**)xpp);
#line 3322

#line 3322
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3322
  /* sjl: manually stripmine so we can limit amount of
#line 3322
   * vector work space reserved to LOOPCNT elements. Also
#line 3322
   * makes vectorisation easy */
#line 3322
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3322
    ni=Min(nelems-j,LOOPCNT);
#line 3322
    if (realign) {
#line 3322
      xp = tmp;
#line 3322
    } else {
#line 3322
      xp = (uint *) *xpp;
#line 3322
    }
#line 3322
   /* copy the next block */
#line 3322
#pragma cdir loopcnt=LOOPCNT
#line 3322
#pragma cdir shortloop
#line 3322
    for (i=0; i<ni; i++) {
#line 3322
      /* the normal case: */
#line 3322
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3322
     /* test for range errors (not always needed but do it anyway) */
#line 3322
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3322
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3322
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3322
    }
#line 3322
   /* copy workspace back if necessary */
#line 3322
    if (realign) {
#line 3322
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3322
      xp = (uint *) *xpp;
#line 3322
    }
#line 3322
   /* update xpp and tp */
#line 3322
    xp += ni;
#line 3322
    tp += ni;
#line 3322
    *xpp = (void*)xp;
#line 3322
  }
#line 3322
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3322

#line 3322
#else   /* not SX */
#line 3322

#line 3322
	char *xp = (char *) *xpp;
#line 3322
	int status = NC_NOERR;
#line 3322

#line 3322
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3322
	{
#line 3322
		int lstatus = ncx_put_uint_int(xp, tp, fillp);
#line 3322
		if (status == NC_NOERR) /* report the first encountered error */
#line 3322
			status = lstatus;
#line 3322
	}
#line 3322

#line 3322
	*xpp = (void *)xp;
#line 3322
	return status;
#line 3322
#endif
#line 3322
}
#line 3322

int
#line 3323
ncx_putn_uint_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3323
{
#line 3323
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3323

#line 3323
 /* basic algorithm is:
#line 3323
  *   - ensure sane alignment of output data
#line 3323
  *   - copy (conversion happens automatically) input data
#line 3323
  *     to output
#line 3323
  *   - update tp to point at next unconverted input, and xpp to point
#line 3323
  *     at next location for converted output
#line 3323
  */
#line 3323
  long i, j, ni;
#line 3323
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3323
  uint *xp;
#line 3323
  int nrange = 0;         /* number of range errors */
#line 3323
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3323
  long cxp = (long) *((char**)xpp);
#line 3323

#line 3323
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3323
  /* sjl: manually stripmine so we can limit amount of
#line 3323
   * vector work space reserved to LOOPCNT elements. Also
#line 3323
   * makes vectorisation easy */
#line 3323
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3323
    ni=Min(nelems-j,LOOPCNT);
#line 3323
    if (realign) {
#line 3323
      xp = tmp;
#line 3323
    } else {
#line 3323
      xp = (uint *) *xpp;
#line 3323
    }
#line 3323
   /* copy the next block */
#line 3323
#pragma cdir loopcnt=LOOPCNT
#line 3323
#pragma cdir shortloop
#line 3323
    for (i=0; i<ni; i++) {
#line 3323
      /* the normal case: */
#line 3323
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3323
     /* test for range errors (not always needed but do it anyway) */
#line 3323
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3323
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3323
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3323
    }
#line 3323
   /* copy workspace back if necessary */
#line 3323
    if (realign) {
#line 3323
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3323
      xp = (uint *) *xpp;
#line 3323
    }
#line 3323
   /* update xpp and tp */
#line 3323
    xp += ni;
#line 3323
    tp += ni;
#line 3323
    *xpp = (void*)xp;
#line 3323
  }
#line 3323
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3323

#line 3323
#else   /* not SX */
#line 3323

#line 3323
	char *xp = (char *) *xpp;
#line 3323
	int status = NC_NOERR;
#line 3323

#line 3323
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3323
	{
#line 3323
		int lstatus = ncx_put_uint_long(xp, tp, fillp);
#line 3323
		if (status == NC_NOERR) /* report the first encountered error */
#line 3323
			status = lstatus;
#line 3323
	}
#line 3323

#line 3323
	*xpp = (void *)xp;
#line 3323
	return status;
#line 3323
#endif
#line 3323
}
#line 3323

int
#line 3324
ncx_putn_uint_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3324
{
#line 3324
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3324

#line 3324
 /* basic algorithm is:
#line 3324
  *   - ensure sane alignment of output data
#line 3324
  *   - copy (conversion happens automatically) input data
#line 3324
  *     to output
#line 3324
  *   - update tp to point at next unconverted input, and xpp to point
#line 3324
  *     at next location for converted output
#line 3324
  */
#line 3324
  long i, j, ni;
#line 3324
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3324
  uint *xp;
#line 3324
  int nrange = 0;         /* number of range errors */
#line 3324
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3324
  long cxp = (long) *((char**)xpp);
#line 3324

#line 3324
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3324
  /* sjl: manually stripmine so we can limit amount of
#line 3324
   * vector work space reserved to LOOPCNT elements. Also
#line 3324
   * makes vectorisation easy */
#line 3324
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3324
    ni=Min(nelems-j,LOOPCNT);
#line 3324
    if (realign) {
#line 3324
      xp = tmp;
#line 3324
    } else {
#line 3324
      xp = (uint *) *xpp;
#line 3324
    }
#line 3324
   /* copy the next block */
#line 3324
#pragma cdir loopcnt=LOOPCNT
#line 3324
#pragma cdir shortloop
#line 3324
    for (i=0; i<ni; i++) {
#line 3324
      /* the normal case: */
#line 3324
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3324
     /* test for range errors (not always needed but do it anyway) */
#line 3324
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3324
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3324
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3324
    }
#line 3324
   /* copy workspace back if necessary */
#line 3324
    if (realign) {
#line 3324
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3324
      xp = (uint *) *xpp;
#line 3324
    }
#line 3324
   /* update xpp and tp */
#line 3324
    xp += ni;
#line 3324
    tp += ni;
#line 3324
    *xpp = (void*)xp;
#line 3324
  }
#line 3324
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3324

#line 3324
#else   /* not SX */
#line 3324

#line 3324
	char *xp = (char *) *xpp;
#line 3324
	int status = NC_NOERR;
#line 3324

#line 3324
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3324
	{
#line 3324
		int lstatus = ncx_put_uint_float(xp, tp, fillp);
#line 3324
		if (status == NC_NOERR) /* report the first encountered error */
#line 3324
			status = lstatus;
#line 3324
	}
#line 3324

#line 3324
	*xpp = (void *)xp;
#line 3324
	return status;
#line 3324
#endif
#line 3324
}
#line 3324

int
#line 3325
ncx_putn_uint_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3325
{
#line 3325
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3325

#line 3325
 /* basic algorithm is:
#line 3325
  *   - ensure sane alignment of output data
#line 3325
  *   - copy (conversion happens automatically) input data
#line 3325
  *     to output
#line 3325
  *   - update tp to point at next unconverted input, and xpp to point
#line 3325
  *     at next location for converted output
#line 3325
  */
#line 3325
  long i, j, ni;
#line 3325
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3325
  uint *xp;
#line 3325
  int nrange = 0;         /* number of range errors */
#line 3325
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3325
  long cxp = (long) *((char**)xpp);
#line 3325

#line 3325
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3325
  /* sjl: manually stripmine so we can limit amount of
#line 3325
   * vector work space reserved to LOOPCNT elements. Also
#line 3325
   * makes vectorisation easy */
#line 3325
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3325
    ni=Min(nelems-j,LOOPCNT);
#line 3325
    if (realign) {
#line 3325
      xp = tmp;
#line 3325
    } else {
#line 3325
      xp = (uint *) *xpp;
#line 3325
    }
#line 3325
   /* copy the next block */
#line 3325
#pragma cdir loopcnt=LOOPCNT
#line 3325
#pragma cdir shortloop
#line 3325
    for (i=0; i<ni; i++) {
#line 3325
      /* the normal case: */
#line 3325
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3325
     /* test for range errors (not always needed but do it anyway) */
#line 3325
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3325
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3325
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3325
    }
#line 3325
   /* copy workspace back if necessary */
#line 3325
    if (realign) {
#line 3325
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3325
      xp = (uint *) *xpp;
#line 3325
    }
#line 3325
   /* update xpp and tp */
#line 3325
    xp += ni;
#line 3325
    tp += ni;
#line 3325
    *xpp = (void*)xp;
#line 3325
  }
#line 3325
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3325

#line 3325
#else   /* not SX */
#line 3325

#line 3325
	char *xp = (char *) *xpp;
#line 3325
	int status = NC_NOERR;
#line 3325

#line 3325
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3325
	{
#line 3325
		int lstatus = ncx_put_uint_double(xp, tp, fillp);
#line 3325
		if (status == NC_NOERR) /* report the first encountered error */
#line 3325
			status = lstatus;
#line 3325
	}
#line 3325

#line 3325
	*xpp = (void *)xp;
#line 3325
	return status;
#line 3325
#endif
#line 3325
}
#line 3325

int
#line 3326
ncx_putn_uint_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3326
{
#line 3326
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3326

#line 3326
 /* basic algorithm is:
#line 3326
  *   - ensure sane alignment of output data
#line 3326
  *   - copy (conversion happens automatically) input data
#line 3326
  *     to output
#line 3326
  *   - update tp to point at next unconverted input, and xpp to point
#line 3326
  *     at next location for converted output
#line 3326
  */
#line 3326
  long i, j, ni;
#line 3326
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3326
  uint *xp;
#line 3326
  int nrange = 0;         /* number of range errors */
#line 3326
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3326
  long cxp = (long) *((char**)xpp);
#line 3326

#line 3326
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3326
  /* sjl: manually stripmine so we can limit amount of
#line 3326
   * vector work space reserved to LOOPCNT elements. Also
#line 3326
   * makes vectorisation easy */
#line 3326
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3326
    ni=Min(nelems-j,LOOPCNT);
#line 3326
    if (realign) {
#line 3326
      xp = tmp;
#line 3326
    } else {
#line 3326
      xp = (uint *) *xpp;
#line 3326
    }
#line 3326
   /* copy the next block */
#line 3326
#pragma cdir loopcnt=LOOPCNT
#line 3326
#pragma cdir shortloop
#line 3326
    for (i=0; i<ni; i++) {
#line 3326
      /* the normal case: */
#line 3326
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3326
     /* test for range errors (not always needed but do it anyway) */
#line 3326
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3326
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3326
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3326
    }
#line 3326
   /* copy workspace back if necessary */
#line 3326
    if (realign) {
#line 3326
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3326
      xp = (uint *) *xpp;
#line 3326
    }
#line 3326
   /* update xpp and tp */
#line 3326
    xp += ni;
#line 3326
    tp += ni;
#line 3326
    *xpp = (void*)xp;
#line 3326
  }
#line 3326
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3326

#line 3326
#else   /* not SX */
#line 3326

#line 3326
	char *xp = (char *) *xpp;
#line 3326
	int status = NC_NOERR;
#line 3326

#line 3326
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3326
	{
#line 3326
		int lstatus = ncx_put_uint_longlong(xp, tp, fillp);
#line 3326
		if (status == NC_NOERR) /* report the first encountered error */
#line 3326
			status = lstatus;
#line 3326
	}
#line 3326

#line 3326
	*xpp = (void *)xp;
#line 3326
	return status;
#line 3326
#endif
#line 3326
}
#line 3326

int
#line 3327
ncx_putn_uint_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3327
{
#line 3327
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3327

#line 3327
 /* basic algorithm is:
#line 3327
  *   - ensure sane alignment of output data
#line 3327
  *   - copy (conversion happens automatically) input data
#line 3327
  *     to output
#line 3327
  *   - update tp to point at next unconverted input, and xpp to point
#line 3327
  *     at next location for converted output
#line 3327
  */
#line 3327
  long i, j, ni;
#line 3327
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3327
  uint *xp;
#line 3327
  int nrange = 0;         /* number of range errors */
#line 3327
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3327
  long cxp = (long) *((char**)xpp);
#line 3327

#line 3327
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3327
  /* sjl: manually stripmine so we can limit amount of
#line 3327
   * vector work space reserved to LOOPCNT elements. Also
#line 3327
   * makes vectorisation easy */
#line 3327
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3327
    ni=Min(nelems-j,LOOPCNT);
#line 3327
    if (realign) {
#line 3327
      xp = tmp;
#line 3327
    } else {
#line 3327
      xp = (uint *) *xpp;
#line 3327
    }
#line 3327
   /* copy the next block */
#line 3327
#pragma cdir loopcnt=LOOPCNT
#line 3327
#pragma cdir shortloop
#line 3327
    for (i=0; i<ni; i++) {
#line 3327
      /* the normal case: */
#line 3327
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3327
     /* test for range errors (not always needed but do it anyway) */
#line 3327
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3327
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3327
      nrange += tp[i] > X_UINT_MAX ;
#line 3327
    }
#line 3327
   /* copy workspace back if necessary */
#line 3327
    if (realign) {
#line 3327
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3327
      xp = (uint *) *xpp;
#line 3327
    }
#line 3327
   /* update xpp and tp */
#line 3327
    xp += ni;
#line 3327
    tp += ni;
#line 3327
    *xpp = (void*)xp;
#line 3327
  }
#line 3327
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3327

#line 3327
#else   /* not SX */
#line 3327

#line 3327
	char *xp = (char *) *xpp;
#line 3327
	int status = NC_NOERR;
#line 3327

#line 3327
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3327
	{
#line 3327
		int lstatus = ncx_put_uint_uchar(xp, tp, fillp);
#line 3327
		if (status == NC_NOERR) /* report the first encountered error */
#line 3327
			status = lstatus;
#line 3327
	}
#line 3327

#line 3327
	*xpp = (void *)xp;
#line 3327
	return status;
#line 3327
#endif
#line 3327
}
#line 3327

int
#line 3328
ncx_putn_uint_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3328
{
#line 3328
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3328

#line 3328
 /* basic algorithm is:
#line 3328
  *   - ensure sane alignment of output data
#line 3328
  *   - copy (conversion happens automatically) input data
#line 3328
  *     to output
#line 3328
  *   - update tp to point at next unconverted input, and xpp to point
#line 3328
  *     at next location for converted output
#line 3328
  */
#line 3328
  long i, j, ni;
#line 3328
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3328
  uint *xp;
#line 3328
  int nrange = 0;         /* number of range errors */
#line 3328
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3328
  long cxp = (long) *((char**)xpp);
#line 3328

#line 3328
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3328
  /* sjl: manually stripmine so we can limit amount of
#line 3328
   * vector work space reserved to LOOPCNT elements. Also
#line 3328
   * makes vectorisation easy */
#line 3328
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3328
    ni=Min(nelems-j,LOOPCNT);
#line 3328
    if (realign) {
#line 3328
      xp = tmp;
#line 3328
    } else {
#line 3328
      xp = (uint *) *xpp;
#line 3328
    }
#line 3328
   /* copy the next block */
#line 3328
#pragma cdir loopcnt=LOOPCNT
#line 3328
#pragma cdir shortloop
#line 3328
    for (i=0; i<ni; i++) {
#line 3328
      /* the normal case: */
#line 3328
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3328
     /* test for range errors (not always needed but do it anyway) */
#line 3328
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3328
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3328
      nrange += tp[i] > X_UINT_MAX ;
#line 3328
    }
#line 3328
   /* copy workspace back if necessary */
#line 3328
    if (realign) {
#line 3328
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3328
      xp = (uint *) *xpp;
#line 3328
    }
#line 3328
   /* update xpp and tp */
#line 3328
    xp += ni;
#line 3328
    tp += ni;
#line 3328
    *xpp = (void*)xp;
#line 3328
  }
#line 3328
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3328

#line 3328
#else   /* not SX */
#line 3328

#line 3328
	char *xp = (char *) *xpp;
#line 3328
	int status = NC_NOERR;
#line 3328

#line 3328
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3328
	{
#line 3328
		int lstatus = ncx_put_uint_ushort(xp, tp, fillp);
#line 3328
		if (status == NC_NOERR) /* report the first encountered error */
#line 3328
			status = lstatus;
#line 3328
	}
#line 3328

#line 3328
	*xpp = (void *)xp;
#line 3328
	return status;
#line 3328
#endif
#line 3328
}
#line 3328

int
#line 3329
ncx_putn_uint_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3329
{
#line 3329
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT == SIZEOF_UINT
#line 3329

#line 3329
 /* basic algorithm is:
#line 3329
  *   - ensure sane alignment of output data
#line 3329
  *   - copy (conversion happens automatically) input data
#line 3329
  *     to output
#line 3329
  *   - update tp to point at next unconverted input, and xpp to point
#line 3329
  *     at next location for converted output
#line 3329
  */
#line 3329
  long i, j, ni;
#line 3329
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3329
  uint *xp;
#line 3329
  int nrange = 0;         /* number of range errors */
#line 3329
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3329
  long cxp = (long) *((char**)xpp);
#line 3329

#line 3329
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3329
  /* sjl: manually stripmine so we can limit amount of
#line 3329
   * vector work space reserved to LOOPCNT elements. Also
#line 3329
   * makes vectorisation easy */
#line 3329
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3329
    ni=Min(nelems-j,LOOPCNT);
#line 3329
    if (realign) {
#line 3329
      xp = tmp;
#line 3329
    } else {
#line 3329
      xp = (uint *) *xpp;
#line 3329
    }
#line 3329
   /* copy the next block */
#line 3329
#pragma cdir loopcnt=LOOPCNT
#line 3329
#pragma cdir shortloop
#line 3329
    for (i=0; i<ni; i++) {
#line 3329
      /* the normal case: */
#line 3329
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3329
     /* test for range errors (not always needed but do it anyway) */
#line 3329
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3329
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3329
      nrange += tp[i] > X_UINT_MAX ;
#line 3329
    }
#line 3329
   /* copy workspace back if necessary */
#line 3329
    if (realign) {
#line 3329
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT);
#line 3329
      xp = (uint *) *xpp;
#line 3329
    }
#line 3329
   /* update xpp and tp */
#line 3329
    xp += ni;
#line 3329
    tp += ni;
#line 3329
    *xpp = (void*)xp;
#line 3329
  }
#line 3329
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3329

#line 3329
#else   /* not SX */
#line 3329

#line 3329
	char *xp = (char *) *xpp;
#line 3329
	int status = NC_NOERR;
#line 3329

#line 3329
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3329
	{
#line 3329
		int lstatus = ncx_put_uint_ulonglong(xp, tp, fillp);
#line 3329
		if (status == NC_NOERR) /* report the first encountered error */
#line 3329
			status = lstatus;
#line 3329
	}
#line 3329

#line 3329
	*xpp = (void *)xp;
#line 3329
	return status;
#line 3329
#endif
#line 3329
}
#line 3329



/* float ---------------------------------------------------------------------*/

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_FLOAT);
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return NC_NOERR;
}
#elif defined(vax) && vax != 0
int
ncx_getn_float_float(const void **xpp, size_t nfloats, float *ip)
{
	float *const end = ip + nfloats;

	while (ip < end)
	{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 3355
		const struct ieee_single *const isp =
#line 3355
			 (const struct ieee_single *) (*xpp);
#line 3355
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 3355

#line 3355
		switch(exp) {
#line 3355
		case 0 :
#line 3355
			/* ieee subnormal */
#line 3355
			if (isp->mant_hi == min.ieee.mant_hi
#line 3355
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 3355
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 3355
			{
#line 3355
				*vsp = min.s;
#line 3355
			}
#line 3355
			else
#line 3355
			{
#line 3355
				unsigned mantissa = (isp->mant_hi << 16)
#line 3355
					 | isp->mant_lo_hi << 8
#line 3355
					 | isp->mant_lo_lo;
#line 3355
				unsigned tmp = mantissa >> 20;
#line 3355
				if (tmp >= 4) {
#line 3355
					vsp->exp = 2;
#line 3355
				} else if (tmp >= 2) {
#line 3355
					vsp->exp = 1;
#line 3355
				} else {
#line 3355
					*vsp = min.s;
#line 3355
					break;
#line 3355
				} /* else */
#line 3355
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 3355
				tmp <<= 3 - vsp->exp;
#line 3355
				vsp->mantissa2 = tmp;
#line 3355
				vsp->mantissa1 = (tmp >> 16);
#line 3355
			}
#line 3355
			break;
#line 3355
		case 0xfe :
#line 3355
		case 0xff :
#line 3355
			*vsp = max.s;
#line 3355
			break;
#line 3355
		default :
#line 3355
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 3355
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 3355
			vsp->mantissa1 = isp->mant_hi;
#line 3355
		}
#line 3355

#line 3355
		vsp->sign = isp->sign;
#line 3355


		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return NC_NOERR;
}
#else
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
	const char *xp = *xpp;
	int status = NC_NOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
	{
		const int lstatus = ncx_get_float_float(xp, tp, fillp);
		if (status == NC_NOERR) /* report the first encountered error */
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}

#endif
int
#line 3381
ncx_getn_float_schar(const void **xpp, size_t nelems, schar *tp)
#line 3381
{
#line 3381
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3381

#line 3381
 /* basic algorithm is:
#line 3381
  *   - ensure sane alignment of input data
#line 3381
  *   - copy (conversion happens automatically) input data
#line 3381
  *     to output
#line 3381
  *   - update xpp to point at next unconverted input, and tp to point
#line 3381
  *     at next location for converted output
#line 3381
  */
#line 3381
  long i, j, ni;
#line 3381
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3381
  float *xp;
#line 3381
  int nrange = 0;         /* number of range errors */
#line 3381
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3381
  long cxp = (long) *((char**)xpp);
#line 3381

#line 3381
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3381
  /* sjl: manually stripmine so we can limit amount of
#line 3381
   * vector work space reserved to LOOPCNT elements. Also
#line 3381
   * makes vectorisation easy */
#line 3381
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3381
    ni=Min(nelems-j,LOOPCNT);
#line 3381
    if (realign) {
#line 3381
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3381
      xp = tmp;
#line 3381
    } else {
#line 3381
      xp = (float *) *xpp;
#line 3381
    }
#line 3381
   /* copy the next block */
#line 3381
#pragma cdir loopcnt=LOOPCNT
#line 3381
#pragma cdir shortloop
#line 3381
    for (i=0; i<ni; i++) {
#line 3381
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3381
     /* test for range errors (not always needed but do it anyway) */
#line 3381
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3381
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3381
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3381
    }
#line 3381
   /* update xpp and tp */
#line 3381
    if (realign) xp = (float *) *xpp;
#line 3381
    xp += ni;
#line 3381
    tp += ni;
#line 3381
    *xpp = (void*)xp;
#line 3381
  }
#line 3381
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3381

#line 3381
#else   /* not SX */
#line 3381
	const char *xp = (const char *) *xpp;
#line 3381
	int status = NC_NOERR;
#line 3381

#line 3381
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3381
	{
#line 3381
		const int lstatus = ncx_get_float_schar(xp, tp);
#line 3381
		if (status == NC_NOERR) /* report the first encountered error */
#line 3381
			status = lstatus;
#line 3381
	}
#line 3381

#line 3381
	*xpp = (const void *)xp;
#line 3381
	return status;
#line 3381
#endif
#line 3381
}
#line 3381

int
#line 3382
ncx_getn_float_short(const void **xpp, size_t nelems, short *tp)
#line 3382
{
#line 3382
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3382

#line 3382
 /* basic algorithm is:
#line 3382
  *   - ensure sane alignment of input data
#line 3382
  *   - copy (conversion happens automatically) input data
#line 3382
  *     to output
#line 3382
  *   - update xpp to point at next unconverted input, and tp to point
#line 3382
  *     at next location for converted output
#line 3382
  */
#line 3382
  long i, j, ni;
#line 3382
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3382
  float *xp;
#line 3382
  int nrange = 0;         /* number of range errors */
#line 3382
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3382
  long cxp = (long) *((char**)xpp);
#line 3382

#line 3382
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3382
  /* sjl: manually stripmine so we can limit amount of
#line 3382
   * vector work space reserved to LOOPCNT elements. Also
#line 3382
   * makes vectorisation easy */
#line 3382
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3382
    ni=Min(nelems-j,LOOPCNT);
#line 3382
    if (realign) {
#line 3382
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3382
      xp = tmp;
#line 3382
    } else {
#line 3382
      xp = (float *) *xpp;
#line 3382
    }
#line 3382
   /* copy the next block */
#line 3382
#pragma cdir loopcnt=LOOPCNT
#line 3382
#pragma cdir shortloop
#line 3382
    for (i=0; i<ni; i++) {
#line 3382
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3382
     /* test for range errors (not always needed but do it anyway) */
#line 3382
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3382
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3382
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3382
    }
#line 3382
   /* update xpp and tp */
#line 3382
    if (realign) xp = (float *) *xpp;
#line 3382
    xp += ni;
#line 3382
    tp += ni;
#line 3382
    *xpp = (void*)xp;
#line 3382
  }
#line 3382
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3382

#line 3382
#else   /* not SX */
#line 3382
	const char *xp = (const char *) *xpp;
#line 3382
	int status = NC_NOERR;
#line 3382

#line 3382
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3382
	{
#line 3382
		const int lstatus = ncx_get_float_short(xp, tp);
#line 3382
		if (status == NC_NOERR) /* report the first encountered error */
#line 3382
			status = lstatus;
#line 3382
	}
#line 3382

#line 3382
	*xpp = (const void *)xp;
#line 3382
	return status;
#line 3382
#endif
#line 3382
}
#line 3382

int
#line 3383
ncx_getn_float_int(const void **xpp, size_t nelems, int *tp)
#line 3383
{
#line 3383
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3383

#line 3383
 /* basic algorithm is:
#line 3383
  *   - ensure sane alignment of input data
#line 3383
  *   - copy (conversion happens automatically) input data
#line 3383
  *     to output
#line 3383
  *   - update xpp to point at next unconverted input, and tp to point
#line 3383
  *     at next location for converted output
#line 3383
  */
#line 3383
  long i, j, ni;
#line 3383
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3383
  float *xp;
#line 3383
  int nrange = 0;         /* number of range errors */
#line 3383
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3383
  long cxp = (long) *((char**)xpp);
#line 3383

#line 3383
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3383
  /* sjl: manually stripmine so we can limit amount of
#line 3383
   * vector work space reserved to LOOPCNT elements. Also
#line 3383
   * makes vectorisation easy */
#line 3383
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3383
    ni=Min(nelems-j,LOOPCNT);
#line 3383
    if (realign) {
#line 3383
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3383
      xp = tmp;
#line 3383
    } else {
#line 3383
      xp = (float *) *xpp;
#line 3383
    }
#line 3383
   /* copy the next block */
#line 3383
#pragma cdir loopcnt=LOOPCNT
#line 3383
#pragma cdir shortloop
#line 3383
    for (i=0; i<ni; i++) {
#line 3383
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3383
     /* test for range errors (not always needed but do it anyway) */
#line 3383
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3383
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3383
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3383
    }
#line 3383
   /* update xpp and tp */
#line 3383
    if (realign) xp = (float *) *xpp;
#line 3383
    xp += ni;
#line 3383
    tp += ni;
#line 3383
    *xpp = (void*)xp;
#line 3383
  }
#line 3383
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3383

#line 3383
#else   /* not SX */
#line 3383
	const char *xp = (const char *) *xpp;
#line 3383
	int status = NC_NOERR;
#line 3383

#line 3383
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3383
	{
#line 3383
		const int lstatus = ncx_get_float_int(xp, tp);
#line 3383
		if (status == NC_NOERR) /* report the first encountered error */
#line 3383
			status = lstatus;
#line 3383
	}
#line 3383

#line 3383
	*xpp = (const void *)xp;
#line 3383
	return status;
#line 3383
#endif
#line 3383
}
#line 3383

int
#line 3384
ncx_getn_float_long(const void **xpp, size_t nelems, long *tp)
#line 3384
{
#line 3384
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3384

#line 3384
 /* basic algorithm is:
#line 3384
  *   - ensure sane alignment of input data
#line 3384
  *   - copy (conversion happens automatically) input data
#line 3384
  *     to output
#line 3384
  *   - update xpp to point at next unconverted input, and tp to point
#line 3384
  *     at next location for converted output
#line 3384
  */
#line 3384
  long i, j, ni;
#line 3384
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3384
  float *xp;
#line 3384
  int nrange = 0;         /* number of range errors */
#line 3384
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3384
  long cxp = (long) *((char**)xpp);
#line 3384

#line 3384
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3384
  /* sjl: manually stripmine so we can limit amount of
#line 3384
   * vector work space reserved to LOOPCNT elements. Also
#line 3384
   * makes vectorisation easy */
#line 3384
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3384
    ni=Min(nelems-j,LOOPCNT);
#line 3384
    if (realign) {
#line 3384
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3384
      xp = tmp;
#line 3384
    } else {
#line 3384
      xp = (float *) *xpp;
#line 3384
    }
#line 3384
   /* copy the next block */
#line 3384
#pragma cdir loopcnt=LOOPCNT
#line 3384
#pragma cdir shortloop
#line 3384
    for (i=0; i<ni; i++) {
#line 3384
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3384
     /* test for range errors (not always needed but do it anyway) */
#line 3384
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3384
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3384
      nrange += xp[i] > LONG_MAX || xp[i] < LONG_MIN;
#line 3384
    }
#line 3384
   /* update xpp and tp */
#line 3384
    if (realign) xp = (float *) *xpp;
#line 3384
    xp += ni;
#line 3384
    tp += ni;
#line 3384
    *xpp = (void*)xp;
#line 3384
  }
#line 3384
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3384

#line 3384
#else   /* not SX */
#line 3384
	const char *xp = (const char *) *xpp;
#line 3384
	int status = NC_NOERR;
#line 3384

#line 3384
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3384
	{
#line 3384
		const int lstatus = ncx_get_float_long(xp, tp);
#line 3384
		if (status == NC_NOERR) /* report the first encountered error */
#line 3384
			status = lstatus;
#line 3384
	}
#line 3384

#line 3384
	*xpp = (const void *)xp;
#line 3384
	return status;
#line 3384
#endif
#line 3384
}
#line 3384

int
#line 3385
ncx_getn_float_double(const void **xpp, size_t nelems, double *tp)
#line 3385
{
#line 3385
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3385

#line 3385
 /* basic algorithm is:
#line 3385
  *   - ensure sane alignment of input data
#line 3385
  *   - copy (conversion happens automatically) input data
#line 3385
  *     to output
#line 3385
  *   - update xpp to point at next unconverted input, and tp to point
#line 3385
  *     at next location for converted output
#line 3385
  */
#line 3385
  long i, j, ni;
#line 3385
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3385
  float *xp;
#line 3385
  int nrange = 0;         /* number of range errors */
#line 3385
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3385
  long cxp = (long) *((char**)xpp);
#line 3385

#line 3385
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3385
  /* sjl: manually stripmine so we can limit amount of
#line 3385
   * vector work space reserved to LOOPCNT elements. Also
#line 3385
   * makes vectorisation easy */
#line 3385
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3385
    ni=Min(nelems-j,LOOPCNT);
#line 3385
    if (realign) {
#line 3385
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3385
      xp = tmp;
#line 3385
    } else {
#line 3385
      xp = (float *) *xpp;
#line 3385
    }
#line 3385
   /* copy the next block */
#line 3385
#pragma cdir loopcnt=LOOPCNT
#line 3385
#pragma cdir shortloop
#line 3385
    for (i=0; i<ni; i++) {
#line 3385
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3385
     /* test for range errors (not always needed but do it anyway) */
#line 3385
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3385
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3385
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3385
    }
#line 3385
   /* update xpp and tp */
#line 3385
    if (realign) xp = (float *) *xpp;
#line 3385
    xp += ni;
#line 3385
    tp += ni;
#line 3385
    *xpp = (void*)xp;
#line 3385
  }
#line 3385
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3385

#line 3385
#else   /* not SX */
#line 3385
	const char *xp = (const char *) *xpp;
#line 3385
	int status = NC_NOERR;
#line 3385

#line 3385
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3385
	{
#line 3385
		const int lstatus = ncx_get_float_double(xp, tp);
#line 3385
		if (status == NC_NOERR) /* report the first encountered error */
#line 3385
			status = lstatus;
#line 3385
	}
#line 3385

#line 3385
	*xpp = (const void *)xp;
#line 3385
	return status;
#line 3385
#endif
#line 3385
}
#line 3385

int
#line 3386
ncx_getn_float_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3386
{
#line 3386
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3386

#line 3386
 /* basic algorithm is:
#line 3386
  *   - ensure sane alignment of input data
#line 3386
  *   - copy (conversion happens automatically) input data
#line 3386
  *     to output
#line 3386
  *   - update xpp to point at next unconverted input, and tp to point
#line 3386
  *     at next location for converted output
#line 3386
  */
#line 3386
  long i, j, ni;
#line 3386
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3386
  float *xp;
#line 3386
  int nrange = 0;         /* number of range errors */
#line 3386
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3386
  long cxp = (long) *((char**)xpp);
#line 3386

#line 3386
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3386
  /* sjl: manually stripmine so we can limit amount of
#line 3386
   * vector work space reserved to LOOPCNT elements. Also
#line 3386
   * makes vectorisation easy */
#line 3386
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3386
    ni=Min(nelems-j,LOOPCNT);
#line 3386
    if (realign) {
#line 3386
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3386
      xp = tmp;
#line 3386
    } else {
#line 3386
      xp = (float *) *xpp;
#line 3386
    }
#line 3386
   /* copy the next block */
#line 3386
#pragma cdir loopcnt=LOOPCNT
#line 3386
#pragma cdir shortloop
#line 3386
    for (i=0; i<ni; i++) {
#line 3386
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3386
     /* test for range errors (not always needed but do it anyway) */
#line 3386
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3386
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3386
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3386
    }
#line 3386
   /* update xpp and tp */
#line 3386
    if (realign) xp = (float *) *xpp;
#line 3386
    xp += ni;
#line 3386
    tp += ni;
#line 3386
    *xpp = (void*)xp;
#line 3386
  }
#line 3386
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3386

#line 3386
#else   /* not SX */
#line 3386
	const char *xp = (const char *) *xpp;
#line 3386
	int status = NC_NOERR;
#line 3386

#line 3386
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3386
	{
#line 3386
		const int lstatus = ncx_get_float_longlong(xp, tp);
#line 3386
		if (status == NC_NOERR) /* report the first encountered error */
#line 3386
			status = lstatus;
#line 3386
	}
#line 3386

#line 3386
	*xpp = (const void *)xp;
#line 3386
	return status;
#line 3386
#endif
#line 3386
}
#line 3386

int
#line 3387
ncx_getn_float_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3387
{
#line 3387
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3387

#line 3387
 /* basic algorithm is:
#line 3387
  *   - ensure sane alignment of input data
#line 3387
  *   - copy (conversion happens automatically) input data
#line 3387
  *     to output
#line 3387
  *   - update xpp to point at next unconverted input, and tp to point
#line 3387
  *     at next location for converted output
#line 3387
  */
#line 3387
  long i, j, ni;
#line 3387
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3387
  float *xp;
#line 3387
  int nrange = 0;         /* number of range errors */
#line 3387
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3387
  long cxp = (long) *((char**)xpp);
#line 3387

#line 3387
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3387
  /* sjl: manually stripmine so we can limit amount of
#line 3387
   * vector work space reserved to LOOPCNT elements. Also
#line 3387
   * makes vectorisation easy */
#line 3387
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3387
    ni=Min(nelems-j,LOOPCNT);
#line 3387
    if (realign) {
#line 3387
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3387
      xp = tmp;
#line 3387
    } else {
#line 3387
      xp = (float *) *xpp;
#line 3387
    }
#line 3387
   /* copy the next block */
#line 3387
#pragma cdir loopcnt=LOOPCNT
#line 3387
#pragma cdir shortloop
#line 3387
    for (i=0; i<ni; i++) {
#line 3387
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3387
     /* test for range errors (not always needed but do it anyway) */
#line 3387
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3387
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3387
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3387
    }
#line 3387
   /* update xpp and tp */
#line 3387
    if (realign) xp = (float *) *xpp;
#line 3387
    xp += ni;
#line 3387
    tp += ni;
#line 3387
    *xpp = (void*)xp;
#line 3387
  }
#line 3387
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3387

#line 3387
#else   /* not SX */
#line 3387
	const char *xp = (const char *) *xpp;
#line 3387
	int status = NC_NOERR;
#line 3387

#line 3387
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3387
	{
#line 3387
		const int lstatus = ncx_get_float_ushort(xp, tp);
#line 3387
		if (status == NC_NOERR) /* report the first encountered error */
#line 3387
			status = lstatus;
#line 3387
	}
#line 3387

#line 3387
	*xpp = (const void *)xp;
#line 3387
	return status;
#line 3387
#endif
#line 3387
}
#line 3387

int
#line 3388
ncx_getn_float_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3388
{
#line 3388
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3388

#line 3388
 /* basic algorithm is:
#line 3388
  *   - ensure sane alignment of input data
#line 3388
  *   - copy (conversion happens automatically) input data
#line 3388
  *     to output
#line 3388
  *   - update xpp to point at next unconverted input, and tp to point
#line 3388
  *     at next location for converted output
#line 3388
  */
#line 3388
  long i, j, ni;
#line 3388
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3388
  float *xp;
#line 3388
  int nrange = 0;         /* number of range errors */
#line 3388
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3388
  long cxp = (long) *((char**)xpp);
#line 3388

#line 3388
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3388
  /* sjl: manually stripmine so we can limit amount of
#line 3388
   * vector work space reserved to LOOPCNT elements. Also
#line 3388
   * makes vectorisation easy */
#line 3388
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3388
    ni=Min(nelems-j,LOOPCNT);
#line 3388
    if (realign) {
#line 3388
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3388
      xp = tmp;
#line 3388
    } else {
#line 3388
      xp = (float *) *xpp;
#line 3388
    }
#line 3388
   /* copy the next block */
#line 3388
#pragma cdir loopcnt=LOOPCNT
#line 3388
#pragma cdir shortloop
#line 3388
    for (i=0; i<ni; i++) {
#line 3388
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3388
     /* test for range errors (not always needed but do it anyway) */
#line 3388
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3388
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3388
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3388
    }
#line 3388
   /* update xpp and tp */
#line 3388
    if (realign) xp = (float *) *xpp;
#line 3388
    xp += ni;
#line 3388
    tp += ni;
#line 3388
    *xpp = (void*)xp;
#line 3388
  }
#line 3388
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3388

#line 3388
#else   /* not SX */
#line 3388
	const char *xp = (const char *) *xpp;
#line 3388
	int status = NC_NOERR;
#line 3388

#line 3388
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3388
	{
#line 3388
		const int lstatus = ncx_get_float_uchar(xp, tp);
#line 3388
		if (status == NC_NOERR) /* report the first encountered error */
#line 3388
			status = lstatus;
#line 3388
	}
#line 3388

#line 3388
	*xpp = (const void *)xp;
#line 3388
	return status;
#line 3388
#endif
#line 3388
}
#line 3388

int
#line 3389
ncx_getn_float_uint(const void **xpp, size_t nelems, uint *tp)
#line 3389
{
#line 3389
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3389

#line 3389
 /* basic algorithm is:
#line 3389
  *   - ensure sane alignment of input data
#line 3389
  *   - copy (conversion happens automatically) input data
#line 3389
  *     to output
#line 3389
  *   - update xpp to point at next unconverted input, and tp to point
#line 3389
  *     at next location for converted output
#line 3389
  */
#line 3389
  long i, j, ni;
#line 3389
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3389
  float *xp;
#line 3389
  int nrange = 0;         /* number of range errors */
#line 3389
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3389
  long cxp = (long) *((char**)xpp);
#line 3389

#line 3389
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3389
  /* sjl: manually stripmine so we can limit amount of
#line 3389
   * vector work space reserved to LOOPCNT elements. Also
#line 3389
   * makes vectorisation easy */
#line 3389
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3389
    ni=Min(nelems-j,LOOPCNT);
#line 3389
    if (realign) {
#line 3389
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3389
      xp = tmp;
#line 3389
    } else {
#line 3389
      xp = (float *) *xpp;
#line 3389
    }
#line 3389
   /* copy the next block */
#line 3389
#pragma cdir loopcnt=LOOPCNT
#line 3389
#pragma cdir shortloop
#line 3389
    for (i=0; i<ni; i++) {
#line 3389
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3389
     /* test for range errors (not always needed but do it anyway) */
#line 3389
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3389
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3389
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3389
    }
#line 3389
   /* update xpp and tp */
#line 3389
    if (realign) xp = (float *) *xpp;
#line 3389
    xp += ni;
#line 3389
    tp += ni;
#line 3389
    *xpp = (void*)xp;
#line 3389
  }
#line 3389
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3389

#line 3389
#else   /* not SX */
#line 3389
	const char *xp = (const char *) *xpp;
#line 3389
	int status = NC_NOERR;
#line 3389

#line 3389
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3389
	{
#line 3389
		const int lstatus = ncx_get_float_uint(xp, tp);
#line 3389
		if (status == NC_NOERR) /* report the first encountered error */
#line 3389
			status = lstatus;
#line 3389
	}
#line 3389

#line 3389
	*xpp = (const void *)xp;
#line 3389
	return status;
#line 3389
#endif
#line 3389
}
#line 3389

int
#line 3390
ncx_getn_float_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3390
{
#line 3390
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3390

#line 3390
 /* basic algorithm is:
#line 3390
  *   - ensure sane alignment of input data
#line 3390
  *   - copy (conversion happens automatically) input data
#line 3390
  *     to output
#line 3390
  *   - update xpp to point at next unconverted input, and tp to point
#line 3390
  *     at next location for converted output
#line 3390
  */
#line 3390
  long i, j, ni;
#line 3390
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3390
  float *xp;
#line 3390
  int nrange = 0;         /* number of range errors */
#line 3390
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3390
  long cxp = (long) *((char**)xpp);
#line 3390

#line 3390
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3390
  /* sjl: manually stripmine so we can limit amount of
#line 3390
   * vector work space reserved to LOOPCNT elements. Also
#line 3390
   * makes vectorisation easy */
#line 3390
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3390
    ni=Min(nelems-j,LOOPCNT);
#line 3390
    if (realign) {
#line 3390
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_FLOAT));
#line 3390
      xp = tmp;
#line 3390
    } else {
#line 3390
      xp = (float *) *xpp;
#line 3390
    }
#line 3390
   /* copy the next block */
#line 3390
#pragma cdir loopcnt=LOOPCNT
#line 3390
#pragma cdir shortloop
#line 3390
    for (i=0; i<ni; i++) {
#line 3390
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3390
     /* test for range errors (not always needed but do it anyway) */
#line 3390
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3390
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3390
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3390
    }
#line 3390
   /* update xpp and tp */
#line 3390
    if (realign) xp = (float *) *xpp;
#line 3390
    xp += ni;
#line 3390
    tp += ni;
#line 3390
    *xpp = (void*)xp;
#line 3390
  }
#line 3390
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3390

#line 3390
#else   /* not SX */
#line 3390
	const char *xp = (const char *) *xpp;
#line 3390
	int status = NC_NOERR;
#line 3390

#line 3390
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3390
	{
#line 3390
		const int lstatus = ncx_get_float_ulonglong(xp, tp);
#line 3390
		if (status == NC_NOERR) /* report the first encountered error */
#line 3390
			status = lstatus;
#line 3390
	}
#line 3390

#line 3390
	*xpp = (const void *)xp;
#line 3390
	return status;
#line 3390
#endif
#line 3390
}
#line 3390


int
ncx_putn_float_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_FLOAT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return NC_NOERR;
}
#elif defined(vax) && vax != 0
{
	const float *const end = tp + nelems;

	while (tp < end) {
				const struct vax_single *const vsp =
#line 3410
			 (const struct vax_single *)ip;
#line 3410
		struct ieee_single *const isp = (struct ieee_single *) (*xpp);
#line 3410

#line 3410
		switch(vsp->exp){
#line 3410
		case 0 :
#line 3410
			/* all vax float with zero exponent map to zero */
#line 3410
			*isp = min.ieee;
#line 3410
			break;
#line 3410
		case 2 :
#line 3410
		case 1 :
#line 3410
		{
#line 3410
			/* These will map to subnormals */
#line 3410
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 3410
					 | vsp->mantissa2;
#line 3410
			mantissa >>= 3 - vsp->exp;
#line 3410
			mantissa += (1 << (20 + vsp->exp));
#line 3410
			isp->mant_lo_lo = mantissa;
#line 3410
			isp->mant_lo_hi = mantissa >> 8;
#line 3410
			isp->mant_hi = mantissa >> 16;
#line 3410
			isp->exp_lo = 0;
#line 3410
			isp->exp_hi = 0;
#line 3410
		}
#line 3410
			break;
#line 3410
		case 0xff : /* max.s.exp */
#line 3410
			if (vsp->mantissa2 == max.s.mantissa2 &&
#line 3410
			    vsp->mantissa1 == max.s.mantissa1)
#line 3410
			{
#line 3410
				/* map largest vax float to ieee infinity */
#line 3410
				*isp = max.ieee;
#line 3410
				break;
#line 3410
			} /* else, fall thru */
#line 3410
		default :
#line 3410
		{
#line 3410
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 3410
			isp->exp_hi = exp >> 1;
#line 3410
			isp->exp_lo = exp;
#line 3410
			isp->mant_lo_lo = vsp->mantissa2;
#line 3410
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 3410
			isp->mant_hi = vsp->mantissa1;
#line 3410
		}
#line 3410
		}
#line 3410

#line 3410
		isp->sign = vsp->sign;
#line 3410

		tp++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return NC_NOERR;
}
#else
{
	char *xp = *xpp;
	int status = NC_NOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++) {
		int lstatus = ncx_put_float_float(xp, tp, fillp);
		if (status == NC_NOERR) /* report the first encountered error */
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}
#endif
int
#line 3431
ncx_putn_float_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3431
{
#line 3431
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3431

#line 3431
 /* basic algorithm is:
#line 3431
  *   - ensure sane alignment of output data
#line 3431
  *   - copy (conversion happens automatically) input data
#line 3431
  *     to output
#line 3431
  *   - update tp to point at next unconverted input, and xpp to point
#line 3431
  *     at next location for converted output
#line 3431
  */
#line 3431
  long i, j, ni;
#line 3431
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3431
  float *xp;
#line 3431
  int nrange = 0;         /* number of range errors */
#line 3431
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3431
  long cxp = (long) *((char**)xpp);
#line 3431

#line 3431
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3431
  /* sjl: manually stripmine so we can limit amount of
#line 3431
   * vector work space reserved to LOOPCNT elements. Also
#line 3431
   * makes vectorisation easy */
#line 3431
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3431
    ni=Min(nelems-j,LOOPCNT);
#line 3431
    if (realign) {
#line 3431
      xp = tmp;
#line 3431
    } else {
#line 3431
      xp = (float *) *xpp;
#line 3431
    }
#line 3431
   /* copy the next block */
#line 3431
#pragma cdir loopcnt=LOOPCNT
#line 3431
#pragma cdir shortloop
#line 3431
    for (i=0; i<ni; i++) {
#line 3431
      /* the normal case: */
#line 3431
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3431
     /* test for range errors (not always needed but do it anyway) */
#line 3431
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3431
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3431
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3431
    }
#line 3431
   /* copy workspace back if necessary */
#line 3431
    if (realign) {
#line 3431
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3431
      xp = (float *) *xpp;
#line 3431
    }
#line 3431
   /* update xpp and tp */
#line 3431
    xp += ni;
#line 3431
    tp += ni;
#line 3431
    *xpp = (void*)xp;
#line 3431
  }
#line 3431
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3431

#line 3431
#else   /* not SX */
#line 3431

#line 3431
	char *xp = (char *) *xpp;
#line 3431
	int status = NC_NOERR;
#line 3431

#line 3431
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3431
	{
#line 3431
		int lstatus = ncx_put_float_schar(xp, tp, fillp);
#line 3431
		if (status == NC_NOERR) /* report the first encountered error */
#line 3431
			status = lstatus;
#line 3431
	}
#line 3431

#line 3431
	*xpp = (void *)xp;
#line 3431
	return status;
#line 3431
#endif
#line 3431
}
#line 3431

int
#line 3432
ncx_putn_float_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3432
{
#line 3432
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3432

#line 3432
 /* basic algorithm is:
#line 3432
  *   - ensure sane alignment of output data
#line 3432
  *   - copy (conversion happens automatically) input data
#line 3432
  *     to output
#line 3432
  *   - update tp to point at next unconverted input, and xpp to point
#line 3432
  *     at next location for converted output
#line 3432
  */
#line 3432
  long i, j, ni;
#line 3432
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3432
  float *xp;
#line 3432
  int nrange = 0;         /* number of range errors */
#line 3432
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3432
  long cxp = (long) *((char**)xpp);
#line 3432

#line 3432
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3432
  /* sjl: manually stripmine so we can limit amount of
#line 3432
   * vector work space reserved to LOOPCNT elements. Also
#line 3432
   * makes vectorisation easy */
#line 3432
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3432
    ni=Min(nelems-j,LOOPCNT);
#line 3432
    if (realign) {
#line 3432
      xp = tmp;
#line 3432
    } else {
#line 3432
      xp = (float *) *xpp;
#line 3432
    }
#line 3432
   /* copy the next block */
#line 3432
#pragma cdir loopcnt=LOOPCNT
#line 3432
#pragma cdir shortloop
#line 3432
    for (i=0; i<ni; i++) {
#line 3432
      /* the normal case: */
#line 3432
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3432
     /* test for range errors (not always needed but do it anyway) */
#line 3432
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3432
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3432
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3432
    }
#line 3432
   /* copy workspace back if necessary */
#line 3432
    if (realign) {
#line 3432
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3432
      xp = (float *) *xpp;
#line 3432
    }
#line 3432
   /* update xpp and tp */
#line 3432
    xp += ni;
#line 3432
    tp += ni;
#line 3432
    *xpp = (void*)xp;
#line 3432
  }
#line 3432
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3432

#line 3432
#else   /* not SX */
#line 3432

#line 3432
	char *xp = (char *) *xpp;
#line 3432
	int status = NC_NOERR;
#line 3432

#line 3432
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3432
	{
#line 3432
		int lstatus = ncx_put_float_short(xp, tp, fillp);
#line 3432
		if (status == NC_NOERR) /* report the first encountered error */
#line 3432
			status = lstatus;
#line 3432
	}
#line 3432

#line 3432
	*xpp = (void *)xp;
#line 3432
	return status;
#line 3432
#endif
#line 3432
}
#line 3432

int
#line 3433
ncx_putn_float_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3433
{
#line 3433
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3433

#line 3433
 /* basic algorithm is:
#line 3433
  *   - ensure sane alignment of output data
#line 3433
  *   - copy (conversion happens automatically) input data
#line 3433
  *     to output
#line 3433
  *   - update tp to point at next unconverted input, and xpp to point
#line 3433
  *     at next location for converted output
#line 3433
  */
#line 3433
  long i, j, ni;
#line 3433
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3433
  float *xp;
#line 3433
  int nrange = 0;         /* number of range errors */
#line 3433
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3433
  long cxp = (long) *((char**)xpp);
#line 3433

#line 3433
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3433
  /* sjl: manually stripmine so we can limit amount of
#line 3433
   * vector work space reserved to LOOPCNT elements. Also
#line 3433
   * makes vectorisation easy */
#line 3433
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3433
    ni=Min(nelems-j,LOOPCNT);
#line 3433
    if (realign) {
#line 3433
      xp = tmp;
#line 3433
    } else {
#line 3433
      xp = (float *) *xpp;
#line 3433
    }
#line 3433
   /* copy the next block */
#line 3433
#pragma cdir loopcnt=LOOPCNT
#line 3433
#pragma cdir shortloop
#line 3433
    for (i=0; i<ni; i++) {
#line 3433
      /* the normal case: */
#line 3433
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3433
     /* test for range errors (not always needed but do it anyway) */
#line 3433
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3433
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3433
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3433
    }
#line 3433
   /* copy workspace back if necessary */
#line 3433
    if (realign) {
#line 3433
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3433
      xp = (float *) *xpp;
#line 3433
    }
#line 3433
   /* update xpp and tp */
#line 3433
    xp += ni;
#line 3433
    tp += ni;
#line 3433
    *xpp = (void*)xp;
#line 3433
  }
#line 3433
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3433

#line 3433
#else   /* not SX */
#line 3433

#line 3433
	char *xp = (char *) *xpp;
#line 3433
	int status = NC_NOERR;
#line 3433

#line 3433
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3433
	{
#line 3433
		int lstatus = ncx_put_float_int(xp, tp, fillp);
#line 3433
		if (status == NC_NOERR) /* report the first encountered error */
#line 3433
			status = lstatus;
#line 3433
	}
#line 3433

#line 3433
	*xpp = (void *)xp;
#line 3433
	return status;
#line 3433
#endif
#line 3433
}
#line 3433

int
#line 3434
ncx_putn_float_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3434
{
#line 3434
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3434

#line 3434
 /* basic algorithm is:
#line 3434
  *   - ensure sane alignment of output data
#line 3434
  *   - copy (conversion happens automatically) input data
#line 3434
  *     to output
#line 3434
  *   - update tp to point at next unconverted input, and xpp to point
#line 3434
  *     at next location for converted output
#line 3434
  */
#line 3434
  long i, j, ni;
#line 3434
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3434
  float *xp;
#line 3434
  int nrange = 0;         /* number of range errors */
#line 3434
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3434
  long cxp = (long) *((char**)xpp);
#line 3434

#line 3434
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3434
  /* sjl: manually stripmine so we can limit amount of
#line 3434
   * vector work space reserved to LOOPCNT elements. Also
#line 3434
   * makes vectorisation easy */
#line 3434
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3434
    ni=Min(nelems-j,LOOPCNT);
#line 3434
    if (realign) {
#line 3434
      xp = tmp;
#line 3434
    } else {
#line 3434
      xp = (float *) *xpp;
#line 3434
    }
#line 3434
   /* copy the next block */
#line 3434
#pragma cdir loopcnt=LOOPCNT
#line 3434
#pragma cdir shortloop
#line 3434
    for (i=0; i<ni; i++) {
#line 3434
      /* the normal case: */
#line 3434
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3434
     /* test for range errors (not always needed but do it anyway) */
#line 3434
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3434
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3434
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3434
    }
#line 3434
   /* copy workspace back if necessary */
#line 3434
    if (realign) {
#line 3434
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3434
      xp = (float *) *xpp;
#line 3434
    }
#line 3434
   /* update xpp and tp */
#line 3434
    xp += ni;
#line 3434
    tp += ni;
#line 3434
    *xpp = (void*)xp;
#line 3434
  }
#line 3434
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3434

#line 3434
#else   /* not SX */
#line 3434

#line 3434
	char *xp = (char *) *xpp;
#line 3434
	int status = NC_NOERR;
#line 3434

#line 3434
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3434
	{
#line 3434
		int lstatus = ncx_put_float_long(xp, tp, fillp);
#line 3434
		if (status == NC_NOERR) /* report the first encountered error */
#line 3434
			status = lstatus;
#line 3434
	}
#line 3434

#line 3434
	*xpp = (void *)xp;
#line 3434
	return status;
#line 3434
#endif
#line 3434
}
#line 3434

int
#line 3435
ncx_putn_float_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3435
{
#line 3435
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3435

#line 3435
 /* basic algorithm is:
#line 3435
  *   - ensure sane alignment of output data
#line 3435
  *   - copy (conversion happens automatically) input data
#line 3435
  *     to output
#line 3435
  *   - update tp to point at next unconverted input, and xpp to point
#line 3435
  *     at next location for converted output
#line 3435
  */
#line 3435
  long i, j, ni;
#line 3435
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3435
  float *xp;
#line 3435
  int nrange = 0;         /* number of range errors */
#line 3435
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3435
  long cxp = (long) *((char**)xpp);
#line 3435

#line 3435
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3435
  /* sjl: manually stripmine so we can limit amount of
#line 3435
   * vector work space reserved to LOOPCNT elements. Also
#line 3435
   * makes vectorisation easy */
#line 3435
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3435
    ni=Min(nelems-j,LOOPCNT);
#line 3435
    if (realign) {
#line 3435
      xp = tmp;
#line 3435
    } else {
#line 3435
      xp = (float *) *xpp;
#line 3435
    }
#line 3435
   /* copy the next block */
#line 3435
#pragma cdir loopcnt=LOOPCNT
#line 3435
#pragma cdir shortloop
#line 3435
    for (i=0; i<ni; i++) {
#line 3435
      /* the normal case: */
#line 3435
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3435
     /* test for range errors (not always needed but do it anyway) */
#line 3435
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3435
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3435
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3435
    }
#line 3435
   /* copy workspace back if necessary */
#line 3435
    if (realign) {
#line 3435
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3435
      xp = (float *) *xpp;
#line 3435
    }
#line 3435
   /* update xpp and tp */
#line 3435
    xp += ni;
#line 3435
    tp += ni;
#line 3435
    *xpp = (void*)xp;
#line 3435
  }
#line 3435
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3435

#line 3435
#else   /* not SX */
#line 3435

#line 3435
	char *xp = (char *) *xpp;
#line 3435
	int status = NC_NOERR;
#line 3435

#line 3435
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3435
	{
#line 3435
		int lstatus = ncx_put_float_double(xp, tp, fillp);
#line 3435
		if (status == NC_NOERR) /* report the first encountered error */
#line 3435
			status = lstatus;
#line 3435
	}
#line 3435

#line 3435
	*xpp = (void *)xp;
#line 3435
	return status;
#line 3435
#endif
#line 3435
}
#line 3435

int
#line 3436
ncx_putn_float_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3436
{
#line 3436
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3436

#line 3436
 /* basic algorithm is:
#line 3436
  *   - ensure sane alignment of output data
#line 3436
  *   - copy (conversion happens automatically) input data
#line 3436
  *     to output
#line 3436
  *   - update tp to point at next unconverted input, and xpp to point
#line 3436
  *     at next location for converted output
#line 3436
  */
#line 3436
  long i, j, ni;
#line 3436
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3436
  float *xp;
#line 3436
  int nrange = 0;         /* number of range errors */
#line 3436
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3436
  long cxp = (long) *((char**)xpp);
#line 3436

#line 3436
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3436
  /* sjl: manually stripmine so we can limit amount of
#line 3436
   * vector work space reserved to LOOPCNT elements. Also
#line 3436
   * makes vectorisation easy */
#line 3436
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3436
    ni=Min(nelems-j,LOOPCNT);
#line 3436
    if (realign) {
#line 3436
      xp = tmp;
#line 3436
    } else {
#line 3436
      xp = (float *) *xpp;
#line 3436
    }
#line 3436
   /* copy the next block */
#line 3436
#pragma cdir loopcnt=LOOPCNT
#line 3436
#pragma cdir shortloop
#line 3436
    for (i=0; i<ni; i++) {
#line 3436
      /* the normal case: */
#line 3436
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3436
     /* test for range errors (not always needed but do it anyway) */
#line 3436
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3436
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3436
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3436
    }
#line 3436
   /* copy workspace back if necessary */
#line 3436
    if (realign) {
#line 3436
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3436
      xp = (float *) *xpp;
#line 3436
    }
#line 3436
   /* update xpp and tp */
#line 3436
    xp += ni;
#line 3436
    tp += ni;
#line 3436
    *xpp = (void*)xp;
#line 3436
  }
#line 3436
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3436

#line 3436
#else   /* not SX */
#line 3436

#line 3436
	char *xp = (char *) *xpp;
#line 3436
	int status = NC_NOERR;
#line 3436

#line 3436
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3436
	{
#line 3436
		int lstatus = ncx_put_float_longlong(xp, tp, fillp);
#line 3436
		if (status == NC_NOERR) /* report the first encountered error */
#line 3436
			status = lstatus;
#line 3436
	}
#line 3436

#line 3436
	*xpp = (void *)xp;
#line 3436
	return status;
#line 3436
#endif
#line 3436
}
#line 3436

int
#line 3437
ncx_putn_float_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3437
{
#line 3437
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3437

#line 3437
 /* basic algorithm is:
#line 3437
  *   - ensure sane alignment of output data
#line 3437
  *   - copy (conversion happens automatically) input data
#line 3437
  *     to output
#line 3437
  *   - update tp to point at next unconverted input, and xpp to point
#line 3437
  *     at next location for converted output
#line 3437
  */
#line 3437
  long i, j, ni;
#line 3437
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3437
  float *xp;
#line 3437
  int nrange = 0;         /* number of range errors */
#line 3437
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3437
  long cxp = (long) *((char**)xpp);
#line 3437

#line 3437
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3437
  /* sjl: manually stripmine so we can limit amount of
#line 3437
   * vector work space reserved to LOOPCNT elements. Also
#line 3437
   * makes vectorisation easy */
#line 3437
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3437
    ni=Min(nelems-j,LOOPCNT);
#line 3437
    if (realign) {
#line 3437
      xp = tmp;
#line 3437
    } else {
#line 3437
      xp = (float *) *xpp;
#line 3437
    }
#line 3437
   /* copy the next block */
#line 3437
#pragma cdir loopcnt=LOOPCNT
#line 3437
#pragma cdir shortloop
#line 3437
    for (i=0; i<ni; i++) {
#line 3437
      /* the normal case: */
#line 3437
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3437
     /* test for range errors (not always needed but do it anyway) */
#line 3437
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3437
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3437
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3437
    }
#line 3437
   /* copy workspace back if necessary */
#line 3437
    if (realign) {
#line 3437
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3437
      xp = (float *) *xpp;
#line 3437
    }
#line 3437
   /* update xpp and tp */
#line 3437
    xp += ni;
#line 3437
    tp += ni;
#line 3437
    *xpp = (void*)xp;
#line 3437
  }
#line 3437
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3437

#line 3437
#else   /* not SX */
#line 3437

#line 3437
	char *xp = (char *) *xpp;
#line 3437
	int status = NC_NOERR;
#line 3437

#line 3437
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3437
	{
#line 3437
		int lstatus = ncx_put_float_uchar(xp, tp, fillp);
#line 3437
		if (status == NC_NOERR) /* report the first encountered error */
#line 3437
			status = lstatus;
#line 3437
	}
#line 3437

#line 3437
	*xpp = (void *)xp;
#line 3437
	return status;
#line 3437
#endif
#line 3437
}
#line 3437

int
#line 3438
ncx_putn_float_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3438
{
#line 3438
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3438

#line 3438
 /* basic algorithm is:
#line 3438
  *   - ensure sane alignment of output data
#line 3438
  *   - copy (conversion happens automatically) input data
#line 3438
  *     to output
#line 3438
  *   - update tp to point at next unconverted input, and xpp to point
#line 3438
  *     at next location for converted output
#line 3438
  */
#line 3438
  long i, j, ni;
#line 3438
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3438
  float *xp;
#line 3438
  int nrange = 0;         /* number of range errors */
#line 3438
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3438
  long cxp = (long) *((char**)xpp);
#line 3438

#line 3438
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3438
  /* sjl: manually stripmine so we can limit amount of
#line 3438
   * vector work space reserved to LOOPCNT elements. Also
#line 3438
   * makes vectorisation easy */
#line 3438
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3438
    ni=Min(nelems-j,LOOPCNT);
#line 3438
    if (realign) {
#line 3438
      xp = tmp;
#line 3438
    } else {
#line 3438
      xp = (float *) *xpp;
#line 3438
    }
#line 3438
   /* copy the next block */
#line 3438
#pragma cdir loopcnt=LOOPCNT
#line 3438
#pragma cdir shortloop
#line 3438
    for (i=0; i<ni; i++) {
#line 3438
      /* the normal case: */
#line 3438
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3438
     /* test for range errors (not always needed but do it anyway) */
#line 3438
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3438
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3438
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3438
    }
#line 3438
   /* copy workspace back if necessary */
#line 3438
    if (realign) {
#line 3438
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3438
      xp = (float *) *xpp;
#line 3438
    }
#line 3438
   /* update xpp and tp */
#line 3438
    xp += ni;
#line 3438
    tp += ni;
#line 3438
    *xpp = (void*)xp;
#line 3438
  }
#line 3438
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3438

#line 3438
#else   /* not SX */
#line 3438

#line 3438
	char *xp = (char *) *xpp;
#line 3438
	int status = NC_NOERR;
#line 3438

#line 3438
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3438
	{
#line 3438
		int lstatus = ncx_put_float_ushort(xp, tp, fillp);
#line 3438
		if (status == NC_NOERR) /* report the first encountered error */
#line 3438
			status = lstatus;
#line 3438
	}
#line 3438

#line 3438
	*xpp = (void *)xp;
#line 3438
	return status;
#line 3438
#endif
#line 3438
}
#line 3438

int
#line 3439
ncx_putn_float_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3439
{
#line 3439
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3439

#line 3439
 /* basic algorithm is:
#line 3439
  *   - ensure sane alignment of output data
#line 3439
  *   - copy (conversion happens automatically) input data
#line 3439
  *     to output
#line 3439
  *   - update tp to point at next unconverted input, and xpp to point
#line 3439
  *     at next location for converted output
#line 3439
  */
#line 3439
  long i, j, ni;
#line 3439
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3439
  float *xp;
#line 3439
  int nrange = 0;         /* number of range errors */
#line 3439
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3439
  long cxp = (long) *((char**)xpp);
#line 3439

#line 3439
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3439
  /* sjl: manually stripmine so we can limit amount of
#line 3439
   * vector work space reserved to LOOPCNT elements. Also
#line 3439
   * makes vectorisation easy */
#line 3439
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3439
    ni=Min(nelems-j,LOOPCNT);
#line 3439
    if (realign) {
#line 3439
      xp = tmp;
#line 3439
    } else {
#line 3439
      xp = (float *) *xpp;
#line 3439
    }
#line 3439
   /* copy the next block */
#line 3439
#pragma cdir loopcnt=LOOPCNT
#line 3439
#pragma cdir shortloop
#line 3439
    for (i=0; i<ni; i++) {
#line 3439
      /* the normal case: */
#line 3439
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3439
     /* test for range errors (not always needed but do it anyway) */
#line 3439
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3439
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3439
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3439
    }
#line 3439
   /* copy workspace back if necessary */
#line 3439
    if (realign) {
#line 3439
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3439
      xp = (float *) *xpp;
#line 3439
    }
#line 3439
   /* update xpp and tp */
#line 3439
    xp += ni;
#line 3439
    tp += ni;
#line 3439
    *xpp = (void*)xp;
#line 3439
  }
#line 3439
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3439

#line 3439
#else   /* not SX */
#line 3439

#line 3439
	char *xp = (char *) *xpp;
#line 3439
	int status = NC_NOERR;
#line 3439

#line 3439
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3439
	{
#line 3439
		int lstatus = ncx_put_float_uint(xp, tp, fillp);
#line 3439
		if (status == NC_NOERR) /* report the first encountered error */
#line 3439
			status = lstatus;
#line 3439
	}
#line 3439

#line 3439
	*xpp = (void *)xp;
#line 3439
	return status;
#line 3439
#endif
#line 3439
}
#line 3439

int
#line 3440
ncx_putn_float_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3440
{
#line 3440
#if defined(_SX) && _SX != 0 && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3440

#line 3440
 /* basic algorithm is:
#line 3440
  *   - ensure sane alignment of output data
#line 3440
  *   - copy (conversion happens automatically) input data
#line 3440
  *     to output
#line 3440
  *   - update tp to point at next unconverted input, and xpp to point
#line 3440
  *     at next location for converted output
#line 3440
  */
#line 3440
  long i, j, ni;
#line 3440
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3440
  float *xp;
#line 3440
  int nrange = 0;         /* number of range errors */
#line 3440
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3440
  long cxp = (long) *((char**)xpp);
#line 3440

#line 3440
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3440
  /* sjl: manually stripmine so we can limit amount of
#line 3440
   * vector work space reserved to LOOPCNT elements. Also
#line 3440
   * makes vectorisation easy */
#line 3440
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3440
    ni=Min(nelems-j,LOOPCNT);
#line 3440
    if (realign) {
#line 3440
      xp = tmp;
#line 3440
    } else {
#line 3440
      xp = (float *) *xpp;
#line 3440
    }
#line 3440
   /* copy the next block */
#line 3440
#pragma cdir loopcnt=LOOPCNT
#line 3440
#pragma cdir shortloop
#line 3440
    for (i=0; i<ni; i++) {
#line 3440
      /* the normal case: */
#line 3440
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3440
     /* test for range errors (not always needed but do it anyway) */
#line 3440
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3440
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3440
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3440
    }
#line 3440
   /* copy workspace back if necessary */
#line 3440
    if (realign) {
#line 3440
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_FLOAT);
#line 3440
      xp = (float *) *xpp;
#line 3440
    }
#line 3440
   /* update xpp and tp */
#line 3440
    xp += ni;
#line 3440
    tp += ni;
#line 3440
    *xpp = (void*)xp;
#line 3440
  }
#line 3440
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3440

#line 3440
#else   /* not SX */
#line 3440

#line 3440
	char *xp = (char *) *xpp;
#line 3440
	int status = NC_NOERR;
#line 3440

#line 3440
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3440
	{
#line 3440
		int lstatus = ncx_put_float_ulonglong(xp, tp, fillp);
#line 3440
		if (status == NC_NOERR) /* report the first encountered error */
#line 3440
			status = lstatus;
#line 3440
	}
#line 3440

#line 3440
	*xpp = (void *)xp;
#line 3440
	return status;
#line 3440
#endif
#line 3440
}
#line 3440


/* double --------------------------------------------------------------------*/

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_DOUBLE);
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return NC_NOERR;
}
#elif defined(vax) && vax != 0
int
ncx_getn_double_double(const void **xpp, size_t ndoubles, double *ip)
{
	double *const end = ip + ndoubles;

	while (ip < end)
	{
	struct vax_double *const vdp =
#line 3465
			 (struct vax_double *)ip;
#line 3465
	const struct ieee_double *const idp =
#line 3465
			 (const struct ieee_double *) (*xpp);
#line 3465
	{
#line 3465
		const struct dbl_limits *lim;
#line 3465
		int ii;
#line 3465
		for (ii = 0, lim = dbl_limits;
#line 3465
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 3465
			ii++, lim++)
#line 3465
		{
#line 3465
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 3465
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 3465
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 3465
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 3465
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 3465
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 3465
				)
#line 3465
			{
#line 3465
				*vdp = lim->d;
#line 3465
				goto doneit;
#line 3465
			}
#line 3465
		}
#line 3465
	}
#line 3465
	{
#line 3465
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 3465
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 3465
	}
#line 3465
	{
#line 3465
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 3465
				 | (idp->mant_5 << 8)
#line 3465
				 | idp->mant_4);
#line 3465
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 3465
		vdp->mantissa1 = (mant_hi >> 13);
#line 3465
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 3465
				| (mant_lo >> 29);
#line 3465
		vdp->mantissa3 = (mant_lo >> 13);
#line 3465
		vdp->mantissa4 = (mant_lo << 3);
#line 3465
	}
#line 3465
	doneit:
#line 3465
		vdp->sign = idp->sign;
#line 3465

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return NC_NOERR;
}
	/* vax */
#else
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
	const char *xp = *xpp;
	int status = NC_NOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		const int lstatus = ncx_get_double_double(xp, tp, fillp);
		if (status == NC_NOERR) /* report the first encountered error */
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}
#endif
int
#line 3490
ncx_getn_double_schar(const void **xpp, size_t nelems, schar *tp)
#line 3490
{
#line 3490
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3490

#line 3490
 /* basic algorithm is:
#line 3490
  *   - ensure sane alignment of input data
#line 3490
  *   - copy (conversion happens automatically) input data
#line 3490
  *     to output
#line 3490
  *   - update xpp to point at next unconverted input, and tp to point
#line 3490
  *     at next location for converted output
#line 3490
  */
#line 3490
  long i, j, ni;
#line 3490
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3490
  double *xp;
#line 3490
  int nrange = 0;         /* number of range errors */
#line 3490
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3490
  long cxp = (long) *((char**)xpp);
#line 3490

#line 3490
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3490
  /* sjl: manually stripmine so we can limit amount of
#line 3490
   * vector work space reserved to LOOPCNT elements. Also
#line 3490
   * makes vectorisation easy */
#line 3490
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3490
    ni=Min(nelems-j,LOOPCNT);
#line 3490
    if (realign) {
#line 3490
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3490
      xp = tmp;
#line 3490
    } else {
#line 3490
      xp = (double *) *xpp;
#line 3490
    }
#line 3490
   /* copy the next block */
#line 3490
#pragma cdir loopcnt=LOOPCNT
#line 3490
#pragma cdir shortloop
#line 3490
    for (i=0; i<ni; i++) {
#line 3490
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3490
     /* test for range errors (not always needed but do it anyway) */
#line 3490
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3490
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3490
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3490
    }
#line 3490
   /* update xpp and tp */
#line 3490
    if (realign) xp = (double *) *xpp;
#line 3490
    xp += ni;
#line 3490
    tp += ni;
#line 3490
    *xpp = (void*)xp;
#line 3490
  }
#line 3490
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3490

#line 3490
#else   /* not SX */
#line 3490
	const char *xp = (const char *) *xpp;
#line 3490
	int status = NC_NOERR;
#line 3490

#line 3490
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3490
	{
#line 3490
		const int lstatus = ncx_get_double_schar(xp, tp);
#line 3490
		if (status == NC_NOERR) /* report the first encountered error */
#line 3490
			status = lstatus;
#line 3490
	}
#line 3490

#line 3490
	*xpp = (const void *)xp;
#line 3490
	return status;
#line 3490
#endif
#line 3490
}
#line 3490

int
#line 3491
ncx_getn_double_short(const void **xpp, size_t nelems, short *tp)
#line 3491
{
#line 3491
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3491

#line 3491
 /* basic algorithm is:
#line 3491
  *   - ensure sane alignment of input data
#line 3491
  *   - copy (conversion happens automatically) input data
#line 3491
  *     to output
#line 3491
  *   - update xpp to point at next unconverted input, and tp to point
#line 3491
  *     at next location for converted output
#line 3491
  */
#line 3491
  long i, j, ni;
#line 3491
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3491
  double *xp;
#line 3491
  int nrange = 0;         /* number of range errors */
#line 3491
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3491
  long cxp = (long) *((char**)xpp);
#line 3491

#line 3491
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3491
  /* sjl: manually stripmine so we can limit amount of
#line 3491
   * vector work space reserved to LOOPCNT elements. Also
#line 3491
   * makes vectorisation easy */
#line 3491
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3491
    ni=Min(nelems-j,LOOPCNT);
#line 3491
    if (realign) {
#line 3491
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3491
      xp = tmp;
#line 3491
    } else {
#line 3491
      xp = (double *) *xpp;
#line 3491
    }
#line 3491
   /* copy the next block */
#line 3491
#pragma cdir loopcnt=LOOPCNT
#line 3491
#pragma cdir shortloop
#line 3491
    for (i=0; i<ni; i++) {
#line 3491
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3491
     /* test for range errors (not always needed but do it anyway) */
#line 3491
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3491
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3491
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3491
    }
#line 3491
   /* update xpp and tp */
#line 3491
    if (realign) xp = (double *) *xpp;
#line 3491
    xp += ni;
#line 3491
    tp += ni;
#line 3491
    *xpp = (void*)xp;
#line 3491
  }
#line 3491
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3491

#line 3491
#else   /* not SX */
#line 3491
	const char *xp = (const char *) *xpp;
#line 3491
	int status = NC_NOERR;
#line 3491

#line 3491
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3491
	{
#line 3491
		const int lstatus = ncx_get_double_short(xp, tp);
#line 3491
		if (status == NC_NOERR) /* report the first encountered error */
#line 3491
			status = lstatus;
#line 3491
	}
#line 3491

#line 3491
	*xpp = (const void *)xp;
#line 3491
	return status;
#line 3491
#endif
#line 3491
}
#line 3491

int
#line 3492
ncx_getn_double_int(const void **xpp, size_t nelems, int *tp)
#line 3492
{
#line 3492
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3492

#line 3492
 /* basic algorithm is:
#line 3492
  *   - ensure sane alignment of input data
#line 3492
  *   - copy (conversion happens automatically) input data
#line 3492
  *     to output
#line 3492
  *   - update xpp to point at next unconverted input, and tp to point
#line 3492
  *     at next location for converted output
#line 3492
  */
#line 3492
  long i, j, ni;
#line 3492
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3492
  double *xp;
#line 3492
  int nrange = 0;         /* number of range errors */
#line 3492
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3492
  long cxp = (long) *((char**)xpp);
#line 3492

#line 3492
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3492
  /* sjl: manually stripmine so we can limit amount of
#line 3492
   * vector work space reserved to LOOPCNT elements. Also
#line 3492
   * makes vectorisation easy */
#line 3492
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3492
    ni=Min(nelems-j,LOOPCNT);
#line 3492
    if (realign) {
#line 3492
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3492
      xp = tmp;
#line 3492
    } else {
#line 3492
      xp = (double *) *xpp;
#line 3492
    }
#line 3492
   /* copy the next block */
#line 3492
#pragma cdir loopcnt=LOOPCNT
#line 3492
#pragma cdir shortloop
#line 3492
    for (i=0; i<ni; i++) {
#line 3492
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3492
     /* test for range errors (not always needed but do it anyway) */
#line 3492
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3492
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3492
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3492
    }
#line 3492
   /* update xpp and tp */
#line 3492
    if (realign) xp = (double *) *xpp;
#line 3492
    xp += ni;
#line 3492
    tp += ni;
#line 3492
    *xpp = (void*)xp;
#line 3492
  }
#line 3492
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3492

#line 3492
#else   /* not SX */
#line 3492
	const char *xp = (const char *) *xpp;
#line 3492
	int status = NC_NOERR;
#line 3492

#line 3492
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3492
	{
#line 3492
		const int lstatus = ncx_get_double_int(xp, tp);
#line 3492
		if (status == NC_NOERR) /* report the first encountered error */
#line 3492
			status = lstatus;
#line 3492
	}
#line 3492

#line 3492
	*xpp = (const void *)xp;
#line 3492
	return status;
#line 3492
#endif
#line 3492
}
#line 3492

int
#line 3493
ncx_getn_double_long(const void **xpp, size_t nelems, long *tp)
#line 3493
{
#line 3493
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3493

#line 3493
 /* basic algorithm is:
#line 3493
  *   - ensure sane alignment of input data
#line 3493
  *   - copy (conversion happens automatically) input data
#line 3493
  *     to output
#line 3493
  *   - update xpp to point at next unconverted input, and tp to point
#line 3493
  *     at next location for converted output
#line 3493
  */
#line 3493
  long i, j, ni;
#line 3493
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3493
  double *xp;
#line 3493
  int nrange = 0;         /* number of range errors */
#line 3493
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3493
  long cxp = (long) *((char**)xpp);
#line 3493

#line 3493
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3493
  /* sjl: manually stripmine so we can limit amount of
#line 3493
   * vector work space reserved to LOOPCNT elements. Also
#line 3493
   * makes vectorisation easy */
#line 3493
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3493
    ni=Min(nelems-j,LOOPCNT);
#line 3493
    if (realign) {
#line 3493
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3493
      xp = tmp;
#line 3493
    } else {
#line 3493
      xp = (double *) *xpp;
#line 3493
    }
#line 3493
   /* copy the next block */
#line 3493
#pragma cdir loopcnt=LOOPCNT
#line 3493
#pragma cdir shortloop
#line 3493
    for (i=0; i<ni; i++) {
#line 3493
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3493
     /* test for range errors (not always needed but do it anyway) */
#line 3493
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3493
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3493
      nrange += xp[i] > LONG_MAX || xp[i] < LONG_MIN;
#line 3493
    }
#line 3493
   /* update xpp and tp */
#line 3493
    if (realign) xp = (double *) *xpp;
#line 3493
    xp += ni;
#line 3493
    tp += ni;
#line 3493
    *xpp = (void*)xp;
#line 3493
  }
#line 3493
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3493

#line 3493
#else   /* not SX */
#line 3493
	const char *xp = (const char *) *xpp;
#line 3493
	int status = NC_NOERR;
#line 3493

#line 3493
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3493
	{
#line 3493
		const int lstatus = ncx_get_double_long(xp, tp);
#line 3493
		if (status == NC_NOERR) /* report the first encountered error */
#line 3493
			status = lstatus;
#line 3493
	}
#line 3493

#line 3493
	*xpp = (const void *)xp;
#line 3493
	return status;
#line 3493
#endif
#line 3493
}
#line 3493

int
#line 3494
ncx_getn_double_float(const void **xpp, size_t nelems, float *tp)
#line 3494
{
#line 3494
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3494

#line 3494
 /* basic algorithm is:
#line 3494
  *   - ensure sane alignment of input data
#line 3494
  *   - copy (conversion happens automatically) input data
#line 3494
  *     to output
#line 3494
  *   - update xpp to point at next unconverted input, and tp to point
#line 3494
  *     at next location for converted output
#line 3494
  */
#line 3494
  long i, j, ni;
#line 3494
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3494
  double *xp;
#line 3494
  int nrange = 0;         /* number of range errors */
#line 3494
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3494
  long cxp = (long) *((char**)xpp);
#line 3494

#line 3494
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3494
  /* sjl: manually stripmine so we can limit amount of
#line 3494
   * vector work space reserved to LOOPCNT elements. Also
#line 3494
   * makes vectorisation easy */
#line 3494
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3494
    ni=Min(nelems-j,LOOPCNT);
#line 3494
    if (realign) {
#line 3494
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3494
      xp = tmp;
#line 3494
    } else {
#line 3494
      xp = (double *) *xpp;
#line 3494
    }
#line 3494
   /* copy the next block */
#line 3494
#pragma cdir loopcnt=LOOPCNT
#line 3494
#pragma cdir shortloop
#line 3494
    for (i=0; i<ni; i++) {
#line 3494
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3494
     /* test for range errors (not always needed but do it anyway) */
#line 3494
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3494
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3494
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3494
    }
#line 3494
   /* update xpp and tp */
#line 3494
    if (realign) xp = (double *) *xpp;
#line 3494
    xp += ni;
#line 3494
    tp += ni;
#line 3494
    *xpp = (void*)xp;
#line 3494
  }
#line 3494
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3494

#line 3494
#else   /* not SX */
#line 3494
	const char *xp = (const char *) *xpp;
#line 3494
	int status = NC_NOERR;
#line 3494

#line 3494
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3494
	{
#line 3494
		const int lstatus = ncx_get_double_float(xp, tp);
#line 3494
		if (status == NC_NOERR) /* report the first encountered error */
#line 3494
			status = lstatus;
#line 3494
	}
#line 3494

#line 3494
	*xpp = (const void *)xp;
#line 3494
	return status;
#line 3494
#endif
#line 3494
}
#line 3494

int
#line 3495
ncx_getn_double_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3495
{
#line 3495
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3495

#line 3495
 /* basic algorithm is:
#line 3495
  *   - ensure sane alignment of input data
#line 3495
  *   - copy (conversion happens automatically) input data
#line 3495
  *     to output
#line 3495
  *   - update xpp to point at next unconverted input, and tp to point
#line 3495
  *     at next location for converted output
#line 3495
  */
#line 3495
  long i, j, ni;
#line 3495
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3495
  double *xp;
#line 3495
  int nrange = 0;         /* number of range errors */
#line 3495
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3495
  long cxp = (long) *((char**)xpp);
#line 3495

#line 3495
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3495
  /* sjl: manually stripmine so we can limit amount of
#line 3495
   * vector work space reserved to LOOPCNT elements. Also
#line 3495
   * makes vectorisation easy */
#line 3495
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3495
    ni=Min(nelems-j,LOOPCNT);
#line 3495
    if (realign) {
#line 3495
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3495
      xp = tmp;
#line 3495
    } else {
#line 3495
      xp = (double *) *xpp;
#line 3495
    }
#line 3495
   /* copy the next block */
#line 3495
#pragma cdir loopcnt=LOOPCNT
#line 3495
#pragma cdir shortloop
#line 3495
    for (i=0; i<ni; i++) {
#line 3495
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3495
     /* test for range errors (not always needed but do it anyway) */
#line 3495
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3495
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3495
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3495
    }
#line 3495
   /* update xpp and tp */
#line 3495
    if (realign) xp = (double *) *xpp;
#line 3495
    xp += ni;
#line 3495
    tp += ni;
#line 3495
    *xpp = (void*)xp;
#line 3495
  }
#line 3495
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3495

#line 3495
#else   /* not SX */
#line 3495
	const char *xp = (const char *) *xpp;
#line 3495
	int status = NC_NOERR;
#line 3495

#line 3495
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3495
	{
#line 3495
		const int lstatus = ncx_get_double_longlong(xp, tp);
#line 3495
		if (status == NC_NOERR) /* report the first encountered error */
#line 3495
			status = lstatus;
#line 3495
	}
#line 3495

#line 3495
	*xpp = (const void *)xp;
#line 3495
	return status;
#line 3495
#endif
#line 3495
}
#line 3495

int
#line 3496
ncx_getn_double_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3496
{
#line 3496
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3496

#line 3496
 /* basic algorithm is:
#line 3496
  *   - ensure sane alignment of input data
#line 3496
  *   - copy (conversion happens automatically) input data
#line 3496
  *     to output
#line 3496
  *   - update xpp to point at next unconverted input, and tp to point
#line 3496
  *     at next location for converted output
#line 3496
  */
#line 3496
  long i, j, ni;
#line 3496
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3496
  double *xp;
#line 3496
  int nrange = 0;         /* number of range errors */
#line 3496
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3496
  long cxp = (long) *((char**)xpp);
#line 3496

#line 3496
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3496
  /* sjl: manually stripmine so we can limit amount of
#line 3496
   * vector work space reserved to LOOPCNT elements. Also
#line 3496
   * makes vectorisation easy */
#line 3496
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3496
    ni=Min(nelems-j,LOOPCNT);
#line 3496
    if (realign) {
#line 3496
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3496
      xp = tmp;
#line 3496
    } else {
#line 3496
      xp = (double *) *xpp;
#line 3496
    }
#line 3496
   /* copy the next block */
#line 3496
#pragma cdir loopcnt=LOOPCNT
#line 3496
#pragma cdir shortloop
#line 3496
    for (i=0; i<ni; i++) {
#line 3496
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3496
     /* test for range errors (not always needed but do it anyway) */
#line 3496
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3496
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3496
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3496
    }
#line 3496
   /* update xpp and tp */
#line 3496
    if (realign) xp = (double *) *xpp;
#line 3496
    xp += ni;
#line 3496
    tp += ni;
#line 3496
    *xpp = (void*)xp;
#line 3496
  }
#line 3496
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3496

#line 3496
#else   /* not SX */
#line 3496
	const char *xp = (const char *) *xpp;
#line 3496
	int status = NC_NOERR;
#line 3496

#line 3496
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3496
	{
#line 3496
		const int lstatus = ncx_get_double_uchar(xp, tp);
#line 3496
		if (status == NC_NOERR) /* report the first encountered error */
#line 3496
			status = lstatus;
#line 3496
	}
#line 3496

#line 3496
	*xpp = (const void *)xp;
#line 3496
	return status;
#line 3496
#endif
#line 3496
}
#line 3496

int
#line 3497
ncx_getn_double_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3497
{
#line 3497
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3497

#line 3497
 /* basic algorithm is:
#line 3497
  *   - ensure sane alignment of input data
#line 3497
  *   - copy (conversion happens automatically) input data
#line 3497
  *     to output
#line 3497
  *   - update xpp to point at next unconverted input, and tp to point
#line 3497
  *     at next location for converted output
#line 3497
  */
#line 3497
  long i, j, ni;
#line 3497
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3497
  double *xp;
#line 3497
  int nrange = 0;         /* number of range errors */
#line 3497
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3497
  long cxp = (long) *((char**)xpp);
#line 3497

#line 3497
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3497
  /* sjl: manually stripmine so we can limit amount of
#line 3497
   * vector work space reserved to LOOPCNT elements. Also
#line 3497
   * makes vectorisation easy */
#line 3497
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3497
    ni=Min(nelems-j,LOOPCNT);
#line 3497
    if (realign) {
#line 3497
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3497
      xp = tmp;
#line 3497
    } else {
#line 3497
      xp = (double *) *xpp;
#line 3497
    }
#line 3497
   /* copy the next block */
#line 3497
#pragma cdir loopcnt=LOOPCNT
#line 3497
#pragma cdir shortloop
#line 3497
    for (i=0; i<ni; i++) {
#line 3497
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3497
     /* test for range errors (not always needed but do it anyway) */
#line 3497
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3497
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3497
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3497
    }
#line 3497
   /* update xpp and tp */
#line 3497
    if (realign) xp = (double *) *xpp;
#line 3497
    xp += ni;
#line 3497
    tp += ni;
#line 3497
    *xpp = (void*)xp;
#line 3497
  }
#line 3497
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3497

#line 3497
#else   /* not SX */
#line 3497
	const char *xp = (const char *) *xpp;
#line 3497
	int status = NC_NOERR;
#line 3497

#line 3497
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3497
	{
#line 3497
		const int lstatus = ncx_get_double_ushort(xp, tp);
#line 3497
		if (status == NC_NOERR) /* report the first encountered error */
#line 3497
			status = lstatus;
#line 3497
	}
#line 3497

#line 3497
	*xpp = (const void *)xp;
#line 3497
	return status;
#line 3497
#endif
#line 3497
}
#line 3497

int
#line 3498
ncx_getn_double_uint(const void **xpp, size_t nelems, uint *tp)
#line 3498
{
#line 3498
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3498

#line 3498
 /* basic algorithm is:
#line 3498
  *   - ensure sane alignment of input data
#line 3498
  *   - copy (conversion happens automatically) input data
#line 3498
  *     to output
#line 3498
  *   - update xpp to point at next unconverted input, and tp to point
#line 3498
  *     at next location for converted output
#line 3498
  */
#line 3498
  long i, j, ni;
#line 3498
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3498
  double *xp;
#line 3498
  int nrange = 0;         /* number of range errors */
#line 3498
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3498
  long cxp = (long) *((char**)xpp);
#line 3498

#line 3498
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3498
  /* sjl: manually stripmine so we can limit amount of
#line 3498
   * vector work space reserved to LOOPCNT elements. Also
#line 3498
   * makes vectorisation easy */
#line 3498
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3498
    ni=Min(nelems-j,LOOPCNT);
#line 3498
    if (realign) {
#line 3498
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3498
      xp = tmp;
#line 3498
    } else {
#line 3498
      xp = (double *) *xpp;
#line 3498
    }
#line 3498
   /* copy the next block */
#line 3498
#pragma cdir loopcnt=LOOPCNT
#line 3498
#pragma cdir shortloop
#line 3498
    for (i=0; i<ni; i++) {
#line 3498
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3498
     /* test for range errors (not always needed but do it anyway) */
#line 3498
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3498
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3498
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3498
    }
#line 3498
   /* update xpp and tp */
#line 3498
    if (realign) xp = (double *) *xpp;
#line 3498
    xp += ni;
#line 3498
    tp += ni;
#line 3498
    *xpp = (void*)xp;
#line 3498
  }
#line 3498
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3498

#line 3498
#else   /* not SX */
#line 3498
	const char *xp = (const char *) *xpp;
#line 3498
	int status = NC_NOERR;
#line 3498

#line 3498
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3498
	{
#line 3498
		const int lstatus = ncx_get_double_uint(xp, tp);
#line 3498
		if (status == NC_NOERR) /* report the first encountered error */
#line 3498
			status = lstatus;
#line 3498
	}
#line 3498

#line 3498
	*xpp = (const void *)xp;
#line 3498
	return status;
#line 3498
#endif
#line 3498
}
#line 3498

int
#line 3499
ncx_getn_double_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3499
{
#line 3499
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3499

#line 3499
 /* basic algorithm is:
#line 3499
  *   - ensure sane alignment of input data
#line 3499
  *   - copy (conversion happens automatically) input data
#line 3499
  *     to output
#line 3499
  *   - update xpp to point at next unconverted input, and tp to point
#line 3499
  *     at next location for converted output
#line 3499
  */
#line 3499
  long i, j, ni;
#line 3499
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3499
  double *xp;
#line 3499
  int nrange = 0;         /* number of range errors */
#line 3499
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3499
  long cxp = (long) *((char**)xpp);
#line 3499

#line 3499
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3499
  /* sjl: manually stripmine so we can limit amount of
#line 3499
   * vector work space reserved to LOOPCNT elements. Also
#line 3499
   * makes vectorisation easy */
#line 3499
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3499
    ni=Min(nelems-j,LOOPCNT);
#line 3499
    if (realign) {
#line 3499
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_DOUBLE));
#line 3499
      xp = tmp;
#line 3499
    } else {
#line 3499
      xp = (double *) *xpp;
#line 3499
    }
#line 3499
   /* copy the next block */
#line 3499
#pragma cdir loopcnt=LOOPCNT
#line 3499
#pragma cdir shortloop
#line 3499
    for (i=0; i<ni; i++) {
#line 3499
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3499
     /* test for range errors (not always needed but do it anyway) */
#line 3499
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3499
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3499
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3499
    }
#line 3499
   /* update xpp and tp */
#line 3499
    if (realign) xp = (double *) *xpp;
#line 3499
    xp += ni;
#line 3499
    tp += ni;
#line 3499
    *xpp = (void*)xp;
#line 3499
  }
#line 3499
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3499

#line 3499
#else   /* not SX */
#line 3499
	const char *xp = (const char *) *xpp;
#line 3499
	int status = NC_NOERR;
#line 3499

#line 3499
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3499
	{
#line 3499
		const int lstatus = ncx_get_double_ulonglong(xp, tp);
#line 3499
		if (status == NC_NOERR) /* report the first encountered error */
#line 3499
			status = lstatus;
#line 3499
	}
#line 3499

#line 3499
	*xpp = (const void *)xp;
#line 3499
	return status;
#line 3499
#endif
#line 3499
}
#line 3499


#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_DOUBLE);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return NC_NOERR;
}
#elif defined(vax) && vax != 0
int
ncx_putn_double_double(void **xpp, size_t ndoubles, const double *ip, void *fillp)
{
	const double *const end = ip + ndoubles;

	while (ip < end)
	{
	const struct vax_double *const vdp =
#line 3522
			(const struct vax_double *)ip;
#line 3522
	struct ieee_double *const idp =
#line 3522
			 (struct ieee_double *) (*xpp);
#line 3522

#line 3522
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 3522
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 3522
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 3522
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 3522
		(vdp->exp == dbl_limits[0].d.exp))
#line 3522
	{
#line 3522
		*idp = dbl_limits[0].ieee;
#line 3522
		goto shipit;
#line 3522
	}
#line 3522
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 3522
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 3522
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 3522
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 3522
		(vdp->exp == dbl_limits[1].d.exp))
#line 3522
	{
#line 3522
		*idp = dbl_limits[1].ieee;
#line 3522
		goto shipit;
#line 3522
	}
#line 3522

#line 3522
	{
#line 3522
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 3522

#line 3522
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 3522
			(vdp->mantissa3 << 13) |
#line 3522
			((vdp->mantissa4 >> 3) & MASK(13));
#line 3522

#line 3522
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 3522
				 | (vdp->mantissa2 >> 3);
#line 3522

#line 3522
		if ((vdp->mantissa4 & 7) > 4)
#line 3522
		{
#line 3522
			/* round up */
#line 3522
			mant_lo++;
#line 3522
			if (mant_lo == 0)
#line 3522
			{
#line 3522
				mant_hi++;
#line 3522
				if (mant_hi > 0xffffff)
#line 3522
				{
#line 3522
					mant_hi = 0;
#line 3522
					exp++;
#line 3522
				}
#line 3522
			}
#line 3522
		}
#line 3522

#line 3522
		idp->mant_lo = SWAP4(mant_lo);
#line 3522
		idp->mant_6 = mant_hi >> 16;
#line 3522
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 3522
		idp->mant_4 = mant_hi;
#line 3522
		idp->exp_hi = exp >> 4;
#line 3522
		idp->exp_lo = exp;
#line 3522
	}
#line 3522

#line 3522
	shipit:
#line 3522
		idp->sign = vdp->sign;
#line 3522

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return NC_NOERR;
}
	/* vax */
#else
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp, void *fillp)
{
	char *xp = *xpp;
	int status = NC_NOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		int lstatus = ncx_put_double_double(xp, tp, fillp);
		if (status == NC_NOERR) /* report the first encountered error */
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}
#endif
int
#line 3547
ncx_putn_double_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3547
{
#line 3547
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3547

#line 3547
 /* basic algorithm is:
#line 3547
  *   - ensure sane alignment of output data
#line 3547
  *   - copy (conversion happens automatically) input data
#line 3547
  *     to output
#line 3547
  *   - update tp to point at next unconverted input, and xpp to point
#line 3547
  *     at next location for converted output
#line 3547
  */
#line 3547
  long i, j, ni;
#line 3547
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3547
  double *xp;
#line 3547
  int nrange = 0;         /* number of range errors */
#line 3547
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3547
  long cxp = (long) *((char**)xpp);
#line 3547

#line 3547
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3547
  /* sjl: manually stripmine so we can limit amount of
#line 3547
   * vector work space reserved to LOOPCNT elements. Also
#line 3547
   * makes vectorisation easy */
#line 3547
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3547
    ni=Min(nelems-j,LOOPCNT);
#line 3547
    if (realign) {
#line 3547
      xp = tmp;
#line 3547
    } else {
#line 3547
      xp = (double *) *xpp;
#line 3547
    }
#line 3547
   /* copy the next block */
#line 3547
#pragma cdir loopcnt=LOOPCNT
#line 3547
#pragma cdir shortloop
#line 3547
    for (i=0; i<ni; i++) {
#line 3547
      /* the normal case: */
#line 3547
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3547
     /* test for range errors (not always needed but do it anyway) */
#line 3547
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3547
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3547
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3547
    }
#line 3547
   /* copy workspace back if necessary */
#line 3547
    if (realign) {
#line 3547
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3547
      xp = (double *) *xpp;
#line 3547
    }
#line 3547
   /* update xpp and tp */
#line 3547
    xp += ni;
#line 3547
    tp += ni;
#line 3547
    *xpp = (void*)xp;
#line 3547
  }
#line 3547
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3547

#line 3547
#else   /* not SX */
#line 3547

#line 3547
	char *xp = (char *) *xpp;
#line 3547
	int status = NC_NOERR;
#line 3547

#line 3547
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3547
	{
#line 3547
		int lstatus = ncx_put_double_schar(xp, tp, fillp);
#line 3547
		if (status == NC_NOERR) /* report the first encountered error */
#line 3547
			status = lstatus;
#line 3547
	}
#line 3547

#line 3547
	*xpp = (void *)xp;
#line 3547
	return status;
#line 3547
#endif
#line 3547
}
#line 3547

int
#line 3548
ncx_putn_double_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3548
{
#line 3548
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3548

#line 3548
 /* basic algorithm is:
#line 3548
  *   - ensure sane alignment of output data
#line 3548
  *   - copy (conversion happens automatically) input data
#line 3548
  *     to output
#line 3548
  *   - update tp to point at next unconverted input, and xpp to point
#line 3548
  *     at next location for converted output
#line 3548
  */
#line 3548
  long i, j, ni;
#line 3548
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3548
  double *xp;
#line 3548
  int nrange = 0;         /* number of range errors */
#line 3548
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3548
  long cxp = (long) *((char**)xpp);
#line 3548

#line 3548
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3548
  /* sjl: manually stripmine so we can limit amount of
#line 3548
   * vector work space reserved to LOOPCNT elements. Also
#line 3548
   * makes vectorisation easy */
#line 3548
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3548
    ni=Min(nelems-j,LOOPCNT);
#line 3548
    if (realign) {
#line 3548
      xp = tmp;
#line 3548
    } else {
#line 3548
      xp = (double *) *xpp;
#line 3548
    }
#line 3548
   /* copy the next block */
#line 3548
#pragma cdir loopcnt=LOOPCNT
#line 3548
#pragma cdir shortloop
#line 3548
    for (i=0; i<ni; i++) {
#line 3548
      /* the normal case: */
#line 3548
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3548
     /* test for range errors (not always needed but do it anyway) */
#line 3548
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3548
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3548
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3548
    }
#line 3548
   /* copy workspace back if necessary */
#line 3548
    if (realign) {
#line 3548
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3548
      xp = (double *) *xpp;
#line 3548
    }
#line 3548
   /* update xpp and tp */
#line 3548
    xp += ni;
#line 3548
    tp += ni;
#line 3548
    *xpp = (void*)xp;
#line 3548
  }
#line 3548
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3548

#line 3548
#else   /* not SX */
#line 3548

#line 3548
	char *xp = (char *) *xpp;
#line 3548
	int status = NC_NOERR;
#line 3548

#line 3548
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3548
	{
#line 3548
		int lstatus = ncx_put_double_short(xp, tp, fillp);
#line 3548
		if (status == NC_NOERR) /* report the first encountered error */
#line 3548
			status = lstatus;
#line 3548
	}
#line 3548

#line 3548
	*xpp = (void *)xp;
#line 3548
	return status;
#line 3548
#endif
#line 3548
}
#line 3548

int
#line 3549
ncx_putn_double_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3549
{
#line 3549
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3549

#line 3549
 /* basic algorithm is:
#line 3549
  *   - ensure sane alignment of output data
#line 3549
  *   - copy (conversion happens automatically) input data
#line 3549
  *     to output
#line 3549
  *   - update tp to point at next unconverted input, and xpp to point
#line 3549
  *     at next location for converted output
#line 3549
  */
#line 3549
  long i, j, ni;
#line 3549
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3549
  double *xp;
#line 3549
  int nrange = 0;         /* number of range errors */
#line 3549
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3549
  long cxp = (long) *((char**)xpp);
#line 3549

#line 3549
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3549
  /* sjl: manually stripmine so we can limit amount of
#line 3549
   * vector work space reserved to LOOPCNT elements. Also
#line 3549
   * makes vectorisation easy */
#line 3549
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3549
    ni=Min(nelems-j,LOOPCNT);
#line 3549
    if (realign) {
#line 3549
      xp = tmp;
#line 3549
    } else {
#line 3549
      xp = (double *) *xpp;
#line 3549
    }
#line 3549
   /* copy the next block */
#line 3549
#pragma cdir loopcnt=LOOPCNT
#line 3549
#pragma cdir shortloop
#line 3549
    for (i=0; i<ni; i++) {
#line 3549
      /* the normal case: */
#line 3549
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3549
     /* test for range errors (not always needed but do it anyway) */
#line 3549
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3549
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3549
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3549
    }
#line 3549
   /* copy workspace back if necessary */
#line 3549
    if (realign) {
#line 3549
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3549
      xp = (double *) *xpp;
#line 3549
    }
#line 3549
   /* update xpp and tp */
#line 3549
    xp += ni;
#line 3549
    tp += ni;
#line 3549
    *xpp = (void*)xp;
#line 3549
  }
#line 3549
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3549

#line 3549
#else   /* not SX */
#line 3549

#line 3549
	char *xp = (char *) *xpp;
#line 3549
	int status = NC_NOERR;
#line 3549

#line 3549
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3549
	{
#line 3549
		int lstatus = ncx_put_double_int(xp, tp, fillp);
#line 3549
		if (status == NC_NOERR) /* report the first encountered error */
#line 3549
			status = lstatus;
#line 3549
	}
#line 3549

#line 3549
	*xpp = (void *)xp;
#line 3549
	return status;
#line 3549
#endif
#line 3549
}
#line 3549

int
#line 3550
ncx_putn_double_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3550
{
#line 3550
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3550

#line 3550
 /* basic algorithm is:
#line 3550
  *   - ensure sane alignment of output data
#line 3550
  *   - copy (conversion happens automatically) input data
#line 3550
  *     to output
#line 3550
  *   - update tp to point at next unconverted input, and xpp to point
#line 3550
  *     at next location for converted output
#line 3550
  */
#line 3550
  long i, j, ni;
#line 3550
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3550
  double *xp;
#line 3550
  int nrange = 0;         /* number of range errors */
#line 3550
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3550
  long cxp = (long) *((char**)xpp);
#line 3550

#line 3550
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3550
  /* sjl: manually stripmine so we can limit amount of
#line 3550
   * vector work space reserved to LOOPCNT elements. Also
#line 3550
   * makes vectorisation easy */
#line 3550
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3550
    ni=Min(nelems-j,LOOPCNT);
#line 3550
    if (realign) {
#line 3550
      xp = tmp;
#line 3550
    } else {
#line 3550
      xp = (double *) *xpp;
#line 3550
    }
#line 3550
   /* copy the next block */
#line 3550
#pragma cdir loopcnt=LOOPCNT
#line 3550
#pragma cdir shortloop
#line 3550
    for (i=0; i<ni; i++) {
#line 3550
      /* the normal case: */
#line 3550
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3550
     /* test for range errors (not always needed but do it anyway) */
#line 3550
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3550
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3550
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3550
    }
#line 3550
   /* copy workspace back if necessary */
#line 3550
    if (realign) {
#line 3550
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3550
      xp = (double *) *xpp;
#line 3550
    }
#line 3550
   /* update xpp and tp */
#line 3550
    xp += ni;
#line 3550
    tp += ni;
#line 3550
    *xpp = (void*)xp;
#line 3550
  }
#line 3550
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3550

#line 3550
#else   /* not SX */
#line 3550

#line 3550
	char *xp = (char *) *xpp;
#line 3550
	int status = NC_NOERR;
#line 3550

#line 3550
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3550
	{
#line 3550
		int lstatus = ncx_put_double_long(xp, tp, fillp);
#line 3550
		if (status == NC_NOERR) /* report the first encountered error */
#line 3550
			status = lstatus;
#line 3550
	}
#line 3550

#line 3550
	*xpp = (void *)xp;
#line 3550
	return status;
#line 3550
#endif
#line 3550
}
#line 3550

int
#line 3551
ncx_putn_double_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3551
{
#line 3551
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3551

#line 3551
 /* basic algorithm is:
#line 3551
  *   - ensure sane alignment of output data
#line 3551
  *   - copy (conversion happens automatically) input data
#line 3551
  *     to output
#line 3551
  *   - update tp to point at next unconverted input, and xpp to point
#line 3551
  *     at next location for converted output
#line 3551
  */
#line 3551
  long i, j, ni;
#line 3551
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3551
  double *xp;
#line 3551
  int nrange = 0;         /* number of range errors */
#line 3551
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3551
  long cxp = (long) *((char**)xpp);
#line 3551

#line 3551
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3551
  /* sjl: manually stripmine so we can limit amount of
#line 3551
   * vector work space reserved to LOOPCNT elements. Also
#line 3551
   * makes vectorisation easy */
#line 3551
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3551
    ni=Min(nelems-j,LOOPCNT);
#line 3551
    if (realign) {
#line 3551
      xp = tmp;
#line 3551
    } else {
#line 3551
      xp = (double *) *xpp;
#line 3551
    }
#line 3551
   /* copy the next block */
#line 3551
#pragma cdir loopcnt=LOOPCNT
#line 3551
#pragma cdir shortloop
#line 3551
    for (i=0; i<ni; i++) {
#line 3551
      /* the normal case: */
#line 3551
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3551
     /* test for range errors (not always needed but do it anyway) */
#line 3551
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3551
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3551
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3551
    }
#line 3551
   /* copy workspace back if necessary */
#line 3551
    if (realign) {
#line 3551
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3551
      xp = (double *) *xpp;
#line 3551
    }
#line 3551
   /* update xpp and tp */
#line 3551
    xp += ni;
#line 3551
    tp += ni;
#line 3551
    *xpp = (void*)xp;
#line 3551
  }
#line 3551
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3551

#line 3551
#else   /* not SX */
#line 3551

#line 3551
	char *xp = (char *) *xpp;
#line 3551
	int status = NC_NOERR;
#line 3551

#line 3551
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3551
	{
#line 3551
		int lstatus = ncx_put_double_float(xp, tp, fillp);
#line 3551
		if (status == NC_NOERR) /* report the first encountered error */
#line 3551
			status = lstatus;
#line 3551
	}
#line 3551

#line 3551
	*xpp = (void *)xp;
#line 3551
	return status;
#line 3551
#endif
#line 3551
}
#line 3551

int
#line 3552
ncx_putn_double_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3552
{
#line 3552
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3552

#line 3552
 /* basic algorithm is:
#line 3552
  *   - ensure sane alignment of output data
#line 3552
  *   - copy (conversion happens automatically) input data
#line 3552
  *     to output
#line 3552
  *   - update tp to point at next unconverted input, and xpp to point
#line 3552
  *     at next location for converted output
#line 3552
  */
#line 3552
  long i, j, ni;
#line 3552
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3552
  double *xp;
#line 3552
  int nrange = 0;         /* number of range errors */
#line 3552
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3552
  long cxp = (long) *((char**)xpp);
#line 3552

#line 3552
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3552
  /* sjl: manually stripmine so we can limit amount of
#line 3552
   * vector work space reserved to LOOPCNT elements. Also
#line 3552
   * makes vectorisation easy */
#line 3552
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3552
    ni=Min(nelems-j,LOOPCNT);
#line 3552
    if (realign) {
#line 3552
      xp = tmp;
#line 3552
    } else {
#line 3552
      xp = (double *) *xpp;
#line 3552
    }
#line 3552
   /* copy the next block */
#line 3552
#pragma cdir loopcnt=LOOPCNT
#line 3552
#pragma cdir shortloop
#line 3552
    for (i=0; i<ni; i++) {
#line 3552
      /* the normal case: */
#line 3552
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3552
     /* test for range errors (not always needed but do it anyway) */
#line 3552
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3552
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3552
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3552
    }
#line 3552
   /* copy workspace back if necessary */
#line 3552
    if (realign) {
#line 3552
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3552
      xp = (double *) *xpp;
#line 3552
    }
#line 3552
   /* update xpp and tp */
#line 3552
    xp += ni;
#line 3552
    tp += ni;
#line 3552
    *xpp = (void*)xp;
#line 3552
  }
#line 3552
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3552

#line 3552
#else   /* not SX */
#line 3552

#line 3552
	char *xp = (char *) *xpp;
#line 3552
	int status = NC_NOERR;
#line 3552

#line 3552
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3552
	{
#line 3552
		int lstatus = ncx_put_double_longlong(xp, tp, fillp);
#line 3552
		if (status == NC_NOERR) /* report the first encountered error */
#line 3552
			status = lstatus;
#line 3552
	}
#line 3552

#line 3552
	*xpp = (void *)xp;
#line 3552
	return status;
#line 3552
#endif
#line 3552
}
#line 3552

int
#line 3553
ncx_putn_double_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3553
{
#line 3553
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3553

#line 3553
 /* basic algorithm is:
#line 3553
  *   - ensure sane alignment of output data
#line 3553
  *   - copy (conversion happens automatically) input data
#line 3553
  *     to output
#line 3553
  *   - update tp to point at next unconverted input, and xpp to point
#line 3553
  *     at next location for converted output
#line 3553
  */
#line 3553
  long i, j, ni;
#line 3553
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3553
  double *xp;
#line 3553
  int nrange = 0;         /* number of range errors */
#line 3553
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3553
  long cxp = (long) *((char**)xpp);
#line 3553

#line 3553
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3553
  /* sjl: manually stripmine so we can limit amount of
#line 3553
   * vector work space reserved to LOOPCNT elements. Also
#line 3553
   * makes vectorisation easy */
#line 3553
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3553
    ni=Min(nelems-j,LOOPCNT);
#line 3553
    if (realign) {
#line 3553
      xp = tmp;
#line 3553
    } else {
#line 3553
      xp = (double *) *xpp;
#line 3553
    }
#line 3553
   /* copy the next block */
#line 3553
#pragma cdir loopcnt=LOOPCNT
#line 3553
#pragma cdir shortloop
#line 3553
    for (i=0; i<ni; i++) {
#line 3553
      /* the normal case: */
#line 3553
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3553
     /* test for range errors (not always needed but do it anyway) */
#line 3553
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3553
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3553
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3553
    }
#line 3553
   /* copy workspace back if necessary */
#line 3553
    if (realign) {
#line 3553
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3553
      xp = (double *) *xpp;
#line 3553
    }
#line 3553
   /* update xpp and tp */
#line 3553
    xp += ni;
#line 3553
    tp += ni;
#line 3553
    *xpp = (void*)xp;
#line 3553
  }
#line 3553
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3553

#line 3553
#else   /* not SX */
#line 3553

#line 3553
	char *xp = (char *) *xpp;
#line 3553
	int status = NC_NOERR;
#line 3553

#line 3553
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3553
	{
#line 3553
		int lstatus = ncx_put_double_uchar(xp, tp, fillp);
#line 3553
		if (status == NC_NOERR) /* report the first encountered error */
#line 3553
			status = lstatus;
#line 3553
	}
#line 3553

#line 3553
	*xpp = (void *)xp;
#line 3553
	return status;
#line 3553
#endif
#line 3553
}
#line 3553

int
#line 3554
ncx_putn_double_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3554
{
#line 3554
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3554

#line 3554
 /* basic algorithm is:
#line 3554
  *   - ensure sane alignment of output data
#line 3554
  *   - copy (conversion happens automatically) input data
#line 3554
  *     to output
#line 3554
  *   - update tp to point at next unconverted input, and xpp to point
#line 3554
  *     at next location for converted output
#line 3554
  */
#line 3554
  long i, j, ni;
#line 3554
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3554
  double *xp;
#line 3554
  int nrange = 0;         /* number of range errors */
#line 3554
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3554
  long cxp = (long) *((char**)xpp);
#line 3554

#line 3554
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3554
  /* sjl: manually stripmine so we can limit amount of
#line 3554
   * vector work space reserved to LOOPCNT elements. Also
#line 3554
   * makes vectorisation easy */
#line 3554
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3554
    ni=Min(nelems-j,LOOPCNT);
#line 3554
    if (realign) {
#line 3554
      xp = tmp;
#line 3554
    } else {
#line 3554
      xp = (double *) *xpp;
#line 3554
    }
#line 3554
   /* copy the next block */
#line 3554
#pragma cdir loopcnt=LOOPCNT
#line 3554
#pragma cdir shortloop
#line 3554
    for (i=0; i<ni; i++) {
#line 3554
      /* the normal case: */
#line 3554
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3554
     /* test for range errors (not always needed but do it anyway) */
#line 3554
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3554
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3554
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3554
    }
#line 3554
   /* copy workspace back if necessary */
#line 3554
    if (realign) {
#line 3554
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3554
      xp = (double *) *xpp;
#line 3554
    }
#line 3554
   /* update xpp and tp */
#line 3554
    xp += ni;
#line 3554
    tp += ni;
#line 3554
    *xpp = (void*)xp;
#line 3554
  }
#line 3554
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3554

#line 3554
#else   /* not SX */
#line 3554

#line 3554
	char *xp = (char *) *xpp;
#line 3554
	int status = NC_NOERR;
#line 3554

#line 3554
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3554
	{
#line 3554
		int lstatus = ncx_put_double_ushort(xp, tp, fillp);
#line 3554
		if (status == NC_NOERR) /* report the first encountered error */
#line 3554
			status = lstatus;
#line 3554
	}
#line 3554

#line 3554
	*xpp = (void *)xp;
#line 3554
	return status;
#line 3554
#endif
#line 3554
}
#line 3554

int
#line 3555
ncx_putn_double_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3555
{
#line 3555
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3555

#line 3555
 /* basic algorithm is:
#line 3555
  *   - ensure sane alignment of output data
#line 3555
  *   - copy (conversion happens automatically) input data
#line 3555
  *     to output
#line 3555
  *   - update tp to point at next unconverted input, and xpp to point
#line 3555
  *     at next location for converted output
#line 3555
  */
#line 3555
  long i, j, ni;
#line 3555
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3555
  double *xp;
#line 3555
  int nrange = 0;         /* number of range errors */
#line 3555
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3555
  long cxp = (long) *((char**)xpp);
#line 3555

#line 3555
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3555
  /* sjl: manually stripmine so we can limit amount of
#line 3555
   * vector work space reserved to LOOPCNT elements. Also
#line 3555
   * makes vectorisation easy */
#line 3555
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3555
    ni=Min(nelems-j,LOOPCNT);
#line 3555
    if (realign) {
#line 3555
      xp = tmp;
#line 3555
    } else {
#line 3555
      xp = (double *) *xpp;
#line 3555
    }
#line 3555
   /* copy the next block */
#line 3555
#pragma cdir loopcnt=LOOPCNT
#line 3555
#pragma cdir shortloop
#line 3555
    for (i=0; i<ni; i++) {
#line 3555
      /* the normal case: */
#line 3555
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3555
     /* test for range errors (not always needed but do it anyway) */
#line 3555
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3555
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3555
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3555
    }
#line 3555
   /* copy workspace back if necessary */
#line 3555
    if (realign) {
#line 3555
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3555
      xp = (double *) *xpp;
#line 3555
    }
#line 3555
   /* update xpp and tp */
#line 3555
    xp += ni;
#line 3555
    tp += ni;
#line 3555
    *xpp = (void*)xp;
#line 3555
  }
#line 3555
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3555

#line 3555
#else   /* not SX */
#line 3555

#line 3555
	char *xp = (char *) *xpp;
#line 3555
	int status = NC_NOERR;
#line 3555

#line 3555
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3555
	{
#line 3555
		int lstatus = ncx_put_double_uint(xp, tp, fillp);
#line 3555
		if (status == NC_NOERR) /* report the first encountered error */
#line 3555
			status = lstatus;
#line 3555
	}
#line 3555

#line 3555
	*xpp = (void *)xp;
#line 3555
	return status;
#line 3555
#endif
#line 3555
}
#line 3555

int
#line 3556
ncx_putn_double_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3556
{
#line 3556
#if defined(_SX) && _SX != 0 && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3556

#line 3556
 /* basic algorithm is:
#line 3556
  *   - ensure sane alignment of output data
#line 3556
  *   - copy (conversion happens automatically) input data
#line 3556
  *     to output
#line 3556
  *   - update tp to point at next unconverted input, and xpp to point
#line 3556
  *     at next location for converted output
#line 3556
  */
#line 3556
  long i, j, ni;
#line 3556
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3556
  double *xp;
#line 3556
  int nrange = 0;         /* number of range errors */
#line 3556
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3556
  long cxp = (long) *((char**)xpp);
#line 3556

#line 3556
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3556
  /* sjl: manually stripmine so we can limit amount of
#line 3556
   * vector work space reserved to LOOPCNT elements. Also
#line 3556
   * makes vectorisation easy */
#line 3556
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3556
    ni=Min(nelems-j,LOOPCNT);
#line 3556
    if (realign) {
#line 3556
      xp = tmp;
#line 3556
    } else {
#line 3556
      xp = (double *) *xpp;
#line 3556
    }
#line 3556
   /* copy the next block */
#line 3556
#pragma cdir loopcnt=LOOPCNT
#line 3556
#pragma cdir shortloop
#line 3556
    for (i=0; i<ni; i++) {
#line 3556
      /* the normal case: */
#line 3556
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3556
     /* test for range errors (not always needed but do it anyway) */
#line 3556
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3556
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3556
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3556
    }
#line 3556
   /* copy workspace back if necessary */
#line 3556
    if (realign) {
#line 3556
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_DOUBLE);
#line 3556
      xp = (double *) *xpp;
#line 3556
    }
#line 3556
   /* update xpp and tp */
#line 3556
    xp += ni;
#line 3556
    tp += ni;
#line 3556
    *xpp = (void*)xp;
#line 3556
  }
#line 3556
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3556

#line 3556
#else   /* not SX */
#line 3556

#line 3556
	char *xp = (char *) *xpp;
#line 3556
	int status = NC_NOERR;
#line 3556

#line 3556
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3556
	{
#line 3556
		int lstatus = ncx_put_double_ulonglong(xp, tp, fillp);
#line 3556
		if (status == NC_NOERR) /* report the first encountered error */
#line 3556
			status = lstatus;
#line 3556
	}
#line 3556

#line 3556
	*xpp = (void *)xp;
#line 3556
	return status;
#line 3556
#endif
#line 3556
}
#line 3556



/* longlong ------------------------------------------------------------------*/

#if X_SIZEOF_INT64 == SIZEOF_LONGLONG
/* optimized version */
int
ncx_getn_longlong_longlong(const void **xpp, size_t nelems, long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_LONG_LONG);
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_INT64);
	return NC_NOERR;
}
#else
int
#line 3575
ncx_getn_longlong_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3575
{
#line 3575
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3575

#line 3575
 /* basic algorithm is:
#line 3575
  *   - ensure sane alignment of input data
#line 3575
  *   - copy (conversion happens automatically) input data
#line 3575
  *     to output
#line 3575
  *   - update xpp to point at next unconverted input, and tp to point
#line 3575
  *     at next location for converted output
#line 3575
  */
#line 3575
  long i, j, ni;
#line 3575
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3575
  int64 *xp;
#line 3575
  int nrange = 0;         /* number of range errors */
#line 3575
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3575
  long cxp = (long) *((char**)xpp);
#line 3575

#line 3575
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3575
  /* sjl: manually stripmine so we can limit amount of
#line 3575
   * vector work space reserved to LOOPCNT elements. Also
#line 3575
   * makes vectorisation easy */
#line 3575
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3575
    ni=Min(nelems-j,LOOPCNT);
#line 3575
    if (realign) {
#line 3575
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3575
      xp = tmp;
#line 3575
    } else {
#line 3575
      xp = (int64 *) *xpp;
#line 3575
    }
#line 3575
   /* copy the next block */
#line 3575
#pragma cdir loopcnt=LOOPCNT
#line 3575
#pragma cdir shortloop
#line 3575
    for (i=0; i<ni; i++) {
#line 3575
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3575
     /* test for range errors (not always needed but do it anyway) */
#line 3575
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3575
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3575
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3575
    }
#line 3575
   /* update xpp and tp */
#line 3575
    if (realign) xp = (int64 *) *xpp;
#line 3575
    xp += ni;
#line 3575
    tp += ni;
#line 3575
    *xpp = (void*)xp;
#line 3575
  }
#line 3575
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3575

#line 3575
#else   /* not SX */
#line 3575
	const char *xp = (const char *) *xpp;
#line 3575
	int status = NC_NOERR;
#line 3575

#line 3575
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3575
	{
#line 3575
		const int lstatus = ncx_get_longlong_longlong(xp, tp);
#line 3575
		if (status == NC_NOERR) /* report the first encountered error */
#line 3575
			status = lstatus;
#line 3575
	}
#line 3575

#line 3575
	*xpp = (const void *)xp;
#line 3575
	return status;
#line 3575
#endif
#line 3575
}
#line 3575

#endif
int
#line 3577
ncx_getn_longlong_schar(const void **xpp, size_t nelems, schar *tp)
#line 3577
{
#line 3577
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3577

#line 3577
 /* basic algorithm is:
#line 3577
  *   - ensure sane alignment of input data
#line 3577
  *   - copy (conversion happens automatically) input data
#line 3577
  *     to output
#line 3577
  *   - update xpp to point at next unconverted input, and tp to point
#line 3577
  *     at next location for converted output
#line 3577
  */
#line 3577
  long i, j, ni;
#line 3577
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3577
  int64 *xp;
#line 3577
  int nrange = 0;         /* number of range errors */
#line 3577
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3577
  long cxp = (long) *((char**)xpp);
#line 3577

#line 3577
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3577
  /* sjl: manually stripmine so we can limit amount of
#line 3577
   * vector work space reserved to LOOPCNT elements. Also
#line 3577
   * makes vectorisation easy */
#line 3577
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3577
    ni=Min(nelems-j,LOOPCNT);
#line 3577
    if (realign) {
#line 3577
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3577
      xp = tmp;
#line 3577
    } else {
#line 3577
      xp = (int64 *) *xpp;
#line 3577
    }
#line 3577
   /* copy the next block */
#line 3577
#pragma cdir loopcnt=LOOPCNT
#line 3577
#pragma cdir shortloop
#line 3577
    for (i=0; i<ni; i++) {
#line 3577
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3577
     /* test for range errors (not always needed but do it anyway) */
#line 3577
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3577
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3577
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3577
    }
#line 3577
   /* update xpp and tp */
#line 3577
    if (realign) xp = (int64 *) *xpp;
#line 3577
    xp += ni;
#line 3577
    tp += ni;
#line 3577
    *xpp = (void*)xp;
#line 3577
  }
#line 3577
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3577

#line 3577
#else   /* not SX */
#line 3577
	const char *xp = (const char *) *xpp;
#line 3577
	int status = NC_NOERR;
#line 3577

#line 3577
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3577
	{
#line 3577
		const int lstatus = ncx_get_longlong_schar(xp, tp);
#line 3577
		if (status == NC_NOERR) /* report the first encountered error */
#line 3577
			status = lstatus;
#line 3577
	}
#line 3577

#line 3577
	*xpp = (const void *)xp;
#line 3577
	return status;
#line 3577
#endif
#line 3577
}
#line 3577

int
#line 3578
ncx_getn_longlong_short(const void **xpp, size_t nelems, short *tp)
#line 3578
{
#line 3578
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3578

#line 3578
 /* basic algorithm is:
#line 3578
  *   - ensure sane alignment of input data
#line 3578
  *   - copy (conversion happens automatically) input data
#line 3578
  *     to output
#line 3578
  *   - update xpp to point at next unconverted input, and tp to point
#line 3578
  *     at next location for converted output
#line 3578
  */
#line 3578
  long i, j, ni;
#line 3578
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3578
  int64 *xp;
#line 3578
  int nrange = 0;         /* number of range errors */
#line 3578
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3578
  long cxp = (long) *((char**)xpp);
#line 3578

#line 3578
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3578
  /* sjl: manually stripmine so we can limit amount of
#line 3578
   * vector work space reserved to LOOPCNT elements. Also
#line 3578
   * makes vectorisation easy */
#line 3578
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3578
    ni=Min(nelems-j,LOOPCNT);
#line 3578
    if (realign) {
#line 3578
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3578
      xp = tmp;
#line 3578
    } else {
#line 3578
      xp = (int64 *) *xpp;
#line 3578
    }
#line 3578
   /* copy the next block */
#line 3578
#pragma cdir loopcnt=LOOPCNT
#line 3578
#pragma cdir shortloop
#line 3578
    for (i=0; i<ni; i++) {
#line 3578
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3578
     /* test for range errors (not always needed but do it anyway) */
#line 3578
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3578
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3578
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3578
    }
#line 3578
   /* update xpp and tp */
#line 3578
    if (realign) xp = (int64 *) *xpp;
#line 3578
    xp += ni;
#line 3578
    tp += ni;
#line 3578
    *xpp = (void*)xp;
#line 3578
  }
#line 3578
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3578

#line 3578
#else   /* not SX */
#line 3578
	const char *xp = (const char *) *xpp;
#line 3578
	int status = NC_NOERR;
#line 3578

#line 3578
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3578
	{
#line 3578
		const int lstatus = ncx_get_longlong_short(xp, tp);
#line 3578
		if (status == NC_NOERR) /* report the first encountered error */
#line 3578
			status = lstatus;
#line 3578
	}
#line 3578

#line 3578
	*xpp = (const void *)xp;
#line 3578
	return status;
#line 3578
#endif
#line 3578
}
#line 3578

int
#line 3579
ncx_getn_longlong_int(const void **xpp, size_t nelems, int *tp)
#line 3579
{
#line 3579
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3579

#line 3579
 /* basic algorithm is:
#line 3579
  *   - ensure sane alignment of input data
#line 3579
  *   - copy (conversion happens automatically) input data
#line 3579
  *     to output
#line 3579
  *   - update xpp to point at next unconverted input, and tp to point
#line 3579
  *     at next location for converted output
#line 3579
  */
#line 3579
  long i, j, ni;
#line 3579
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3579
  int64 *xp;
#line 3579
  int nrange = 0;         /* number of range errors */
#line 3579
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3579
  long cxp = (long) *((char**)xpp);
#line 3579

#line 3579
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3579
  /* sjl: manually stripmine so we can limit amount of
#line 3579
   * vector work space reserved to LOOPCNT elements. Also
#line 3579
   * makes vectorisation easy */
#line 3579
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3579
    ni=Min(nelems-j,LOOPCNT);
#line 3579
    if (realign) {
#line 3579
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3579
      xp = tmp;
#line 3579
    } else {
#line 3579
      xp = (int64 *) *xpp;
#line 3579
    }
#line 3579
   /* copy the next block */
#line 3579
#pragma cdir loopcnt=LOOPCNT
#line 3579
#pragma cdir shortloop
#line 3579
    for (i=0; i<ni; i++) {
#line 3579
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3579
     /* test for range errors (not always needed but do it anyway) */
#line 3579
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3579
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3579
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3579
    }
#line 3579
   /* update xpp and tp */
#line 3579
    if (realign) xp = (int64 *) *xpp;
#line 3579
    xp += ni;
#line 3579
    tp += ni;
#line 3579
    *xpp = (void*)xp;
#line 3579
  }
#line 3579
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3579

#line 3579
#else   /* not SX */
#line 3579
	const char *xp = (const char *) *xpp;
#line 3579
	int status = NC_NOERR;
#line 3579

#line 3579
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3579
	{
#line 3579
		const int lstatus = ncx_get_longlong_int(xp, tp);
#line 3579
		if (status == NC_NOERR) /* report the first encountered error */
#line 3579
			status = lstatus;
#line 3579
	}
#line 3579

#line 3579
	*xpp = (const void *)xp;
#line 3579
	return status;
#line 3579
#endif
#line 3579
}
#line 3579

int
#line 3580
ncx_getn_longlong_long(const void **xpp, size_t nelems, long *tp)
#line 3580
{
#line 3580
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3580

#line 3580
 /* basic algorithm is:
#line 3580
  *   - ensure sane alignment of input data
#line 3580
  *   - copy (conversion happens automatically) input data
#line 3580
  *     to output
#line 3580
  *   - update xpp to point at next unconverted input, and tp to point
#line 3580
  *     at next location for converted output
#line 3580
  */
#line 3580
  long i, j, ni;
#line 3580
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3580
  int64 *xp;
#line 3580
  int nrange = 0;         /* number of range errors */
#line 3580
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3580
  long cxp = (long) *((char**)xpp);
#line 3580

#line 3580
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3580
  /* sjl: manually stripmine so we can limit amount of
#line 3580
   * vector work space reserved to LOOPCNT elements. Also
#line 3580
   * makes vectorisation easy */
#line 3580
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3580
    ni=Min(nelems-j,LOOPCNT);
#line 3580
    if (realign) {
#line 3580
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3580
      xp = tmp;
#line 3580
    } else {
#line 3580
      xp = (int64 *) *xpp;
#line 3580
    }
#line 3580
   /* copy the next block */
#line 3580
#pragma cdir loopcnt=LOOPCNT
#line 3580
#pragma cdir shortloop
#line 3580
    for (i=0; i<ni; i++) {
#line 3580
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3580
     /* test for range errors (not always needed but do it anyway) */
#line 3580
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3580
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3580
      nrange += xp[i] > LONG_MAX || xp[i] < LONG_MIN;
#line 3580
    }
#line 3580
   /* update xpp and tp */
#line 3580
    if (realign) xp = (int64 *) *xpp;
#line 3580
    xp += ni;
#line 3580
    tp += ni;
#line 3580
    *xpp = (void*)xp;
#line 3580
  }
#line 3580
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3580

#line 3580
#else   /* not SX */
#line 3580
	const char *xp = (const char *) *xpp;
#line 3580
	int status = NC_NOERR;
#line 3580

#line 3580
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3580
	{
#line 3580
		const int lstatus = ncx_get_longlong_long(xp, tp);
#line 3580
		if (status == NC_NOERR) /* report the first encountered error */
#line 3580
			status = lstatus;
#line 3580
	}
#line 3580

#line 3580
	*xpp = (const void *)xp;
#line 3580
	return status;
#line 3580
#endif
#line 3580
}
#line 3580

int
#line 3581
ncx_getn_longlong_float(const void **xpp, size_t nelems, float *tp)
#line 3581
{
#line 3581
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3581

#line 3581
 /* basic algorithm is:
#line 3581
  *   - ensure sane alignment of input data
#line 3581
  *   - copy (conversion happens automatically) input data
#line 3581
  *     to output
#line 3581
  *   - update xpp to point at next unconverted input, and tp to point
#line 3581
  *     at next location for converted output
#line 3581
  */
#line 3581
  long i, j, ni;
#line 3581
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3581
  int64 *xp;
#line 3581
  int nrange = 0;         /* number of range errors */
#line 3581
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3581
  long cxp = (long) *((char**)xpp);
#line 3581

#line 3581
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3581
  /* sjl: manually stripmine so we can limit amount of
#line 3581
   * vector work space reserved to LOOPCNT elements. Also
#line 3581
   * makes vectorisation easy */
#line 3581
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3581
    ni=Min(nelems-j,LOOPCNT);
#line 3581
    if (realign) {
#line 3581
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3581
      xp = tmp;
#line 3581
    } else {
#line 3581
      xp = (int64 *) *xpp;
#line 3581
    }
#line 3581
   /* copy the next block */
#line 3581
#pragma cdir loopcnt=LOOPCNT
#line 3581
#pragma cdir shortloop
#line 3581
    for (i=0; i<ni; i++) {
#line 3581
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3581
     /* test for range errors (not always needed but do it anyway) */
#line 3581
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3581
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3581
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3581
    }
#line 3581
   /* update xpp and tp */
#line 3581
    if (realign) xp = (int64 *) *xpp;
#line 3581
    xp += ni;
#line 3581
    tp += ni;
#line 3581
    *xpp = (void*)xp;
#line 3581
  }
#line 3581
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3581

#line 3581
#else   /* not SX */
#line 3581
	const char *xp = (const char *) *xpp;
#line 3581
	int status = NC_NOERR;
#line 3581

#line 3581
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3581
	{
#line 3581
		const int lstatus = ncx_get_longlong_float(xp, tp);
#line 3581
		if (status == NC_NOERR) /* report the first encountered error */
#line 3581
			status = lstatus;
#line 3581
	}
#line 3581

#line 3581
	*xpp = (const void *)xp;
#line 3581
	return status;
#line 3581
#endif
#line 3581
}
#line 3581

int
#line 3582
ncx_getn_longlong_double(const void **xpp, size_t nelems, double *tp)
#line 3582
{
#line 3582
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3582

#line 3582
 /* basic algorithm is:
#line 3582
  *   - ensure sane alignment of input data
#line 3582
  *   - copy (conversion happens automatically) input data
#line 3582
  *     to output
#line 3582
  *   - update xpp to point at next unconverted input, and tp to point
#line 3582
  *     at next location for converted output
#line 3582
  */
#line 3582
  long i, j, ni;
#line 3582
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3582
  int64 *xp;
#line 3582
  int nrange = 0;         /* number of range errors */
#line 3582
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3582
  long cxp = (long) *((char**)xpp);
#line 3582

#line 3582
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3582
  /* sjl: manually stripmine so we can limit amount of
#line 3582
   * vector work space reserved to LOOPCNT elements. Also
#line 3582
   * makes vectorisation easy */
#line 3582
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3582
    ni=Min(nelems-j,LOOPCNT);
#line 3582
    if (realign) {
#line 3582
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3582
      xp = tmp;
#line 3582
    } else {
#line 3582
      xp = (int64 *) *xpp;
#line 3582
    }
#line 3582
   /* copy the next block */
#line 3582
#pragma cdir loopcnt=LOOPCNT
#line 3582
#pragma cdir shortloop
#line 3582
    for (i=0; i<ni; i++) {
#line 3582
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3582
     /* test for range errors (not always needed but do it anyway) */
#line 3582
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3582
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3582
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3582
    }
#line 3582
   /* update xpp and tp */
#line 3582
    if (realign) xp = (int64 *) *xpp;
#line 3582
    xp += ni;
#line 3582
    tp += ni;
#line 3582
    *xpp = (void*)xp;
#line 3582
  }
#line 3582
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3582

#line 3582
#else   /* not SX */
#line 3582
	const char *xp = (const char *) *xpp;
#line 3582
	int status = NC_NOERR;
#line 3582

#line 3582
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3582
	{
#line 3582
		const int lstatus = ncx_get_longlong_double(xp, tp);
#line 3582
		if (status == NC_NOERR) /* report the first encountered error */
#line 3582
			status = lstatus;
#line 3582
	}
#line 3582

#line 3582
	*xpp = (const void *)xp;
#line 3582
	return status;
#line 3582
#endif
#line 3582
}
#line 3582

int
#line 3583
ncx_getn_longlong_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3583
{
#line 3583
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3583

#line 3583
 /* basic algorithm is:
#line 3583
  *   - ensure sane alignment of input data
#line 3583
  *   - copy (conversion happens automatically) input data
#line 3583
  *     to output
#line 3583
  *   - update xpp to point at next unconverted input, and tp to point
#line 3583
  *     at next location for converted output
#line 3583
  */
#line 3583
  long i, j, ni;
#line 3583
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3583
  int64 *xp;
#line 3583
  int nrange = 0;         /* number of range errors */
#line 3583
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3583
  long cxp = (long) *((char**)xpp);
#line 3583

#line 3583
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3583
  /* sjl: manually stripmine so we can limit amount of
#line 3583
   * vector work space reserved to LOOPCNT elements. Also
#line 3583
   * makes vectorisation easy */
#line 3583
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3583
    ni=Min(nelems-j,LOOPCNT);
#line 3583
    if (realign) {
#line 3583
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3583
      xp = tmp;
#line 3583
    } else {
#line 3583
      xp = (int64 *) *xpp;
#line 3583
    }
#line 3583
   /* copy the next block */
#line 3583
#pragma cdir loopcnt=LOOPCNT
#line 3583
#pragma cdir shortloop
#line 3583
    for (i=0; i<ni; i++) {
#line 3583
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3583
     /* test for range errors (not always needed but do it anyway) */
#line 3583
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3583
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3583
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3583
    }
#line 3583
   /* update xpp and tp */
#line 3583
    if (realign) xp = (int64 *) *xpp;
#line 3583
    xp += ni;
#line 3583
    tp += ni;
#line 3583
    *xpp = (void*)xp;
#line 3583
  }
#line 3583
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3583

#line 3583
#else   /* not SX */
#line 3583
	const char *xp = (const char *) *xpp;
#line 3583
	int status = NC_NOERR;
#line 3583

#line 3583
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3583
	{
#line 3583
		const int lstatus = ncx_get_longlong_uchar(xp, tp);
#line 3583
		if (status == NC_NOERR) /* report the first encountered error */
#line 3583
			status = lstatus;
#line 3583
	}
#line 3583

#line 3583
	*xpp = (const void *)xp;
#line 3583
	return status;
#line 3583
#endif
#line 3583
}
#line 3583

int
#line 3584
ncx_getn_longlong_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3584
{
#line 3584
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3584

#line 3584
 /* basic algorithm is:
#line 3584
  *   - ensure sane alignment of input data
#line 3584
  *   - copy (conversion happens automatically) input data
#line 3584
  *     to output
#line 3584
  *   - update xpp to point at next unconverted input, and tp to point
#line 3584
  *     at next location for converted output
#line 3584
  */
#line 3584
  long i, j, ni;
#line 3584
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3584
  int64 *xp;
#line 3584
  int nrange = 0;         /* number of range errors */
#line 3584
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3584
  long cxp = (long) *((char**)xpp);
#line 3584

#line 3584
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3584
  /* sjl: manually stripmine so we can limit amount of
#line 3584
   * vector work space reserved to LOOPCNT elements. Also
#line 3584
   * makes vectorisation easy */
#line 3584
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3584
    ni=Min(nelems-j,LOOPCNT);
#line 3584
    if (realign) {
#line 3584
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3584
      xp = tmp;
#line 3584
    } else {
#line 3584
      xp = (int64 *) *xpp;
#line 3584
    }
#line 3584
   /* copy the next block */
#line 3584
#pragma cdir loopcnt=LOOPCNT
#line 3584
#pragma cdir shortloop
#line 3584
    for (i=0; i<ni; i++) {
#line 3584
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3584
     /* test for range errors (not always needed but do it anyway) */
#line 3584
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3584
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3584
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3584
    }
#line 3584
   /* update xpp and tp */
#line 3584
    if (realign) xp = (int64 *) *xpp;
#line 3584
    xp += ni;
#line 3584
    tp += ni;
#line 3584
    *xpp = (void*)xp;
#line 3584
  }
#line 3584
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3584

#line 3584
#else   /* not SX */
#line 3584
	const char *xp = (const char *) *xpp;
#line 3584
	int status = NC_NOERR;
#line 3584

#line 3584
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3584
	{
#line 3584
		const int lstatus = ncx_get_longlong_ushort(xp, tp);
#line 3584
		if (status == NC_NOERR) /* report the first encountered error */
#line 3584
			status = lstatus;
#line 3584
	}
#line 3584

#line 3584
	*xpp = (const void *)xp;
#line 3584
	return status;
#line 3584
#endif
#line 3584
}
#line 3584

int
#line 3585
ncx_getn_longlong_uint(const void **xpp, size_t nelems, uint *tp)
#line 3585
{
#line 3585
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3585

#line 3585
 /* basic algorithm is:
#line 3585
  *   - ensure sane alignment of input data
#line 3585
  *   - copy (conversion happens automatically) input data
#line 3585
  *     to output
#line 3585
  *   - update xpp to point at next unconverted input, and tp to point
#line 3585
  *     at next location for converted output
#line 3585
  */
#line 3585
  long i, j, ni;
#line 3585
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3585
  int64 *xp;
#line 3585
  int nrange = 0;         /* number of range errors */
#line 3585
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3585
  long cxp = (long) *((char**)xpp);
#line 3585

#line 3585
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3585
  /* sjl: manually stripmine so we can limit amount of
#line 3585
   * vector work space reserved to LOOPCNT elements. Also
#line 3585
   * makes vectorisation easy */
#line 3585
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3585
    ni=Min(nelems-j,LOOPCNT);
#line 3585
    if (realign) {
#line 3585
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3585
      xp = tmp;
#line 3585
    } else {
#line 3585
      xp = (int64 *) *xpp;
#line 3585
    }
#line 3585
   /* copy the next block */
#line 3585
#pragma cdir loopcnt=LOOPCNT
#line 3585
#pragma cdir shortloop
#line 3585
    for (i=0; i<ni; i++) {
#line 3585
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3585
     /* test for range errors (not always needed but do it anyway) */
#line 3585
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3585
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3585
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3585
    }
#line 3585
   /* update xpp and tp */
#line 3585
    if (realign) xp = (int64 *) *xpp;
#line 3585
    xp += ni;
#line 3585
    tp += ni;
#line 3585
    *xpp = (void*)xp;
#line 3585
  }
#line 3585
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3585

#line 3585
#else   /* not SX */
#line 3585
	const char *xp = (const char *) *xpp;
#line 3585
	int status = NC_NOERR;
#line 3585

#line 3585
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3585
	{
#line 3585
		const int lstatus = ncx_get_longlong_uint(xp, tp);
#line 3585
		if (status == NC_NOERR) /* report the first encountered error */
#line 3585
			status = lstatus;
#line 3585
	}
#line 3585

#line 3585
	*xpp = (const void *)xp;
#line 3585
	return status;
#line 3585
#endif
#line 3585
}
#line 3585

int
#line 3586
ncx_getn_longlong_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3586
{
#line 3586
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3586

#line 3586
 /* basic algorithm is:
#line 3586
  *   - ensure sane alignment of input data
#line 3586
  *   - copy (conversion happens automatically) input data
#line 3586
  *     to output
#line 3586
  *   - update xpp to point at next unconverted input, and tp to point
#line 3586
  *     at next location for converted output
#line 3586
  */
#line 3586
  long i, j, ni;
#line 3586
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3586
  int64 *xp;
#line 3586
  int nrange = 0;         /* number of range errors */
#line 3586
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3586
  long cxp = (long) *((char**)xpp);
#line 3586

#line 3586
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3586
  /* sjl: manually stripmine so we can limit amount of
#line 3586
   * vector work space reserved to LOOPCNT elements. Also
#line 3586
   * makes vectorisation easy */
#line 3586
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3586
    ni=Min(nelems-j,LOOPCNT);
#line 3586
    if (realign) {
#line 3586
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_INT64));
#line 3586
      xp = tmp;
#line 3586
    } else {
#line 3586
      xp = (int64 *) *xpp;
#line 3586
    }
#line 3586
   /* copy the next block */
#line 3586
#pragma cdir loopcnt=LOOPCNT
#line 3586
#pragma cdir shortloop
#line 3586
    for (i=0; i<ni; i++) {
#line 3586
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3586
     /* test for range errors (not always needed but do it anyway) */
#line 3586
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3586
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3586
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3586
    }
#line 3586
   /* update xpp and tp */
#line 3586
    if (realign) xp = (int64 *) *xpp;
#line 3586
    xp += ni;
#line 3586
    tp += ni;
#line 3586
    *xpp = (void*)xp;
#line 3586
  }
#line 3586
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3586

#line 3586
#else   /* not SX */
#line 3586
	const char *xp = (const char *) *xpp;
#line 3586
	int status = NC_NOERR;
#line 3586

#line 3586
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3586
	{
#line 3586
		const int lstatus = ncx_get_longlong_ulonglong(xp, tp);
#line 3586
		if (status == NC_NOERR) /* report the first encountered error */
#line 3586
			status = lstatus;
#line 3586
	}
#line 3586

#line 3586
	*xpp = (const void *)xp;
#line 3586
	return status;
#line 3586
#endif
#line 3586
}
#line 3586


#if X_SIZEOF_INT64 == SIZEOF_LONGLONG
/* optimized version */
int
ncx_putn_longlong_longlong(void **xpp, size_t nelems, const long long *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_INT64);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT64);
	return NC_NOERR;
}
#else
int
#line 3602
ncx_putn_longlong_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3602
{
#line 3602
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3602

#line 3602
 /* basic algorithm is:
#line 3602
  *   - ensure sane alignment of output data
#line 3602
  *   - copy (conversion happens automatically) input data
#line 3602
  *     to output
#line 3602
  *   - update tp to point at next unconverted input, and xpp to point
#line 3602
  *     at next location for converted output
#line 3602
  */
#line 3602
  long i, j, ni;
#line 3602
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3602
  int64 *xp;
#line 3602
  int nrange = 0;         /* number of range errors */
#line 3602
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3602
  long cxp = (long) *((char**)xpp);
#line 3602

#line 3602
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3602
  /* sjl: manually stripmine so we can limit amount of
#line 3602
   * vector work space reserved to LOOPCNT elements. Also
#line 3602
   * makes vectorisation easy */
#line 3602
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3602
    ni=Min(nelems-j,LOOPCNT);
#line 3602
    if (realign) {
#line 3602
      xp = tmp;
#line 3602
    } else {
#line 3602
      xp = (int64 *) *xpp;
#line 3602
    }
#line 3602
   /* copy the next block */
#line 3602
#pragma cdir loopcnt=LOOPCNT
#line 3602
#pragma cdir shortloop
#line 3602
    for (i=0; i<ni; i++) {
#line 3602
      /* the normal case: */
#line 3602
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3602
     /* test for range errors (not always needed but do it anyway) */
#line 3602
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3602
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3602
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3602
    }
#line 3602
   /* copy workspace back if necessary */
#line 3602
    if (realign) {
#line 3602
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3602
      xp = (int64 *) *xpp;
#line 3602
    }
#line 3602
   /* update xpp and tp */
#line 3602
    xp += ni;
#line 3602
    tp += ni;
#line 3602
    *xpp = (void*)xp;
#line 3602
  }
#line 3602
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3602

#line 3602
#else   /* not SX */
#line 3602

#line 3602
	char *xp = (char *) *xpp;
#line 3602
	int status = NC_NOERR;
#line 3602

#line 3602
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3602
	{
#line 3602
		int lstatus = ncx_put_longlong_longlong(xp, tp, fillp);
#line 3602
		if (status == NC_NOERR) /* report the first encountered error */
#line 3602
			status = lstatus;
#line 3602
	}
#line 3602

#line 3602
	*xpp = (void *)xp;
#line 3602
	return status;
#line 3602
#endif
#line 3602
}
#line 3602

#endif
int
#line 3604
ncx_putn_longlong_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3604
{
#line 3604
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3604

#line 3604
 /* basic algorithm is:
#line 3604
  *   - ensure sane alignment of output data
#line 3604
  *   - copy (conversion happens automatically) input data
#line 3604
  *     to output
#line 3604
  *   - update tp to point at next unconverted input, and xpp to point
#line 3604
  *     at next location for converted output
#line 3604
  */
#line 3604
  long i, j, ni;
#line 3604
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3604
  int64 *xp;
#line 3604
  int nrange = 0;         /* number of range errors */
#line 3604
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3604
  long cxp = (long) *((char**)xpp);
#line 3604

#line 3604
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3604
  /* sjl: manually stripmine so we can limit amount of
#line 3604
   * vector work space reserved to LOOPCNT elements. Also
#line 3604
   * makes vectorisation easy */
#line 3604
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3604
    ni=Min(nelems-j,LOOPCNT);
#line 3604
    if (realign) {
#line 3604
      xp = tmp;
#line 3604
    } else {
#line 3604
      xp = (int64 *) *xpp;
#line 3604
    }
#line 3604
   /* copy the next block */
#line 3604
#pragma cdir loopcnt=LOOPCNT
#line 3604
#pragma cdir shortloop
#line 3604
    for (i=0; i<ni; i++) {
#line 3604
      /* the normal case: */
#line 3604
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3604
     /* test for range errors (not always needed but do it anyway) */
#line 3604
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3604
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3604
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3604
    }
#line 3604
   /* copy workspace back if necessary */
#line 3604
    if (realign) {
#line 3604
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3604
      xp = (int64 *) *xpp;
#line 3604
    }
#line 3604
   /* update xpp and tp */
#line 3604
    xp += ni;
#line 3604
    tp += ni;
#line 3604
    *xpp = (void*)xp;
#line 3604
  }
#line 3604
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3604

#line 3604
#else   /* not SX */
#line 3604

#line 3604
	char *xp = (char *) *xpp;
#line 3604
	int status = NC_NOERR;
#line 3604

#line 3604
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3604
	{
#line 3604
		int lstatus = ncx_put_longlong_schar(xp, tp, fillp);
#line 3604
		if (status == NC_NOERR) /* report the first encountered error */
#line 3604
			status = lstatus;
#line 3604
	}
#line 3604

#line 3604
	*xpp = (void *)xp;
#line 3604
	return status;
#line 3604
#endif
#line 3604
}
#line 3604

int
#line 3605
ncx_putn_longlong_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3605
{
#line 3605
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3605

#line 3605
 /* basic algorithm is:
#line 3605
  *   - ensure sane alignment of output data
#line 3605
  *   - copy (conversion happens automatically) input data
#line 3605
  *     to output
#line 3605
  *   - update tp to point at next unconverted input, and xpp to point
#line 3605
  *     at next location for converted output
#line 3605
  */
#line 3605
  long i, j, ni;
#line 3605
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3605
  int64 *xp;
#line 3605
  int nrange = 0;         /* number of range errors */
#line 3605
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3605
  long cxp = (long) *((char**)xpp);
#line 3605

#line 3605
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3605
  /* sjl: manually stripmine so we can limit amount of
#line 3605
   * vector work space reserved to LOOPCNT elements. Also
#line 3605
   * makes vectorisation easy */
#line 3605
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3605
    ni=Min(nelems-j,LOOPCNT);
#line 3605
    if (realign) {
#line 3605
      xp = tmp;
#line 3605
    } else {
#line 3605
      xp = (int64 *) *xpp;
#line 3605
    }
#line 3605
   /* copy the next block */
#line 3605
#pragma cdir loopcnt=LOOPCNT
#line 3605
#pragma cdir shortloop
#line 3605
    for (i=0; i<ni; i++) {
#line 3605
      /* the normal case: */
#line 3605
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3605
     /* test for range errors (not always needed but do it anyway) */
#line 3605
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3605
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3605
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3605
    }
#line 3605
   /* copy workspace back if necessary */
#line 3605
    if (realign) {
#line 3605
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3605
      xp = (int64 *) *xpp;
#line 3605
    }
#line 3605
   /* update xpp and tp */
#line 3605
    xp += ni;
#line 3605
    tp += ni;
#line 3605
    *xpp = (void*)xp;
#line 3605
  }
#line 3605
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3605

#line 3605
#else   /* not SX */
#line 3605

#line 3605
	char *xp = (char *) *xpp;
#line 3605
	int status = NC_NOERR;
#line 3605

#line 3605
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3605
	{
#line 3605
		int lstatus = ncx_put_longlong_short(xp, tp, fillp);
#line 3605
		if (status == NC_NOERR) /* report the first encountered error */
#line 3605
			status = lstatus;
#line 3605
	}
#line 3605

#line 3605
	*xpp = (void *)xp;
#line 3605
	return status;
#line 3605
#endif
#line 3605
}
#line 3605

int
#line 3606
ncx_putn_longlong_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3606
{
#line 3606
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3606

#line 3606
 /* basic algorithm is:
#line 3606
  *   - ensure sane alignment of output data
#line 3606
  *   - copy (conversion happens automatically) input data
#line 3606
  *     to output
#line 3606
  *   - update tp to point at next unconverted input, and xpp to point
#line 3606
  *     at next location for converted output
#line 3606
  */
#line 3606
  long i, j, ni;
#line 3606
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3606
  int64 *xp;
#line 3606
  int nrange = 0;         /* number of range errors */
#line 3606
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3606
  long cxp = (long) *((char**)xpp);
#line 3606

#line 3606
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3606
  /* sjl: manually stripmine so we can limit amount of
#line 3606
   * vector work space reserved to LOOPCNT elements. Also
#line 3606
   * makes vectorisation easy */
#line 3606
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3606
    ni=Min(nelems-j,LOOPCNT);
#line 3606
    if (realign) {
#line 3606
      xp = tmp;
#line 3606
    } else {
#line 3606
      xp = (int64 *) *xpp;
#line 3606
    }
#line 3606
   /* copy the next block */
#line 3606
#pragma cdir loopcnt=LOOPCNT
#line 3606
#pragma cdir shortloop
#line 3606
    for (i=0; i<ni; i++) {
#line 3606
      /* the normal case: */
#line 3606
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3606
     /* test for range errors (not always needed but do it anyway) */
#line 3606
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3606
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3606
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3606
    }
#line 3606
   /* copy workspace back if necessary */
#line 3606
    if (realign) {
#line 3606
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3606
      xp = (int64 *) *xpp;
#line 3606
    }
#line 3606
   /* update xpp and tp */
#line 3606
    xp += ni;
#line 3606
    tp += ni;
#line 3606
    *xpp = (void*)xp;
#line 3606
  }
#line 3606
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3606

#line 3606
#else   /* not SX */
#line 3606

#line 3606
	char *xp = (char *) *xpp;
#line 3606
	int status = NC_NOERR;
#line 3606

#line 3606
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3606
	{
#line 3606
		int lstatus = ncx_put_longlong_int(xp, tp, fillp);
#line 3606
		if (status == NC_NOERR) /* report the first encountered error */
#line 3606
			status = lstatus;
#line 3606
	}
#line 3606

#line 3606
	*xpp = (void *)xp;
#line 3606
	return status;
#line 3606
#endif
#line 3606
}
#line 3606

int
#line 3607
ncx_putn_longlong_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3607
{
#line 3607
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3607

#line 3607
 /* basic algorithm is:
#line 3607
  *   - ensure sane alignment of output data
#line 3607
  *   - copy (conversion happens automatically) input data
#line 3607
  *     to output
#line 3607
  *   - update tp to point at next unconverted input, and xpp to point
#line 3607
  *     at next location for converted output
#line 3607
  */
#line 3607
  long i, j, ni;
#line 3607
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3607
  int64 *xp;
#line 3607
  int nrange = 0;         /* number of range errors */
#line 3607
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3607
  long cxp = (long) *((char**)xpp);
#line 3607

#line 3607
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3607
  /* sjl: manually stripmine so we can limit amount of
#line 3607
   * vector work space reserved to LOOPCNT elements. Also
#line 3607
   * makes vectorisation easy */
#line 3607
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3607
    ni=Min(nelems-j,LOOPCNT);
#line 3607
    if (realign) {
#line 3607
      xp = tmp;
#line 3607
    } else {
#line 3607
      xp = (int64 *) *xpp;
#line 3607
    }
#line 3607
   /* copy the next block */
#line 3607
#pragma cdir loopcnt=LOOPCNT
#line 3607
#pragma cdir shortloop
#line 3607
    for (i=0; i<ni; i++) {
#line 3607
      /* the normal case: */
#line 3607
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3607
     /* test for range errors (not always needed but do it anyway) */
#line 3607
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3607
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3607
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3607
    }
#line 3607
   /* copy workspace back if necessary */
#line 3607
    if (realign) {
#line 3607
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3607
      xp = (int64 *) *xpp;
#line 3607
    }
#line 3607
   /* update xpp and tp */
#line 3607
    xp += ni;
#line 3607
    tp += ni;
#line 3607
    *xpp = (void*)xp;
#line 3607
  }
#line 3607
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3607

#line 3607
#else   /* not SX */
#line 3607

#line 3607
	char *xp = (char *) *xpp;
#line 3607
	int status = NC_NOERR;
#line 3607

#line 3607
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3607
	{
#line 3607
		int lstatus = ncx_put_longlong_long(xp, tp, fillp);
#line 3607
		if (status == NC_NOERR) /* report the first encountered error */
#line 3607
			status = lstatus;
#line 3607
	}
#line 3607

#line 3607
	*xpp = (void *)xp;
#line 3607
	return status;
#line 3607
#endif
#line 3607
}
#line 3607

int
#line 3608
ncx_putn_longlong_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3608
{
#line 3608
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3608

#line 3608
 /* basic algorithm is:
#line 3608
  *   - ensure sane alignment of output data
#line 3608
  *   - copy (conversion happens automatically) input data
#line 3608
  *     to output
#line 3608
  *   - update tp to point at next unconverted input, and xpp to point
#line 3608
  *     at next location for converted output
#line 3608
  */
#line 3608
  long i, j, ni;
#line 3608
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3608
  int64 *xp;
#line 3608
  int nrange = 0;         /* number of range errors */
#line 3608
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3608
  long cxp = (long) *((char**)xpp);
#line 3608

#line 3608
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3608
  /* sjl: manually stripmine so we can limit amount of
#line 3608
   * vector work space reserved to LOOPCNT elements. Also
#line 3608
   * makes vectorisation easy */
#line 3608
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3608
    ni=Min(nelems-j,LOOPCNT);
#line 3608
    if (realign) {
#line 3608
      xp = tmp;
#line 3608
    } else {
#line 3608
      xp = (int64 *) *xpp;
#line 3608
    }
#line 3608
   /* copy the next block */
#line 3608
#pragma cdir loopcnt=LOOPCNT
#line 3608
#pragma cdir shortloop
#line 3608
    for (i=0; i<ni; i++) {
#line 3608
      /* the normal case: */
#line 3608
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3608
     /* test for range errors (not always needed but do it anyway) */
#line 3608
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3608
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3608
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3608
    }
#line 3608
   /* copy workspace back if necessary */
#line 3608
    if (realign) {
#line 3608
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3608
      xp = (int64 *) *xpp;
#line 3608
    }
#line 3608
   /* update xpp and tp */
#line 3608
    xp += ni;
#line 3608
    tp += ni;
#line 3608
    *xpp = (void*)xp;
#line 3608
  }
#line 3608
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3608

#line 3608
#else   /* not SX */
#line 3608

#line 3608
	char *xp = (char *) *xpp;
#line 3608
	int status = NC_NOERR;
#line 3608

#line 3608
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3608
	{
#line 3608
		int lstatus = ncx_put_longlong_float(xp, tp, fillp);
#line 3608
		if (status == NC_NOERR) /* report the first encountered error */
#line 3608
			status = lstatus;
#line 3608
	}
#line 3608

#line 3608
	*xpp = (void *)xp;
#line 3608
	return status;
#line 3608
#endif
#line 3608
}
#line 3608

int
#line 3609
ncx_putn_longlong_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3609
{
#line 3609
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3609

#line 3609
 /* basic algorithm is:
#line 3609
  *   - ensure sane alignment of output data
#line 3609
  *   - copy (conversion happens automatically) input data
#line 3609
  *     to output
#line 3609
  *   - update tp to point at next unconverted input, and xpp to point
#line 3609
  *     at next location for converted output
#line 3609
  */
#line 3609
  long i, j, ni;
#line 3609
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3609
  int64 *xp;
#line 3609
  int nrange = 0;         /* number of range errors */
#line 3609
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3609
  long cxp = (long) *((char**)xpp);
#line 3609

#line 3609
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3609
  /* sjl: manually stripmine so we can limit amount of
#line 3609
   * vector work space reserved to LOOPCNT elements. Also
#line 3609
   * makes vectorisation easy */
#line 3609
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3609
    ni=Min(nelems-j,LOOPCNT);
#line 3609
    if (realign) {
#line 3609
      xp = tmp;
#line 3609
    } else {
#line 3609
      xp = (int64 *) *xpp;
#line 3609
    }
#line 3609
   /* copy the next block */
#line 3609
#pragma cdir loopcnt=LOOPCNT
#line 3609
#pragma cdir shortloop
#line 3609
    for (i=0; i<ni; i++) {
#line 3609
      /* the normal case: */
#line 3609
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3609
     /* test for range errors (not always needed but do it anyway) */
#line 3609
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3609
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3609
      nrange += tp[i] > X_INT64_MAX || tp[i] < X_INT64_MIN;
#line 3609
    }
#line 3609
   /* copy workspace back if necessary */
#line 3609
    if (realign) {
#line 3609
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3609
      xp = (int64 *) *xpp;
#line 3609
    }
#line 3609
   /* update xpp and tp */
#line 3609
    xp += ni;
#line 3609
    tp += ni;
#line 3609
    *xpp = (void*)xp;
#line 3609
  }
#line 3609
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3609

#line 3609
#else   /* not SX */
#line 3609

#line 3609
	char *xp = (char *) *xpp;
#line 3609
	int status = NC_NOERR;
#line 3609

#line 3609
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3609
	{
#line 3609
		int lstatus = ncx_put_longlong_double(xp, tp, fillp);
#line 3609
		if (status == NC_NOERR) /* report the first encountered error */
#line 3609
			status = lstatus;
#line 3609
	}
#line 3609

#line 3609
	*xpp = (void *)xp;
#line 3609
	return status;
#line 3609
#endif
#line 3609
}
#line 3609

int
#line 3610
ncx_putn_longlong_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3610
{
#line 3610
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3610

#line 3610
 /* basic algorithm is:
#line 3610
  *   - ensure sane alignment of output data
#line 3610
  *   - copy (conversion happens automatically) input data
#line 3610
  *     to output
#line 3610
  *   - update tp to point at next unconverted input, and xpp to point
#line 3610
  *     at next location for converted output
#line 3610
  */
#line 3610
  long i, j, ni;
#line 3610
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3610
  int64 *xp;
#line 3610
  int nrange = 0;         /* number of range errors */
#line 3610
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3610
  long cxp = (long) *((char**)xpp);
#line 3610

#line 3610
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3610
  /* sjl: manually stripmine so we can limit amount of
#line 3610
   * vector work space reserved to LOOPCNT elements. Also
#line 3610
   * makes vectorisation easy */
#line 3610
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3610
    ni=Min(nelems-j,LOOPCNT);
#line 3610
    if (realign) {
#line 3610
      xp = tmp;
#line 3610
    } else {
#line 3610
      xp = (int64 *) *xpp;
#line 3610
    }
#line 3610
   /* copy the next block */
#line 3610
#pragma cdir loopcnt=LOOPCNT
#line 3610
#pragma cdir shortloop
#line 3610
    for (i=0; i<ni; i++) {
#line 3610
      /* the normal case: */
#line 3610
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3610
     /* test for range errors (not always needed but do it anyway) */
#line 3610
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3610
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3610
      nrange += tp[i] > X_INT64_MAX ;
#line 3610
    }
#line 3610
   /* copy workspace back if necessary */
#line 3610
    if (realign) {
#line 3610
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3610
      xp = (int64 *) *xpp;
#line 3610
    }
#line 3610
   /* update xpp and tp */
#line 3610
    xp += ni;
#line 3610
    tp += ni;
#line 3610
    *xpp = (void*)xp;
#line 3610
  }
#line 3610
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3610

#line 3610
#else   /* not SX */
#line 3610

#line 3610
	char *xp = (char *) *xpp;
#line 3610
	int status = NC_NOERR;
#line 3610

#line 3610
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3610
	{
#line 3610
		int lstatus = ncx_put_longlong_uchar(xp, tp, fillp);
#line 3610
		if (status == NC_NOERR) /* report the first encountered error */
#line 3610
			status = lstatus;
#line 3610
	}
#line 3610

#line 3610
	*xpp = (void *)xp;
#line 3610
	return status;
#line 3610
#endif
#line 3610
}
#line 3610

int
#line 3611
ncx_putn_longlong_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3611
{
#line 3611
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3611

#line 3611
 /* basic algorithm is:
#line 3611
  *   - ensure sane alignment of output data
#line 3611
  *   - copy (conversion happens automatically) input data
#line 3611
  *     to output
#line 3611
  *   - update tp to point at next unconverted input, and xpp to point
#line 3611
  *     at next location for converted output
#line 3611
  */
#line 3611
  long i, j, ni;
#line 3611
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3611
  int64 *xp;
#line 3611
  int nrange = 0;         /* number of range errors */
#line 3611
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3611
  long cxp = (long) *((char**)xpp);
#line 3611

#line 3611
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3611
  /* sjl: manually stripmine so we can limit amount of
#line 3611
   * vector work space reserved to LOOPCNT elements. Also
#line 3611
   * makes vectorisation easy */
#line 3611
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3611
    ni=Min(nelems-j,LOOPCNT);
#line 3611
    if (realign) {
#line 3611
      xp = tmp;
#line 3611
    } else {
#line 3611
      xp = (int64 *) *xpp;
#line 3611
    }
#line 3611
   /* copy the next block */
#line 3611
#pragma cdir loopcnt=LOOPCNT
#line 3611
#pragma cdir shortloop
#line 3611
    for (i=0; i<ni; i++) {
#line 3611
      /* the normal case: */
#line 3611
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3611
     /* test for range errors (not always needed but do it anyway) */
#line 3611
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3611
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3611
      nrange += tp[i] > X_INT64_MAX ;
#line 3611
    }
#line 3611
   /* copy workspace back if necessary */
#line 3611
    if (realign) {
#line 3611
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3611
      xp = (int64 *) *xpp;
#line 3611
    }
#line 3611
   /* update xpp and tp */
#line 3611
    xp += ni;
#line 3611
    tp += ni;
#line 3611
    *xpp = (void*)xp;
#line 3611
  }
#line 3611
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3611

#line 3611
#else   /* not SX */
#line 3611

#line 3611
	char *xp = (char *) *xpp;
#line 3611
	int status = NC_NOERR;
#line 3611

#line 3611
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3611
	{
#line 3611
		int lstatus = ncx_put_longlong_ushort(xp, tp, fillp);
#line 3611
		if (status == NC_NOERR) /* report the first encountered error */
#line 3611
			status = lstatus;
#line 3611
	}
#line 3611

#line 3611
	*xpp = (void *)xp;
#line 3611
	return status;
#line 3611
#endif
#line 3611
}
#line 3611

int
#line 3612
ncx_putn_longlong_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3612
{
#line 3612
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3612

#line 3612
 /* basic algorithm is:
#line 3612
  *   - ensure sane alignment of output data
#line 3612
  *   - copy (conversion happens automatically) input data
#line 3612
  *     to output
#line 3612
  *   - update tp to point at next unconverted input, and xpp to point
#line 3612
  *     at next location for converted output
#line 3612
  */
#line 3612
  long i, j, ni;
#line 3612
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3612
  int64 *xp;
#line 3612
  int nrange = 0;         /* number of range errors */
#line 3612
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3612
  long cxp = (long) *((char**)xpp);
#line 3612

#line 3612
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3612
  /* sjl: manually stripmine so we can limit amount of
#line 3612
   * vector work space reserved to LOOPCNT elements. Also
#line 3612
   * makes vectorisation easy */
#line 3612
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3612
    ni=Min(nelems-j,LOOPCNT);
#line 3612
    if (realign) {
#line 3612
      xp = tmp;
#line 3612
    } else {
#line 3612
      xp = (int64 *) *xpp;
#line 3612
    }
#line 3612
   /* copy the next block */
#line 3612
#pragma cdir loopcnt=LOOPCNT
#line 3612
#pragma cdir shortloop
#line 3612
    for (i=0; i<ni; i++) {
#line 3612
      /* the normal case: */
#line 3612
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3612
     /* test for range errors (not always needed but do it anyway) */
#line 3612
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3612
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3612
      nrange += tp[i] > X_INT64_MAX ;
#line 3612
    }
#line 3612
   /* copy workspace back if necessary */
#line 3612
    if (realign) {
#line 3612
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3612
      xp = (int64 *) *xpp;
#line 3612
    }
#line 3612
   /* update xpp and tp */
#line 3612
    xp += ni;
#line 3612
    tp += ni;
#line 3612
    *xpp = (void*)xp;
#line 3612
  }
#line 3612
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3612

#line 3612
#else   /* not SX */
#line 3612

#line 3612
	char *xp = (char *) *xpp;
#line 3612
	int status = NC_NOERR;
#line 3612

#line 3612
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3612
	{
#line 3612
		int lstatus = ncx_put_longlong_uint(xp, tp, fillp);
#line 3612
		if (status == NC_NOERR) /* report the first encountered error */
#line 3612
			status = lstatus;
#line 3612
	}
#line 3612

#line 3612
	*xpp = (void *)xp;
#line 3612
	return status;
#line 3612
#endif
#line 3612
}
#line 3612

int
#line 3613
ncx_putn_longlong_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3613
{
#line 3613
#if defined(_SX) && _SX != 0 && X_SIZEOF_INT64 == SIZEOF_INT64
#line 3613

#line 3613
 /* basic algorithm is:
#line 3613
  *   - ensure sane alignment of output data
#line 3613
  *   - copy (conversion happens automatically) input data
#line 3613
  *     to output
#line 3613
  *   - update tp to point at next unconverted input, and xpp to point
#line 3613
  *     at next location for converted output
#line 3613
  */
#line 3613
  long i, j, ni;
#line 3613
  int64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3613
  int64 *xp;
#line 3613
  int nrange = 0;         /* number of range errors */
#line 3613
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3613
  long cxp = (long) *((char**)xpp);
#line 3613

#line 3613
  realign = (cxp & 7) % SIZEOF_INT64;
#line 3613
  /* sjl: manually stripmine so we can limit amount of
#line 3613
   * vector work space reserved to LOOPCNT elements. Also
#line 3613
   * makes vectorisation easy */
#line 3613
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3613
    ni=Min(nelems-j,LOOPCNT);
#line 3613
    if (realign) {
#line 3613
      xp = tmp;
#line 3613
    } else {
#line 3613
      xp = (int64 *) *xpp;
#line 3613
    }
#line 3613
   /* copy the next block */
#line 3613
#pragma cdir loopcnt=LOOPCNT
#line 3613
#pragma cdir shortloop
#line 3613
    for (i=0; i<ni; i++) {
#line 3613
      /* the normal case: */
#line 3613
      xp[i] = (int64) Max( X_INT64_MIN, Min(X_INT64_MAX, (int64) tp[i]));
#line 3613
     /* test for range errors (not always needed but do it anyway) */
#line 3613
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3613
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3613
      nrange += tp[i] > X_INT64_MAX ;
#line 3613
    }
#line 3613
   /* copy workspace back if necessary */
#line 3613
    if (realign) {
#line 3613
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_INT64);
#line 3613
      xp = (int64 *) *xpp;
#line 3613
    }
#line 3613
   /* update xpp and tp */
#line 3613
    xp += ni;
#line 3613
    tp += ni;
#line 3613
    *xpp = (void*)xp;
#line 3613
  }
#line 3613
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3613

#line 3613
#else   /* not SX */
#line 3613

#line 3613
	char *xp = (char *) *xpp;
#line 3613
	int status = NC_NOERR;
#line 3613

#line 3613
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT64, tp++)
#line 3613
	{
#line 3613
		int lstatus = ncx_put_longlong_ulonglong(xp, tp, fillp);
#line 3613
		if (status == NC_NOERR) /* report the first encountered error */
#line 3613
			status = lstatus;
#line 3613
	}
#line 3613

#line 3613
	*xpp = (void *)xp;
#line 3613
	return status;
#line 3613
#endif
#line 3613
}
#line 3613


/* uint64 --------------------------------------------------------------------*/

#if X_SIZEOF_UINT64 == SIZEOF_ULONGLONG
/* optimized version */
int
ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, unsigned long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, (size_t)nelems * SIZEOF_UNSIGNED_LONG_LONG);
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_UINT64);
	return NC_NOERR;
}
#else
int
#line 3631
ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3631
{
#line 3631
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3631

#line 3631
 /* basic algorithm is:
#line 3631
  *   - ensure sane alignment of input data
#line 3631
  *   - copy (conversion happens automatically) input data
#line 3631
  *     to output
#line 3631
  *   - update xpp to point at next unconverted input, and tp to point
#line 3631
  *     at next location for converted output
#line 3631
  */
#line 3631
  long i, j, ni;
#line 3631
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3631
  uint64 *xp;
#line 3631
  int nrange = 0;         /* number of range errors */
#line 3631
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3631
  long cxp = (long) *((char**)xpp);
#line 3631

#line 3631
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3631
  /* sjl: manually stripmine so we can limit amount of
#line 3631
   * vector work space reserved to LOOPCNT elements. Also
#line 3631
   * makes vectorisation easy */
#line 3631
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3631
    ni=Min(nelems-j,LOOPCNT);
#line 3631
    if (realign) {
#line 3631
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3631
      xp = tmp;
#line 3631
    } else {
#line 3631
      xp = (uint64 *) *xpp;
#line 3631
    }
#line 3631
   /* copy the next block */
#line 3631
#pragma cdir loopcnt=LOOPCNT
#line 3631
#pragma cdir shortloop
#line 3631
    for (i=0; i<ni; i++) {
#line 3631
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3631
     /* test for range errors (not always needed but do it anyway) */
#line 3631
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3631
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3631
      nrange += xp[i] > ULONGLONG_MAX ;
#line 3631
    }
#line 3631
   /* update xpp and tp */
#line 3631
    if (realign) xp = (uint64 *) *xpp;
#line 3631
    xp += ni;
#line 3631
    tp += ni;
#line 3631
    *xpp = (void*)xp;
#line 3631
  }
#line 3631
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3631

#line 3631
#else   /* not SX */
#line 3631
	const char *xp = (const char *) *xpp;
#line 3631
	int status = NC_NOERR;
#line 3631

#line 3631
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3631
	{
#line 3631
		const int lstatus = ncx_get_ulonglong_ulonglong(xp, tp);
#line 3631
		if (status == NC_NOERR) /* report the first encountered error */
#line 3631
			status = lstatus;
#line 3631
	}
#line 3631

#line 3631
	*xpp = (const void *)xp;
#line 3631
	return status;
#line 3631
#endif
#line 3631
}
#line 3631

#endif
int
#line 3633
ncx_getn_ulonglong_schar(const void **xpp, size_t nelems, schar *tp)
#line 3633
{
#line 3633
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3633

#line 3633
 /* basic algorithm is:
#line 3633
  *   - ensure sane alignment of input data
#line 3633
  *   - copy (conversion happens automatically) input data
#line 3633
  *     to output
#line 3633
  *   - update xpp to point at next unconverted input, and tp to point
#line 3633
  *     at next location for converted output
#line 3633
  */
#line 3633
  long i, j, ni;
#line 3633
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3633
  uint64 *xp;
#line 3633
  int nrange = 0;         /* number of range errors */
#line 3633
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3633
  long cxp = (long) *((char**)xpp);
#line 3633

#line 3633
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3633
  /* sjl: manually stripmine so we can limit amount of
#line 3633
   * vector work space reserved to LOOPCNT elements. Also
#line 3633
   * makes vectorisation easy */
#line 3633
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3633
    ni=Min(nelems-j,LOOPCNT);
#line 3633
    if (realign) {
#line 3633
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3633
      xp = tmp;
#line 3633
    } else {
#line 3633
      xp = (uint64 *) *xpp;
#line 3633
    }
#line 3633
   /* copy the next block */
#line 3633
#pragma cdir loopcnt=LOOPCNT
#line 3633
#pragma cdir shortloop
#line 3633
    for (i=0; i<ni; i++) {
#line 3633
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3633
     /* test for range errors (not always needed but do it anyway) */
#line 3633
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3633
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3633
      nrange += xp[i] > SCHAR_MAX ;
#line 3633
    }
#line 3633
   /* update xpp and tp */
#line 3633
    if (realign) xp = (uint64 *) *xpp;
#line 3633
    xp += ni;
#line 3633
    tp += ni;
#line 3633
    *xpp = (void*)xp;
#line 3633
  }
#line 3633
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3633

#line 3633
#else   /* not SX */
#line 3633
	const char *xp = (const char *) *xpp;
#line 3633
	int status = NC_NOERR;
#line 3633

#line 3633
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3633
	{
#line 3633
		const int lstatus = ncx_get_ulonglong_schar(xp, tp);
#line 3633
		if (status == NC_NOERR) /* report the first encountered error */
#line 3633
			status = lstatus;
#line 3633
	}
#line 3633

#line 3633
	*xpp = (const void *)xp;
#line 3633
	return status;
#line 3633
#endif
#line 3633
}
#line 3633

int
#line 3634
ncx_getn_ulonglong_short(const void **xpp, size_t nelems, short *tp)
#line 3634
{
#line 3634
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3634

#line 3634
 /* basic algorithm is:
#line 3634
  *   - ensure sane alignment of input data
#line 3634
  *   - copy (conversion happens automatically) input data
#line 3634
  *     to output
#line 3634
  *   - update xpp to point at next unconverted input, and tp to point
#line 3634
  *     at next location for converted output
#line 3634
  */
#line 3634
  long i, j, ni;
#line 3634
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3634
  uint64 *xp;
#line 3634
  int nrange = 0;         /* number of range errors */
#line 3634
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3634
  long cxp = (long) *((char**)xpp);
#line 3634

#line 3634
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3634
  /* sjl: manually stripmine so we can limit amount of
#line 3634
   * vector work space reserved to LOOPCNT elements. Also
#line 3634
   * makes vectorisation easy */
#line 3634
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3634
    ni=Min(nelems-j,LOOPCNT);
#line 3634
    if (realign) {
#line 3634
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3634
      xp = tmp;
#line 3634
    } else {
#line 3634
      xp = (uint64 *) *xpp;
#line 3634
    }
#line 3634
   /* copy the next block */
#line 3634
#pragma cdir loopcnt=LOOPCNT
#line 3634
#pragma cdir shortloop
#line 3634
    for (i=0; i<ni; i++) {
#line 3634
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3634
     /* test for range errors (not always needed but do it anyway) */
#line 3634
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3634
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3634
      nrange += xp[i] > SHORT_MAX ;
#line 3634
    }
#line 3634
   /* update xpp and tp */
#line 3634
    if (realign) xp = (uint64 *) *xpp;
#line 3634
    xp += ni;
#line 3634
    tp += ni;
#line 3634
    *xpp = (void*)xp;
#line 3634
  }
#line 3634
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3634

#line 3634
#else   /* not SX */
#line 3634
	const char *xp = (const char *) *xpp;
#line 3634
	int status = NC_NOERR;
#line 3634

#line 3634
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3634
	{
#line 3634
		const int lstatus = ncx_get_ulonglong_short(xp, tp);
#line 3634
		if (status == NC_NOERR) /* report the first encountered error */
#line 3634
			status = lstatus;
#line 3634
	}
#line 3634

#line 3634
	*xpp = (const void *)xp;
#line 3634
	return status;
#line 3634
#endif
#line 3634
}
#line 3634

int
#line 3635
ncx_getn_ulonglong_int(const void **xpp, size_t nelems, int *tp)
#line 3635
{
#line 3635
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3635

#line 3635
 /* basic algorithm is:
#line 3635
  *   - ensure sane alignment of input data
#line 3635
  *   - copy (conversion happens automatically) input data
#line 3635
  *     to output
#line 3635
  *   - update xpp to point at next unconverted input, and tp to point
#line 3635
  *     at next location for converted output
#line 3635
  */
#line 3635
  long i, j, ni;
#line 3635
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3635
  uint64 *xp;
#line 3635
  int nrange = 0;         /* number of range errors */
#line 3635
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3635
  long cxp = (long) *((char**)xpp);
#line 3635

#line 3635
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3635
  /* sjl: manually stripmine so we can limit amount of
#line 3635
   * vector work space reserved to LOOPCNT elements. Also
#line 3635
   * makes vectorisation easy */
#line 3635
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3635
    ni=Min(nelems-j,LOOPCNT);
#line 3635
    if (realign) {
#line 3635
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3635
      xp = tmp;
#line 3635
    } else {
#line 3635
      xp = (uint64 *) *xpp;
#line 3635
    }
#line 3635
   /* copy the next block */
#line 3635
#pragma cdir loopcnt=LOOPCNT
#line 3635
#pragma cdir shortloop
#line 3635
    for (i=0; i<ni; i++) {
#line 3635
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3635
     /* test for range errors (not always needed but do it anyway) */
#line 3635
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3635
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3635
      nrange += xp[i] > INT_MAX ;
#line 3635
    }
#line 3635
   /* update xpp and tp */
#line 3635
    if (realign) xp = (uint64 *) *xpp;
#line 3635
    xp += ni;
#line 3635
    tp += ni;
#line 3635
    *xpp = (void*)xp;
#line 3635
  }
#line 3635
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3635

#line 3635
#else   /* not SX */
#line 3635
	const char *xp = (const char *) *xpp;
#line 3635
	int status = NC_NOERR;
#line 3635

#line 3635
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3635
	{
#line 3635
		const int lstatus = ncx_get_ulonglong_int(xp, tp);
#line 3635
		if (status == NC_NOERR) /* report the first encountered error */
#line 3635
			status = lstatus;
#line 3635
	}
#line 3635

#line 3635
	*xpp = (const void *)xp;
#line 3635
	return status;
#line 3635
#endif
#line 3635
}
#line 3635

int
#line 3636
ncx_getn_ulonglong_long(const void **xpp, size_t nelems, long *tp)
#line 3636
{
#line 3636
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3636

#line 3636
 /* basic algorithm is:
#line 3636
  *   - ensure sane alignment of input data
#line 3636
  *   - copy (conversion happens automatically) input data
#line 3636
  *     to output
#line 3636
  *   - update xpp to point at next unconverted input, and tp to point
#line 3636
  *     at next location for converted output
#line 3636
  */
#line 3636
  long i, j, ni;
#line 3636
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3636
  uint64 *xp;
#line 3636
  int nrange = 0;         /* number of range errors */
#line 3636
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3636
  long cxp = (long) *((char**)xpp);
#line 3636

#line 3636
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3636
  /* sjl: manually stripmine so we can limit amount of
#line 3636
   * vector work space reserved to LOOPCNT elements. Also
#line 3636
   * makes vectorisation easy */
#line 3636
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3636
    ni=Min(nelems-j,LOOPCNT);
#line 3636
    if (realign) {
#line 3636
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3636
      xp = tmp;
#line 3636
    } else {
#line 3636
      xp = (uint64 *) *xpp;
#line 3636
    }
#line 3636
   /* copy the next block */
#line 3636
#pragma cdir loopcnt=LOOPCNT
#line 3636
#pragma cdir shortloop
#line 3636
    for (i=0; i<ni; i++) {
#line 3636
      tp[i] = (long) Max( LONG_MIN, Min(LONG_MAX, (long) xp[i]));
#line 3636
     /* test for range errors (not always needed but do it anyway) */
#line 3636
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3636
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3636
      nrange += xp[i] > LONG_MAX ;
#line 3636
    }
#line 3636
   /* update xpp and tp */
#line 3636
    if (realign) xp = (uint64 *) *xpp;
#line 3636
    xp += ni;
#line 3636
    tp += ni;
#line 3636
    *xpp = (void*)xp;
#line 3636
  }
#line 3636
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3636

#line 3636
#else   /* not SX */
#line 3636
	const char *xp = (const char *) *xpp;
#line 3636
	int status = NC_NOERR;
#line 3636

#line 3636
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3636
	{
#line 3636
		const int lstatus = ncx_get_ulonglong_long(xp, tp);
#line 3636
		if (status == NC_NOERR) /* report the first encountered error */
#line 3636
			status = lstatus;
#line 3636
	}
#line 3636

#line 3636
	*xpp = (const void *)xp;
#line 3636
	return status;
#line 3636
#endif
#line 3636
}
#line 3636

int
#line 3637
ncx_getn_ulonglong_float(const void **xpp, size_t nelems, float *tp)
#line 3637
{
#line 3637
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3637

#line 3637
 /* basic algorithm is:
#line 3637
  *   - ensure sane alignment of input data
#line 3637
  *   - copy (conversion happens automatically) input data
#line 3637
  *     to output
#line 3637
  *   - update xpp to point at next unconverted input, and tp to point
#line 3637
  *     at next location for converted output
#line 3637
  */
#line 3637
  long i, j, ni;
#line 3637
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3637
  uint64 *xp;
#line 3637
  int nrange = 0;         /* number of range errors */
#line 3637
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3637
  long cxp = (long) *((char**)xpp);
#line 3637

#line 3637
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3637
  /* sjl: manually stripmine so we can limit amount of
#line 3637
   * vector work space reserved to LOOPCNT elements. Also
#line 3637
   * makes vectorisation easy */
#line 3637
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3637
    ni=Min(nelems-j,LOOPCNT);
#line 3637
    if (realign) {
#line 3637
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3637
      xp = tmp;
#line 3637
    } else {
#line 3637
      xp = (uint64 *) *xpp;
#line 3637
    }
#line 3637
   /* copy the next block */
#line 3637
#pragma cdir loopcnt=LOOPCNT
#line 3637
#pragma cdir shortloop
#line 3637
    for (i=0; i<ni; i++) {
#line 3637
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3637
     /* test for range errors (not always needed but do it anyway) */
#line 3637
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3637
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3637
      nrange += xp[i] > FLOAT_MAX ;
#line 3637
    }
#line 3637
   /* update xpp and tp */
#line 3637
    if (realign) xp = (uint64 *) *xpp;
#line 3637
    xp += ni;
#line 3637
    tp += ni;
#line 3637
    *xpp = (void*)xp;
#line 3637
  }
#line 3637
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3637

#line 3637
#else   /* not SX */
#line 3637
	const char *xp = (const char *) *xpp;
#line 3637
	int status = NC_NOERR;
#line 3637

#line 3637
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3637
	{
#line 3637
		const int lstatus = ncx_get_ulonglong_float(xp, tp);
#line 3637
		if (status == NC_NOERR) /* report the first encountered error */
#line 3637
			status = lstatus;
#line 3637
	}
#line 3637

#line 3637
	*xpp = (const void *)xp;
#line 3637
	return status;
#line 3637
#endif
#line 3637
}
#line 3637

int
#line 3638
ncx_getn_ulonglong_double(const void **xpp, size_t nelems, double *tp)
#line 3638
{
#line 3638
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3638

#line 3638
 /* basic algorithm is:
#line 3638
  *   - ensure sane alignment of input data
#line 3638
  *   - copy (conversion happens automatically) input data
#line 3638
  *     to output
#line 3638
  *   - update xpp to point at next unconverted input, and tp to point
#line 3638
  *     at next location for converted output
#line 3638
  */
#line 3638
  long i, j, ni;
#line 3638
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3638
  uint64 *xp;
#line 3638
  int nrange = 0;         /* number of range errors */
#line 3638
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3638
  long cxp = (long) *((char**)xpp);
#line 3638

#line 3638
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3638
  /* sjl: manually stripmine so we can limit amount of
#line 3638
   * vector work space reserved to LOOPCNT elements. Also
#line 3638
   * makes vectorisation easy */
#line 3638
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3638
    ni=Min(nelems-j,LOOPCNT);
#line 3638
    if (realign) {
#line 3638
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3638
      xp = tmp;
#line 3638
    } else {
#line 3638
      xp = (uint64 *) *xpp;
#line 3638
    }
#line 3638
   /* copy the next block */
#line 3638
#pragma cdir loopcnt=LOOPCNT
#line 3638
#pragma cdir shortloop
#line 3638
    for (i=0; i<ni; i++) {
#line 3638
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3638
     /* test for range errors (not always needed but do it anyway) */
#line 3638
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3638
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3638
      nrange += xp[i] > DOUBLE_MAX ;
#line 3638
    }
#line 3638
   /* update xpp and tp */
#line 3638
    if (realign) xp = (uint64 *) *xpp;
#line 3638
    xp += ni;
#line 3638
    tp += ni;
#line 3638
    *xpp = (void*)xp;
#line 3638
  }
#line 3638
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3638

#line 3638
#else   /* not SX */
#line 3638
	const char *xp = (const char *) *xpp;
#line 3638
	int status = NC_NOERR;
#line 3638

#line 3638
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3638
	{
#line 3638
		const int lstatus = ncx_get_ulonglong_double(xp, tp);
#line 3638
		if (status == NC_NOERR) /* report the first encountered error */
#line 3638
			status = lstatus;
#line 3638
	}
#line 3638

#line 3638
	*xpp = (const void *)xp;
#line 3638
	return status;
#line 3638
#endif
#line 3638
}
#line 3638

int
#line 3639
ncx_getn_ulonglong_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3639
{
#line 3639
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3639

#line 3639
 /* basic algorithm is:
#line 3639
  *   - ensure sane alignment of input data
#line 3639
  *   - copy (conversion happens automatically) input data
#line 3639
  *     to output
#line 3639
  *   - update xpp to point at next unconverted input, and tp to point
#line 3639
  *     at next location for converted output
#line 3639
  */
#line 3639
  long i, j, ni;
#line 3639
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3639
  uint64 *xp;
#line 3639
  int nrange = 0;         /* number of range errors */
#line 3639
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3639
  long cxp = (long) *((char**)xpp);
#line 3639

#line 3639
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3639
  /* sjl: manually stripmine so we can limit amount of
#line 3639
   * vector work space reserved to LOOPCNT elements. Also
#line 3639
   * makes vectorisation easy */
#line 3639
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3639
    ni=Min(nelems-j,LOOPCNT);
#line 3639
    if (realign) {
#line 3639
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3639
      xp = tmp;
#line 3639
    } else {
#line 3639
      xp = (uint64 *) *xpp;
#line 3639
    }
#line 3639
   /* copy the next block */
#line 3639
#pragma cdir loopcnt=LOOPCNT
#line 3639
#pragma cdir shortloop
#line 3639
    for (i=0; i<ni; i++) {
#line 3639
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3639
     /* test for range errors (not always needed but do it anyway) */
#line 3639
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3639
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3639
      nrange += xp[i] > LONGLONG_MAX ;
#line 3639
    }
#line 3639
   /* update xpp and tp */
#line 3639
    if (realign) xp = (uint64 *) *xpp;
#line 3639
    xp += ni;
#line 3639
    tp += ni;
#line 3639
    *xpp = (void*)xp;
#line 3639
  }
#line 3639
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3639

#line 3639
#else   /* not SX */
#line 3639
	const char *xp = (const char *) *xpp;
#line 3639
	int status = NC_NOERR;
#line 3639

#line 3639
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3639
	{
#line 3639
		const int lstatus = ncx_get_ulonglong_longlong(xp, tp);
#line 3639
		if (status == NC_NOERR) /* report the first encountered error */
#line 3639
			status = lstatus;
#line 3639
	}
#line 3639

#line 3639
	*xpp = (const void *)xp;
#line 3639
	return status;
#line 3639
#endif
#line 3639
}
#line 3639

int
#line 3640
ncx_getn_ulonglong_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3640
{
#line 3640
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3640

#line 3640
 /* basic algorithm is:
#line 3640
  *   - ensure sane alignment of input data
#line 3640
  *   - copy (conversion happens automatically) input data
#line 3640
  *     to output
#line 3640
  *   - update xpp to point at next unconverted input, and tp to point
#line 3640
  *     at next location for converted output
#line 3640
  */
#line 3640
  long i, j, ni;
#line 3640
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3640
  uint64 *xp;
#line 3640
  int nrange = 0;         /* number of range errors */
#line 3640
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3640
  long cxp = (long) *((char**)xpp);
#line 3640

#line 3640
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3640
  /* sjl: manually stripmine so we can limit amount of
#line 3640
   * vector work space reserved to LOOPCNT elements. Also
#line 3640
   * makes vectorisation easy */
#line 3640
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3640
    ni=Min(nelems-j,LOOPCNT);
#line 3640
    if (realign) {
#line 3640
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3640
      xp = tmp;
#line 3640
    } else {
#line 3640
      xp = (uint64 *) *xpp;
#line 3640
    }
#line 3640
   /* copy the next block */
#line 3640
#pragma cdir loopcnt=LOOPCNT
#line 3640
#pragma cdir shortloop
#line 3640
    for (i=0; i<ni; i++) {
#line 3640
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3640
     /* test for range errors (not always needed but do it anyway) */
#line 3640
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3640
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3640
      nrange += xp[i] > UCHAR_MAX ;
#line 3640
    }
#line 3640
   /* update xpp and tp */
#line 3640
    if (realign) xp = (uint64 *) *xpp;
#line 3640
    xp += ni;
#line 3640
    tp += ni;
#line 3640
    *xpp = (void*)xp;
#line 3640
  }
#line 3640
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3640

#line 3640
#else   /* not SX */
#line 3640
	const char *xp = (const char *) *xpp;
#line 3640
	int status = NC_NOERR;
#line 3640

#line 3640
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3640
	{
#line 3640
		const int lstatus = ncx_get_ulonglong_uchar(xp, tp);
#line 3640
		if (status == NC_NOERR) /* report the first encountered error */
#line 3640
			status = lstatus;
#line 3640
	}
#line 3640

#line 3640
	*xpp = (const void *)xp;
#line 3640
	return status;
#line 3640
#endif
#line 3640
}
#line 3640

int
#line 3641
ncx_getn_ulonglong_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3641
{
#line 3641
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3641

#line 3641
 /* basic algorithm is:
#line 3641
  *   - ensure sane alignment of input data
#line 3641
  *   - copy (conversion happens automatically) input data
#line 3641
  *     to output
#line 3641
  *   - update xpp to point at next unconverted input, and tp to point
#line 3641
  *     at next location for converted output
#line 3641
  */
#line 3641
  long i, j, ni;
#line 3641
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3641
  uint64 *xp;
#line 3641
  int nrange = 0;         /* number of range errors */
#line 3641
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3641
  long cxp = (long) *((char**)xpp);
#line 3641

#line 3641
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3641
  /* sjl: manually stripmine so we can limit amount of
#line 3641
   * vector work space reserved to LOOPCNT elements. Also
#line 3641
   * makes vectorisation easy */
#line 3641
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3641
    ni=Min(nelems-j,LOOPCNT);
#line 3641
    if (realign) {
#line 3641
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3641
      xp = tmp;
#line 3641
    } else {
#line 3641
      xp = (uint64 *) *xpp;
#line 3641
    }
#line 3641
   /* copy the next block */
#line 3641
#pragma cdir loopcnt=LOOPCNT
#line 3641
#pragma cdir shortloop
#line 3641
    for (i=0; i<ni; i++) {
#line 3641
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3641
     /* test for range errors (not always needed but do it anyway) */
#line 3641
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3641
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3641
      nrange += xp[i] > USHORT_MAX ;
#line 3641
    }
#line 3641
   /* update xpp and tp */
#line 3641
    if (realign) xp = (uint64 *) *xpp;
#line 3641
    xp += ni;
#line 3641
    tp += ni;
#line 3641
    *xpp = (void*)xp;
#line 3641
  }
#line 3641
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3641

#line 3641
#else   /* not SX */
#line 3641
	const char *xp = (const char *) *xpp;
#line 3641
	int status = NC_NOERR;
#line 3641

#line 3641
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3641
	{
#line 3641
		const int lstatus = ncx_get_ulonglong_ushort(xp, tp);
#line 3641
		if (status == NC_NOERR) /* report the first encountered error */
#line 3641
			status = lstatus;
#line 3641
	}
#line 3641

#line 3641
	*xpp = (const void *)xp;
#line 3641
	return status;
#line 3641
#endif
#line 3641
}
#line 3641

int
#line 3642
ncx_getn_ulonglong_uint(const void **xpp, size_t nelems, uint *tp)
#line 3642
{
#line 3642
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3642

#line 3642
 /* basic algorithm is:
#line 3642
  *   - ensure sane alignment of input data
#line 3642
  *   - copy (conversion happens automatically) input data
#line 3642
  *     to output
#line 3642
  *   - update xpp to point at next unconverted input, and tp to point
#line 3642
  *     at next location for converted output
#line 3642
  */
#line 3642
  long i, j, ni;
#line 3642
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3642
  uint64 *xp;
#line 3642
  int nrange = 0;         /* number of range errors */
#line 3642
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3642
  long cxp = (long) *((char**)xpp);
#line 3642

#line 3642
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3642
  /* sjl: manually stripmine so we can limit amount of
#line 3642
   * vector work space reserved to LOOPCNT elements. Also
#line 3642
   * makes vectorisation easy */
#line 3642
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3642
    ni=Min(nelems-j,LOOPCNT);
#line 3642
    if (realign) {
#line 3642
      memcpy(tmp, *xpp, (size_t)(ni*SIZEOF_UINT64));
#line 3642
      xp = tmp;
#line 3642
    } else {
#line 3642
      xp = (uint64 *) *xpp;
#line 3642
    }
#line 3642
   /* copy the next block */
#line 3642
#pragma cdir loopcnt=LOOPCNT
#line 3642
#pragma cdir shortloop
#line 3642
    for (i=0; i<ni; i++) {
#line 3642
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3642
     /* test for range errors (not always needed but do it anyway) */
#line 3642
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3642
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3642
      nrange += xp[i] > UINT_MAX ;
#line 3642
    }
#line 3642
   /* update xpp and tp */
#line 3642
    if (realign) xp = (uint64 *) *xpp;
#line 3642
    xp += ni;
#line 3642
    tp += ni;
#line 3642
    *xpp = (void*)xp;
#line 3642
  }
#line 3642
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3642

#line 3642
#else   /* not SX */
#line 3642
	const char *xp = (const char *) *xpp;
#line 3642
	int status = NC_NOERR;
#line 3642

#line 3642
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3642
	{
#line 3642
		const int lstatus = ncx_get_ulonglong_uint(xp, tp);
#line 3642
		if (status == NC_NOERR) /* report the first encountered error */
#line 3642
			status = lstatus;
#line 3642
	}
#line 3642

#line 3642
	*xpp = (const void *)xp;
#line 3642
	return status;
#line 3642
#endif
#line 3642
}
#line 3642


#if X_SIZEOF_UINT64 == SIZEOF_ULONGLONG
/* optimized version */
int
ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const unsigned long long *tp, void *fillp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, (size_t)nelems * X_SIZEOF_UINT64);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_UINT64);
	return NC_NOERR;
}
#else
int
#line 3658
ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const ulonglong *tp, void *fillp)
#line 3658
{
#line 3658
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3658

#line 3658
 /* basic algorithm is:
#line 3658
  *   - ensure sane alignment of output data
#line 3658
  *   - copy (conversion happens automatically) input data
#line 3658
  *     to output
#line 3658
  *   - update tp to point at next unconverted input, and xpp to point
#line 3658
  *     at next location for converted output
#line 3658
  */
#line 3658
  long i, j, ni;
#line 3658
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3658
  uint64 *xp;
#line 3658
  int nrange = 0;         /* number of range errors */
#line 3658
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3658
  long cxp = (long) *((char**)xpp);
#line 3658

#line 3658
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3658
  /* sjl: manually stripmine so we can limit amount of
#line 3658
   * vector work space reserved to LOOPCNT elements. Also
#line 3658
   * makes vectorisation easy */
#line 3658
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3658
    ni=Min(nelems-j,LOOPCNT);
#line 3658
    if (realign) {
#line 3658
      xp = tmp;
#line 3658
    } else {
#line 3658
      xp = (uint64 *) *xpp;
#line 3658
    }
#line 3658
   /* copy the next block */
#line 3658
#pragma cdir loopcnt=LOOPCNT
#line 3658
#pragma cdir shortloop
#line 3658
    for (i=0; i<ni; i++) {
#line 3658
      /* the normal case: */
#line 3658
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3658
     /* test for range errors (not always needed but do it anyway) */
#line 3658
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3658
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3658
      nrange += tp[i] > X_UINT64_MAX ;
#line 3658
    }
#line 3658
   /* copy workspace back if necessary */
#line 3658
    if (realign) {
#line 3658
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3658
      xp = (uint64 *) *xpp;
#line 3658
    }
#line 3658
   /* update xpp and tp */
#line 3658
    xp += ni;
#line 3658
    tp += ni;
#line 3658
    *xpp = (void*)xp;
#line 3658
  }
#line 3658
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3658

#line 3658
#else   /* not SX */
#line 3658

#line 3658
	char *xp = (char *) *xpp;
#line 3658
	int status = NC_NOERR;
#line 3658

#line 3658
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3658
	{
#line 3658
		int lstatus = ncx_put_ulonglong_ulonglong(xp, tp, fillp);
#line 3658
		if (status == NC_NOERR) /* report the first encountered error */
#line 3658
			status = lstatus;
#line 3658
	}
#line 3658

#line 3658
	*xpp = (void *)xp;
#line 3658
	return status;
#line 3658
#endif
#line 3658
}
#line 3658

#endif
int
#line 3660
ncx_putn_ulonglong_schar(void **xpp, size_t nelems, const schar *tp, void *fillp)
#line 3660
{
#line 3660
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3660

#line 3660
 /* basic algorithm is:
#line 3660
  *   - ensure sane alignment of output data
#line 3660
  *   - copy (conversion happens automatically) input data
#line 3660
  *     to output
#line 3660
  *   - update tp to point at next unconverted input, and xpp to point
#line 3660
  *     at next location for converted output
#line 3660
  */
#line 3660
  long i, j, ni;
#line 3660
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3660
  uint64 *xp;
#line 3660
  int nrange = 0;         /* number of range errors */
#line 3660
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3660
  long cxp = (long) *((char**)xpp);
#line 3660

#line 3660
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3660
  /* sjl: manually stripmine so we can limit amount of
#line 3660
   * vector work space reserved to LOOPCNT elements. Also
#line 3660
   * makes vectorisation easy */
#line 3660
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3660
    ni=Min(nelems-j,LOOPCNT);
#line 3660
    if (realign) {
#line 3660
      xp = tmp;
#line 3660
    } else {
#line 3660
      xp = (uint64 *) *xpp;
#line 3660
    }
#line 3660
   /* copy the next block */
#line 3660
#pragma cdir loopcnt=LOOPCNT
#line 3660
#pragma cdir shortloop
#line 3660
    for (i=0; i<ni; i++) {
#line 3660
      /* the normal case: */
#line 3660
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3660
     /* test for range errors (not always needed but do it anyway) */
#line 3660
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3660
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3660
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3660
    }
#line 3660
   /* copy workspace back if necessary */
#line 3660
    if (realign) {
#line 3660
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3660
      xp = (uint64 *) *xpp;
#line 3660
    }
#line 3660
   /* update xpp and tp */
#line 3660
    xp += ni;
#line 3660
    tp += ni;
#line 3660
    *xpp = (void*)xp;
#line 3660
  }
#line 3660
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3660

#line 3660
#else   /* not SX */
#line 3660

#line 3660
	char *xp = (char *) *xpp;
#line 3660
	int status = NC_NOERR;
#line 3660

#line 3660
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3660
	{
#line 3660
		int lstatus = ncx_put_ulonglong_schar(xp, tp, fillp);
#line 3660
		if (status == NC_NOERR) /* report the first encountered error */
#line 3660
			status = lstatus;
#line 3660
	}
#line 3660

#line 3660
	*xpp = (void *)xp;
#line 3660
	return status;
#line 3660
#endif
#line 3660
}
#line 3660

int
#line 3661
ncx_putn_ulonglong_short(void **xpp, size_t nelems, const short *tp, void *fillp)
#line 3661
{
#line 3661
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3661

#line 3661
 /* basic algorithm is:
#line 3661
  *   - ensure sane alignment of output data
#line 3661
  *   - copy (conversion happens automatically) input data
#line 3661
  *     to output
#line 3661
  *   - update tp to point at next unconverted input, and xpp to point
#line 3661
  *     at next location for converted output
#line 3661
  */
#line 3661
  long i, j, ni;
#line 3661
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3661
  uint64 *xp;
#line 3661
  int nrange = 0;         /* number of range errors */
#line 3661
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3661
  long cxp = (long) *((char**)xpp);
#line 3661

#line 3661
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3661
  /* sjl: manually stripmine so we can limit amount of
#line 3661
   * vector work space reserved to LOOPCNT elements. Also
#line 3661
   * makes vectorisation easy */
#line 3661
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3661
    ni=Min(nelems-j,LOOPCNT);
#line 3661
    if (realign) {
#line 3661
      xp = tmp;
#line 3661
    } else {
#line 3661
      xp = (uint64 *) *xpp;
#line 3661
    }
#line 3661
   /* copy the next block */
#line 3661
#pragma cdir loopcnt=LOOPCNT
#line 3661
#pragma cdir shortloop
#line 3661
    for (i=0; i<ni; i++) {
#line 3661
      /* the normal case: */
#line 3661
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3661
     /* test for range errors (not always needed but do it anyway) */
#line 3661
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3661
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3661
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3661
    }
#line 3661
   /* copy workspace back if necessary */
#line 3661
    if (realign) {
#line 3661
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3661
      xp = (uint64 *) *xpp;
#line 3661
    }
#line 3661
   /* update xpp and tp */
#line 3661
    xp += ni;
#line 3661
    tp += ni;
#line 3661
    *xpp = (void*)xp;
#line 3661
  }
#line 3661
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3661

#line 3661
#else   /* not SX */
#line 3661

#line 3661
	char *xp = (char *) *xpp;
#line 3661
	int status = NC_NOERR;
#line 3661

#line 3661
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3661
	{
#line 3661
		int lstatus = ncx_put_ulonglong_short(xp, tp, fillp);
#line 3661
		if (status == NC_NOERR) /* report the first encountered error */
#line 3661
			status = lstatus;
#line 3661
	}
#line 3661

#line 3661
	*xpp = (void *)xp;
#line 3661
	return status;
#line 3661
#endif
#line 3661
}
#line 3661

int
#line 3662
ncx_putn_ulonglong_int(void **xpp, size_t nelems, const int *tp, void *fillp)
#line 3662
{
#line 3662
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3662

#line 3662
 /* basic algorithm is:
#line 3662
  *   - ensure sane alignment of output data
#line 3662
  *   - copy (conversion happens automatically) input data
#line 3662
  *     to output
#line 3662
  *   - update tp to point at next unconverted input, and xpp to point
#line 3662
  *     at next location for converted output
#line 3662
  */
#line 3662
  long i, j, ni;
#line 3662
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3662
  uint64 *xp;
#line 3662
  int nrange = 0;         /* number of range errors */
#line 3662
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3662
  long cxp = (long) *((char**)xpp);
#line 3662

#line 3662
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3662
  /* sjl: manually stripmine so we can limit amount of
#line 3662
   * vector work space reserved to LOOPCNT elements. Also
#line 3662
   * makes vectorisation easy */
#line 3662
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3662
    ni=Min(nelems-j,LOOPCNT);
#line 3662
    if (realign) {
#line 3662
      xp = tmp;
#line 3662
    } else {
#line 3662
      xp = (uint64 *) *xpp;
#line 3662
    }
#line 3662
   /* copy the next block */
#line 3662
#pragma cdir loopcnt=LOOPCNT
#line 3662
#pragma cdir shortloop
#line 3662
    for (i=0; i<ni; i++) {
#line 3662
      /* the normal case: */
#line 3662
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3662
     /* test for range errors (not always needed but do it anyway) */
#line 3662
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3662
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3662
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3662
    }
#line 3662
   /* copy workspace back if necessary */
#line 3662
    if (realign) {
#line 3662
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3662
      xp = (uint64 *) *xpp;
#line 3662
    }
#line 3662
   /* update xpp and tp */
#line 3662
    xp += ni;
#line 3662
    tp += ni;
#line 3662
    *xpp = (void*)xp;
#line 3662
  }
#line 3662
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3662

#line 3662
#else   /* not SX */
#line 3662

#line 3662
	char *xp = (char *) *xpp;
#line 3662
	int status = NC_NOERR;
#line 3662

#line 3662
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3662
	{
#line 3662
		int lstatus = ncx_put_ulonglong_int(xp, tp, fillp);
#line 3662
		if (status == NC_NOERR) /* report the first encountered error */
#line 3662
			status = lstatus;
#line 3662
	}
#line 3662

#line 3662
	*xpp = (void *)xp;
#line 3662
	return status;
#line 3662
#endif
#line 3662
}
#line 3662

int
#line 3663
ncx_putn_ulonglong_long(void **xpp, size_t nelems, const long *tp, void *fillp)
#line 3663
{
#line 3663
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3663

#line 3663
 /* basic algorithm is:
#line 3663
  *   - ensure sane alignment of output data
#line 3663
  *   - copy (conversion happens automatically) input data
#line 3663
  *     to output
#line 3663
  *   - update tp to point at next unconverted input, and xpp to point
#line 3663
  *     at next location for converted output
#line 3663
  */
#line 3663
  long i, j, ni;
#line 3663
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3663
  uint64 *xp;
#line 3663
  int nrange = 0;         /* number of range errors */
#line 3663
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3663
  long cxp = (long) *((char**)xpp);
#line 3663

#line 3663
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3663
  /* sjl: manually stripmine so we can limit amount of
#line 3663
   * vector work space reserved to LOOPCNT elements. Also
#line 3663
   * makes vectorisation easy */
#line 3663
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3663
    ni=Min(nelems-j,LOOPCNT);
#line 3663
    if (realign) {
#line 3663
      xp = tmp;
#line 3663
    } else {
#line 3663
      xp = (uint64 *) *xpp;
#line 3663
    }
#line 3663
   /* copy the next block */
#line 3663
#pragma cdir loopcnt=LOOPCNT
#line 3663
#pragma cdir shortloop
#line 3663
    for (i=0; i<ni; i++) {
#line 3663
      /* the normal case: */
#line 3663
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3663
     /* test for range errors (not always needed but do it anyway) */
#line 3663
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3663
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3663
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3663
    }
#line 3663
   /* copy workspace back if necessary */
#line 3663
    if (realign) {
#line 3663
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3663
      xp = (uint64 *) *xpp;
#line 3663
    }
#line 3663
   /* update xpp and tp */
#line 3663
    xp += ni;
#line 3663
    tp += ni;
#line 3663
    *xpp = (void*)xp;
#line 3663
  }
#line 3663
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3663

#line 3663
#else   /* not SX */
#line 3663

#line 3663
	char *xp = (char *) *xpp;
#line 3663
	int status = NC_NOERR;
#line 3663

#line 3663
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3663
	{
#line 3663
		int lstatus = ncx_put_ulonglong_long(xp, tp, fillp);
#line 3663
		if (status == NC_NOERR) /* report the first encountered error */
#line 3663
			status = lstatus;
#line 3663
	}
#line 3663

#line 3663
	*xpp = (void *)xp;
#line 3663
	return status;
#line 3663
#endif
#line 3663
}
#line 3663

int
#line 3664
ncx_putn_ulonglong_float(void **xpp, size_t nelems, const float *tp, void *fillp)
#line 3664
{
#line 3664
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3664

#line 3664
 /* basic algorithm is:
#line 3664
  *   - ensure sane alignment of output data
#line 3664
  *   - copy (conversion happens automatically) input data
#line 3664
  *     to output
#line 3664
  *   - update tp to point at next unconverted input, and xpp to point
#line 3664
  *     at next location for converted output
#line 3664
  */
#line 3664
  long i, j, ni;
#line 3664
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3664
  uint64 *xp;
#line 3664
  int nrange = 0;         /* number of range errors */
#line 3664
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3664
  long cxp = (long) *((char**)xpp);
#line 3664

#line 3664
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3664
  /* sjl: manually stripmine so we can limit amount of
#line 3664
   * vector work space reserved to LOOPCNT elements. Also
#line 3664
   * makes vectorisation easy */
#line 3664
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3664
    ni=Min(nelems-j,LOOPCNT);
#line 3664
    if (realign) {
#line 3664
      xp = tmp;
#line 3664
    } else {
#line 3664
      xp = (uint64 *) *xpp;
#line 3664
    }
#line 3664
   /* copy the next block */
#line 3664
#pragma cdir loopcnt=LOOPCNT
#line 3664
#pragma cdir shortloop
#line 3664
    for (i=0; i<ni; i++) {
#line 3664
      /* the normal case: */
#line 3664
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3664
     /* test for range errors (not always needed but do it anyway) */
#line 3664
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3664
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3664
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3664
    }
#line 3664
   /* copy workspace back if necessary */
#line 3664
    if (realign) {
#line 3664
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3664
      xp = (uint64 *) *xpp;
#line 3664
    }
#line 3664
   /* update xpp and tp */
#line 3664
    xp += ni;
#line 3664
    tp += ni;
#line 3664
    *xpp = (void*)xp;
#line 3664
  }
#line 3664
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3664

#line 3664
#else   /* not SX */
#line 3664

#line 3664
	char *xp = (char *) *xpp;
#line 3664
	int status = NC_NOERR;
#line 3664

#line 3664
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3664
	{
#line 3664
		int lstatus = ncx_put_ulonglong_float(xp, tp, fillp);
#line 3664
		if (status == NC_NOERR) /* report the first encountered error */
#line 3664
			status = lstatus;
#line 3664
	}
#line 3664

#line 3664
	*xpp = (void *)xp;
#line 3664
	return status;
#line 3664
#endif
#line 3664
}
#line 3664

int
#line 3665
ncx_putn_ulonglong_double(void **xpp, size_t nelems, const double *tp, void *fillp)
#line 3665
{
#line 3665
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3665

#line 3665
 /* basic algorithm is:
#line 3665
  *   - ensure sane alignment of output data
#line 3665
  *   - copy (conversion happens automatically) input data
#line 3665
  *     to output
#line 3665
  *   - update tp to point at next unconverted input, and xpp to point
#line 3665
  *     at next location for converted output
#line 3665
  */
#line 3665
  long i, j, ni;
#line 3665
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3665
  uint64 *xp;
#line 3665
  int nrange = 0;         /* number of range errors */
#line 3665
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3665
  long cxp = (long) *((char**)xpp);
#line 3665

#line 3665
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3665
  /* sjl: manually stripmine so we can limit amount of
#line 3665
   * vector work space reserved to LOOPCNT elements. Also
#line 3665
   * makes vectorisation easy */
#line 3665
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3665
    ni=Min(nelems-j,LOOPCNT);
#line 3665
    if (realign) {
#line 3665
      xp = tmp;
#line 3665
    } else {
#line 3665
      xp = (uint64 *) *xpp;
#line 3665
    }
#line 3665
   /* copy the next block */
#line 3665
#pragma cdir loopcnt=LOOPCNT
#line 3665
#pragma cdir shortloop
#line 3665
    for (i=0; i<ni; i++) {
#line 3665
      /* the normal case: */
#line 3665
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3665
     /* test for range errors (not always needed but do it anyway) */
#line 3665
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3665
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3665
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3665
    }
#line 3665
   /* copy workspace back if necessary */
#line 3665
    if (realign) {
#line 3665
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3665
      xp = (uint64 *) *xpp;
#line 3665
    }
#line 3665
   /* update xpp and tp */
#line 3665
    xp += ni;
#line 3665
    tp += ni;
#line 3665
    *xpp = (void*)xp;
#line 3665
  }
#line 3665
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3665

#line 3665
#else   /* not SX */
#line 3665

#line 3665
	char *xp = (char *) *xpp;
#line 3665
	int status = NC_NOERR;
#line 3665

#line 3665
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3665
	{
#line 3665
		int lstatus = ncx_put_ulonglong_double(xp, tp, fillp);
#line 3665
		if (status == NC_NOERR) /* report the first encountered error */
#line 3665
			status = lstatus;
#line 3665
	}
#line 3665

#line 3665
	*xpp = (void *)xp;
#line 3665
	return status;
#line 3665
#endif
#line 3665
}
#line 3665

int
#line 3666
ncx_putn_ulonglong_longlong(void **xpp, size_t nelems, const longlong *tp, void *fillp)
#line 3666
{
#line 3666
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3666

#line 3666
 /* basic algorithm is:
#line 3666
  *   - ensure sane alignment of output data
#line 3666
  *   - copy (conversion happens automatically) input data
#line 3666
  *     to output
#line 3666
  *   - update tp to point at next unconverted input, and xpp to point
#line 3666
  *     at next location for converted output
#line 3666
  */
#line 3666
  long i, j, ni;
#line 3666
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3666
  uint64 *xp;
#line 3666
  int nrange = 0;         /* number of range errors */
#line 3666
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3666
  long cxp = (long) *((char**)xpp);
#line 3666

#line 3666
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3666
  /* sjl: manually stripmine so we can limit amount of
#line 3666
   * vector work space reserved to LOOPCNT elements. Also
#line 3666
   * makes vectorisation easy */
#line 3666
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3666
    ni=Min(nelems-j,LOOPCNT);
#line 3666
    if (realign) {
#line 3666
      xp = tmp;
#line 3666
    } else {
#line 3666
      xp = (uint64 *) *xpp;
#line 3666
    }
#line 3666
   /* copy the next block */
#line 3666
#pragma cdir loopcnt=LOOPCNT
#line 3666
#pragma cdir shortloop
#line 3666
    for (i=0; i<ni; i++) {
#line 3666
      /* the normal case: */
#line 3666
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3666
     /* test for range errors (not always needed but do it anyway) */
#line 3666
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3666
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3666
      nrange += tp[i] > X_UINT64_MAX || tp[i] < 0;
#line 3666
    }
#line 3666
   /* copy workspace back if necessary */
#line 3666
    if (realign) {
#line 3666
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3666
      xp = (uint64 *) *xpp;
#line 3666
    }
#line 3666
   /* update xpp and tp */
#line 3666
    xp += ni;
#line 3666
    tp += ni;
#line 3666
    *xpp = (void*)xp;
#line 3666
  }
#line 3666
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3666

#line 3666
#else   /* not SX */
#line 3666

#line 3666
	char *xp = (char *) *xpp;
#line 3666
	int status = NC_NOERR;
#line 3666

#line 3666
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3666
	{
#line 3666
		int lstatus = ncx_put_ulonglong_longlong(xp, tp, fillp);
#line 3666
		if (status == NC_NOERR) /* report the first encountered error */
#line 3666
			status = lstatus;
#line 3666
	}
#line 3666

#line 3666
	*xpp = (void *)xp;
#line 3666
	return status;
#line 3666
#endif
#line 3666
}
#line 3666

int
#line 3667
ncx_putn_ulonglong_uchar(void **xpp, size_t nelems, const uchar *tp, void *fillp)
#line 3667
{
#line 3667
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3667

#line 3667
 /* basic algorithm is:
#line 3667
  *   - ensure sane alignment of output data
#line 3667
  *   - copy (conversion happens automatically) input data
#line 3667
  *     to output
#line 3667
  *   - update tp to point at next unconverted input, and xpp to point
#line 3667
  *     at next location for converted output
#line 3667
  */
#line 3667
  long i, j, ni;
#line 3667
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3667
  uint64 *xp;
#line 3667
  int nrange = 0;         /* number of range errors */
#line 3667
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3667
  long cxp = (long) *((char**)xpp);
#line 3667

#line 3667
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3667
  /* sjl: manually stripmine so we can limit amount of
#line 3667
   * vector work space reserved to LOOPCNT elements. Also
#line 3667
   * makes vectorisation easy */
#line 3667
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3667
    ni=Min(nelems-j,LOOPCNT);
#line 3667
    if (realign) {
#line 3667
      xp = tmp;
#line 3667
    } else {
#line 3667
      xp = (uint64 *) *xpp;
#line 3667
    }
#line 3667
   /* copy the next block */
#line 3667
#pragma cdir loopcnt=LOOPCNT
#line 3667
#pragma cdir shortloop
#line 3667
    for (i=0; i<ni; i++) {
#line 3667
      /* the normal case: */
#line 3667
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3667
     /* test for range errors (not always needed but do it anyway) */
#line 3667
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3667
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3667
      nrange += tp[i] > X_UINT64_MAX ;
#line 3667
    }
#line 3667
   /* copy workspace back if necessary */
#line 3667
    if (realign) {
#line 3667
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3667
      xp = (uint64 *) *xpp;
#line 3667
    }
#line 3667
   /* update xpp and tp */
#line 3667
    xp += ni;
#line 3667
    tp += ni;
#line 3667
    *xpp = (void*)xp;
#line 3667
  }
#line 3667
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3667

#line 3667
#else   /* not SX */
#line 3667

#line 3667
	char *xp = (char *) *xpp;
#line 3667
	int status = NC_NOERR;
#line 3667

#line 3667
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3667
	{
#line 3667
		int lstatus = ncx_put_ulonglong_uchar(xp, tp, fillp);
#line 3667
		if (status == NC_NOERR) /* report the first encountered error */
#line 3667
			status = lstatus;
#line 3667
	}
#line 3667

#line 3667
	*xpp = (void *)xp;
#line 3667
	return status;
#line 3667
#endif
#line 3667
}
#line 3667

int
#line 3668
ncx_putn_ulonglong_ushort(void **xpp, size_t nelems, const ushort *tp, void *fillp)
#line 3668
{
#line 3668
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3668

#line 3668
 /* basic algorithm is:
#line 3668
  *   - ensure sane alignment of output data
#line 3668
  *   - copy (conversion happens automatically) input data
#line 3668
  *     to output
#line 3668
  *   - update tp to point at next unconverted input, and xpp to point
#line 3668
  *     at next location for converted output
#line 3668
  */
#line 3668
  long i, j, ni;
#line 3668
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3668
  uint64 *xp;
#line 3668
  int nrange = 0;         /* number of range errors */
#line 3668
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3668
  long cxp = (long) *((char**)xpp);
#line 3668

#line 3668
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3668
  /* sjl: manually stripmine so we can limit amount of
#line 3668
   * vector work space reserved to LOOPCNT elements. Also
#line 3668
   * makes vectorisation easy */
#line 3668
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3668
    ni=Min(nelems-j,LOOPCNT);
#line 3668
    if (realign) {
#line 3668
      xp = tmp;
#line 3668
    } else {
#line 3668
      xp = (uint64 *) *xpp;
#line 3668
    }
#line 3668
   /* copy the next block */
#line 3668
#pragma cdir loopcnt=LOOPCNT
#line 3668
#pragma cdir shortloop
#line 3668
    for (i=0; i<ni; i++) {
#line 3668
      /* the normal case: */
#line 3668
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3668
     /* test for range errors (not always needed but do it anyway) */
#line 3668
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3668
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3668
      nrange += tp[i] > X_UINT64_MAX ;
#line 3668
    }
#line 3668
   /* copy workspace back if necessary */
#line 3668
    if (realign) {
#line 3668
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3668
      xp = (uint64 *) *xpp;
#line 3668
    }
#line 3668
   /* update xpp and tp */
#line 3668
    xp += ni;
#line 3668
    tp += ni;
#line 3668
    *xpp = (void*)xp;
#line 3668
  }
#line 3668
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3668

#line 3668
#else   /* not SX */
#line 3668

#line 3668
	char *xp = (char *) *xpp;
#line 3668
	int status = NC_NOERR;
#line 3668

#line 3668
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3668
	{
#line 3668
		int lstatus = ncx_put_ulonglong_ushort(xp, tp, fillp);
#line 3668
		if (status == NC_NOERR) /* report the first encountered error */
#line 3668
			status = lstatus;
#line 3668
	}
#line 3668

#line 3668
	*xpp = (void *)xp;
#line 3668
	return status;
#line 3668
#endif
#line 3668
}
#line 3668

int
#line 3669
ncx_putn_ulonglong_uint(void **xpp, size_t nelems, const uint *tp, void *fillp)
#line 3669
{
#line 3669
#if defined(_SX) && _SX != 0 && X_SIZEOF_UINT64 == SIZEOF_UINT64
#line 3669

#line 3669
 /* basic algorithm is:
#line 3669
  *   - ensure sane alignment of output data
#line 3669
  *   - copy (conversion happens automatically) input data
#line 3669
  *     to output
#line 3669
  *   - update tp to point at next unconverted input, and xpp to point
#line 3669
  *     at next location for converted output
#line 3669
  */
#line 3669
  long i, j, ni;
#line 3669
  uint64 tmp[LOOPCNT];        /* in case input is misaligned */
#line 3669
  uint64 *xp;
#line 3669
  int nrange = 0;         /* number of range errors */
#line 3669
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3669
  long cxp = (long) *((char**)xpp);
#line 3669

#line 3669
  realign = (cxp & 7) % SIZEOF_UINT64;
#line 3669
  /* sjl: manually stripmine so we can limit amount of
#line 3669
   * vector work space reserved to LOOPCNT elements. Also
#line 3669
   * makes vectorisation easy */
#line 3669
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3669
    ni=Min(nelems-j,LOOPCNT);
#line 3669
    if (realign) {
#line 3669
      xp = tmp;
#line 3669
    } else {
#line 3669
      xp = (uint64 *) *xpp;
#line 3669
    }
#line 3669
   /* copy the next block */
#line 3669
#pragma cdir loopcnt=LOOPCNT
#line 3669
#pragma cdir shortloop
#line 3669
    for (i=0; i<ni; i++) {
#line 3669
      /* the normal case: */
#line 3669
      xp[i] = (uint64) Max( X_UINT64_MIN, Min(X_UINT64_MAX, (uint64) tp[i]));
#line 3669
     /* test for range errors (not always needed but do it anyway) */
#line 3669
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3669
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3669
      nrange += tp[i] > X_UINT64_MAX ;
#line 3669
    }
#line 3669
   /* copy workspace back if necessary */
#line 3669
    if (realign) {
#line 3669
      memcpy(*xpp, tmp, (size_t)*ni*X_SIZEOF_UINT64);
#line 3669
      xp = (uint64 *) *xpp;
#line 3669
    }
#line 3669
   /* update xpp and tp */
#line 3669
    xp += ni;
#line 3669
    tp += ni;
#line 3669
    *xpp = (void*)xp;
#line 3669
  }
#line 3669
  return nrange == 0 ? NC_NOERR : NC_ERANGE;
#line 3669

#line 3669
#else   /* not SX */
#line 3669

#line 3669
	char *xp = (char *) *xpp;
#line 3669
	int status = NC_NOERR;
#line 3669

#line 3669
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT64, tp++)
#line 3669
	{
#line 3669
		int lstatus = ncx_put_ulonglong_uint(xp, tp, fillp);
#line 3669
		if (status == NC_NOERR) /* report the first encountered error */
#line 3669
			status = lstatus;
#line 3669
	}
#line 3669

#line 3669
	*xpp = (void *)xp;
#line 3669
	return status;
#line 3669
#endif
#line 3669
}
#line 3669



/*
 * Other aggregate conversion functions.
 */

/* text */

int
ncx_getn_text(const void **xpp, size_t nelems, char *tp)
{
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 3681
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3681
	return NC_NOERR;
#line 3681

}

int
ncx_pad_getn_text(const void **xpp, size_t nelems, char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3687

#line 3687
	if (rndup)
#line 3687
		rndup = X_ALIGN - rndup;
#line 3687

#line 3687
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 3687
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3687

#line 3687
	return NC_NOERR;
#line 3687

}

int
ncx_putn_text(void **xpp, size_t nelems, const char *tp)
{
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3693
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3693

#line 3693
	return NC_NOERR;
#line 3693

}

int
ncx_pad_putn_text(void **xpp, size_t nelems, const char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3699

#line 3699
	if (rndup)
#line 3699
		rndup = X_ALIGN - rndup;
#line 3699

#line 3699
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3699
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3699

#line 3699
	if (rndup)
#line 3699
	{
#line 3699
		(void) memcpy(*xpp, nada, (size_t)rndup);
#line 3699
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3699
	}
#line 3699

#line 3699
	return NC_NOERR;
#line 3699

}


/* opaque */

int
ncx_getn_void(const void **xpp, size_t nelems, void *tp)
{
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 3708
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3708
	return NC_NOERR;
#line 3708

}

int
ncx_pad_getn_void(const void **xpp, size_t nelems, void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3714

#line 3714
	if (rndup)
#line 3714
		rndup = X_ALIGN - rndup;
#line 3714

#line 3714
	(void) memcpy(tp, *xpp, (size_t)nelems);
#line 3714
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3714

#line 3714
	return NC_NOERR;
#line 3714

}

int
ncx_putn_void(void **xpp, size_t nelems, const void *tp)
{
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3720
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3720

#line 3720
	return NC_NOERR;
#line 3720

}

int
ncx_pad_putn_void(void **xpp, size_t nelems, const void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3726

#line 3726
	if (rndup)
#line 3726
		rndup = X_ALIGN - rndup;
#line 3726

#line 3726
	(void) memcpy(*xpp, tp, (size_t)nelems);
#line 3726
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3726

#line 3726
	if (rndup)
#line 3726
	{
#line 3726
		(void) memcpy(*xpp, nada, (size_t)rndup);
#line 3726
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3726
	}
#line 3726

#line 3726
	return NC_NOERR;
#line 3726

}
